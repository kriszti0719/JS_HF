# Chapter 1: Introduction

Programming languages. There's a lot of them, and it could be argued that all of them have their uses, their pros and cons.

There are things however that are generally considered positive attributes for languages, and many modern languages are converging in terms of these attributes. During this course, we'll be studying Kotlin, which is a great example of a modern, well-rounded language, but you'll see many similar features and ideas in other languages such as Swift, C#, or Groovy, just to name a few examples.

Why should you start using Kotlin specifically, out of all these languages? Its creators often say that they don't really want to push Kotlin on anyone, they want it to speak for itself. It's a pragmatic language, which they believe solves real problems. Try it, see if it solves problems that you're facing in other languages, and if that's valuable for you. And there really is no substitute for seeing what it's like to use in practice.

The creators also proudly admit that almost none of the features in Kotlin have been invented from scratch. We all stand on the shoulders of giants, there's nothing new under the sun, and [everything is a remix](https://www.youtube.com/watch?v=nJPERZDfyWc). Great creations always take existing pieces of work, and then copy, transform, and combine them into something new. Creating a language is no different from your everyday coding in this regard.

> The original lead language designer for Kotlin, Andrey Breslav gave an [excellent talk](https://www.youtube.com/watch?v=7z_K-hTTeqI) on this in May 2022. Best watched once you're already familiar with Kotlin.

What does make Kotlin unique is how well its features fit together, and what features were omitted on purpose, because they would have broken the language's consistency, or go against its core tenets.

So what are some of these desired attributes that Kotlin aims to achieve?

- **Conciseness**, i.e. less code for expressing the same ideas. Not for the sake of conciseness itself, but to improve **readability** compared to more verbose languages. Not having to write [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code) makes coding faster, and more importantly, not having that boilerplate in your codebase makes navigating and reading your existing code a lot easier.
- **Safety** means that your program misbehaves as little as possible. There's various ways to achieve such safety at the language level. Kotlin does this by having a *strong, static type system*, which reveals most mistakes at compile time (at edit time, really, in almost all cases), rather than letting your code fail at runtime.
- **Interoperability** is another driving principle of Kotlin. It runs on multiple platforms, and on each of them it cooperates with the native environment and libraries as much as possible. We'll look specifically at how it interops with Java when running it on the JVM.
- **Pragmatism** is a way of saying that Kotlin is not an academic language. It's meant for use in real industrial settings, and to solve real, practical problems.
- **Tooling** is something you might overlook at first when evaluating languages, but it's something that can make a good language a true pleasure to use. While there are still proud Vim warriors out there, most developers are used to using rich IDEs for their coding needs, and Kotlin's tooling is as first-party as it gets.

This brings us to Kotlin's origin story.

## History

[JetBrains](https://www.jetbrains.com/), the company behind the IntelliJ platform (and [all the IDEs that are built on it](https://www.jetbrains.com/products/#type=ide-vs), such as IntelliJ IDEA, Android Studio, CLion, PyCharm, and so on) has been developing their products in Java for a decade by 2010. During this time, they've built up immense experience in creating tooling for programming languages, and they also got very familiar with Java's pros and cons.

It was at this time that they started looking for a new language for their own development needs that was better than Java. They've evaluated the existing languages that ran on the Java Virtual Machine (JVM), but they didn't find one at the time that would've satisfied their needs.

>The closest candidate at the time was Scala, but it was notoriously difficult to make tooling for, and it suffered from lengthy compilation times.
 
So they've done what anyone else would've done at this point - created their own.

This, in general, is not a great idea - it's akin to writing your own date library or rolling your own crypto. But with the tooling and language expertise of JetBrains, as well as their strong market position, they've deemed it a viable project, and got started on it.

Some highlights of the language's development:

- 2010: internal development started under the name "JetLang".
- July 2011: [announced to the public](https://blog.jetbrains.com/kotlin/2011/07/hello-world-2/) as Project Kotlin.
- February 2016: [Kotlin 1.0](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), the first stable release.
- March 2017: [version 1.1](https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/), the first major feature update to Kotlin, with initial JavaScript support.
- May 2017: first-class Android support for Kotlin announced at Google I/O.
- November 2017: [version 1.2](https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/), with the first version of multiplatform projects.
- October 2018: [version 1.3](https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/), containing stable coroutines.
- May 2019: Android development going [Kotlin-first](https://developer.android.com/kotlin/first) announced at Google I/O.
- August 2020: [version 1.4](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/), introducing the foundations for a new compiler, and some neat new language features.
- May 2021: [version 1.5](https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/), stabilizing inline classes, adding improvements to sealed types, and stabilizing the new JVM compiler backend.
- November 2021: [version 1.6](https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/), with a preview of the new Kotlin/Native memory model, exhaustive when statements, type inference improvements, and lots of new stable Standard Library APIs.
- June 2022: [version 1.7](https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/), with the new K2 compiler available in alpha, , and yet again many new stabilized language features.  

> Watch [Ten Years of Kotlin: The Story of The Programming Language](https://www.youtube.com/watch?v=uE-1oF9PyiY), a documentary about the language made for its 10-year anniversary.

> Read the blog post from Google [celebrating 5 years of Kotlin on Android](https://android-developers.googleblog.com/2022/08/celebrating-5-years-of-kotlin-on-android.html).

Let's take a moment to review some of the previously mentioned language attributes, with this history now in mind:

- **Interoperability**: JetBrains had hundreds of thousands of lines of Java code in IntelliJ that they could never just throw away. The new code written in Kotlin and the old code written in Java had to be able to communicate efficiently and effortlessly.
- **Pragmatism**: The language was born to serve a specific need, a real industrial project.
- **Tooling**: Language and tooling could be developed side-by-side, in-house, and complement each other perfectly.

Who's using the language? A very rapidly rising number of developers - millions, by now (see [2018 stats](https://youtu.be/PsaFVLr8t4E?t=366), [2020 stats](https://youtu.be/pD58Dw17CLk?t=200)). [(About 6 million as of August 2020.)](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/#compiler-and-ecosystem) 

What are they using the language for? A lot of the focus is on Android development, but Kotlin has a lot of traction outside of mobile too. You can take a look at the [Kotlin Census (2020)](https://www.jetbrains.com/lp/kotlin-census-2020/) or the [State of Developer Ecosystem survey (2021)](https://www.jetbrains.com/lp/devecosystem-2021/kotlin/) ran by JetBrains for some official statistics.

Kotlin is an open-source language. Everything around it - the compiler, the standard library, docs, and so on - are available [on GitHub](https://github.com/jetbrains/kotlin). JetBrains isn't the sole owner and controller of the language, its development is governed by the [Kotlin Foundation](https://kotlinlang.org/foundation/kotlin-foundation.html), co-founded by JetBrains and Google.

Being an open source project, it's rare that surprise product announcements for Kotlin appear, as everything is developed out in the open in the first place. You can take a look at what's planned to be coming up for Kotlin in the next few months (or years) on the [Kotlin roadmap](https://kotlinlang.org/roadmap.html).

## Compilation

Kotlin now positions itself as a modern, multiplatform [application programming language](https://medium.com/@elizarov/application-programming-language-ff7f0063c16). Its original and primary target is the JVM, but Kotlin code can also be compiled to [JavaScript](https://kotlinlang.org/docs/js-overview.html), and even [native](https://kotlinlang.org/docs/native-overview.html) binaries.

In this course, we'll focus on using Kotlin on the JVM. When compiling `.kt` Kotlin sources, the output here is *bytecode* in the form of `.class` files - the same as when compiling Java code.

![Compiling Java or Kotlin to bytecode.](./images/1_kotlin_and_java_basic_compilation.png)

What makes this compilation interesting is the strong interoperability between Kotlin and Java. Code written in one language can call into the other one completely seamlessly. So how can this work out during compilation, if we need to compile Java and Kotlin with their respective compilers? How would the Java compiler know about declarations in Kotlin sources, and vice versa?

Here's how the compilation actually works ([credits to Jake Wharton](https://youtu.be/CtZL_IjR5Ww?t=378)):

![Compiling Java and Kotlin, interop details](./images/1_kotlin_and_java_interop_compilation.png)

The Kotlin compiler, `kotlinc` runs first, and it parses both Java and Kotlin sources. This allows it to compile Kotlin code that references declarations in the Java sources. Next, the Java compiler `javac` is invoked. This again parses the Java sources, plus it receives the output of the Kotlin compiler as already compiled bytecode, which is what allows Java sources to reference Kotlin declarations. Finally, the merged output of these two compilers is bytecode in `.class` files.

## Tooling and environment

Unsurprisingly, JetBrains works very hard to provide the best possible tooling for Kotlin. After all, this is their business angle with the language: building products with it, and selling the tooling for it.

Therefore, [IntelliJ IDEA](https://www.jetbrains.com/idea/) is the definitive IDE for Kotlin development, although other editors support it as well. You can also download the Kotlin compiler and [compile it from the command line](https://kotlinlang.org/docs/command-line.html), if that's your thing.

> [Android Studio](https://developer.android.com/studio) is based on IntelliJ IDEA and offers the same support for Kotlin (although new features from IDEA take a while to trickle down to Studio releases).

Most non-trivial JVM projects use build tools instead of invoking the compiler directly. Kotlin supports both [Maven](https://kotlinlang.org/docs/maven.html) and [Gradle](https://kotlinlang.org/docs/gradle.html), which are the popular build tools in the JVM world. Gradle, which also happens to be the de-facto build system for Android projects, is generally preferred.

> You can even write your Gradle build scripts [in Kotlin](https://docs.gradle.org/current/userguide/kotlin_dsl.html).

IntelliJ has a suite of convenient tools built-in for working with Kotlin. Let's take a quick look at each of these before we get to the code.

### Scratch files

[Scratch files](https://www.jetbrains.com/help/idea/scratches.html) are temporary files that you can use to quickly write and run Kotlin code. They are not associated with any project, and they reside outside your project directory, so they won't be under version control, but only stored locally.

![A simple Kotlin scratch file](./images/1_scratch_file.png)

Despite this, you can reference code in your current project from a scratch file, if you need to. You can create instances of classes, call existing functions, and so on. This makes it really, really easy to perform quick experiments.

To create a scratch file, go to *File -> New -> Scratch File*.

### REPL

Read-Eval-Print Loops, or REPLs, are usually a tool for scripting languages. They allow you to write and execute code line by line, to quickly iterate and try out various things in the language. 

Kotlin comes with this tool as well, which you can either run from the command line, or right inside IntelliJ IDEA (*Tools -> Kotlin -> Kotlin REPL*). Just like with scratch files, you can call into code in your currently open project from the REPL.

![The Kotlin REPL](./images/1_repl.png)

### Decompiler

Sometimes the easiest way to understand what a certain piece of Kotlin code does is to look at what it compiles to. The bytecode that the compiler will output for a given Kotlin source file can be viewed by going to *Tools -> Kotlin -> Show Kotlin Bytecode*.

![The Kotlin bytecode viewer](./images/1_bytecode_viewer.png)

While this can help you figure out what's happening in some cases, most people can't read bytecode very well (nor should they be required to), so there's an even more important feature here. You can decompile this bytecode to Java by choosing the *Decompile* option on the bytecode viewer panel.

![Decompiled Kotlin bytecode](./images/1_decompiled.png)

This gives you a Java source file, which is an attempt at writing Java code that would result in the same compilation result. Keep in mind that this is a best effort step, and not all the bytecode that the Kotlin compiler produces can be represented by Java code in a straightforward way. Most of the time, this decompiled Java code will contain at least a few errors. Still, the decompiler is a very useful tool for gaining a deeper understanding of Kotlin.

### Java-to-Kotlin converter

The Kotlin plugin IntelliJ IDEA also ships with a feature that lets you go the other way around: take existing Java code, and automatically convert it to Kotlin. This comes in really handy when migrating a project to Kotlin. 

![Example of Java-to-Kotlin conversion](./images/1_java_to_kotlin.png)

> You'll find this action under  *Code -> Convert Java File to Kotlin File* when you have a Java file open.

Keep in mind that just like the decompiler, this isn't a perfect tool either. Occasionally the converted Kotlin code won't compile straight away, or it will have some bugs in it. Often it might be messy, Java-like, and require some cleanup to make it more _idiomatic_ Kotlin. But it's usually a good start.

The best use of this feature is perhaps for learning purposes. If you don't know how to express something in Kotlin, but you can write it down in Java, you can always run it through the converter! Again, this might not give you the best possible Kotlin solution, but it'll at least give you one.

> Bonus: pasting Java code into a `.kt` file will also prompt you about converting that code into Kotlin while the paste operation is happening.

## Basic syntax

### Variables

Let's take the first thing you'd want to do in a language, and declare a variable!

>Note: In the beginning, we'll look at the Java equivalents of the Kotlin code in case you need them for reference. Remember, Kotlin *does not* actually compile to Java!

```kotlin
var x: Int = 0              // int x = 0;
```

Let's take note of a couple things:
- You declare variables with the `var` keyword.
- The variable name *precedes* the type.
- Semicolons are... allowed, but optional (in practice, this means that you won't use them).

You should only use `var` when you explicitly want a *mutable* **var**iable.

If that's not the case, use `val` instead, which declares an *immutable* **val**ue.

```kotlin
val y: Int = 1              // final int y = 1;
```

That's better. When declaring variables, `val` should be your default choice.

We can make another improvement to this declaration, by making use of *type inference*.

```kotlin
val z = 2                   // final int z = 2;
```

Kotlin is statically typed and has a very strong, strict type system. This variable is still has a type of `Int` just like before, but you can omit the type from your code, as the compiler can *infer* it itself from context (in this case, from the value being assigned). You'll see a lot of this happening in Kotlin code.

This mechanism means you'll never type out something as verbose as this again:

```java
final FileInputStream fis = new FileInputStream("filename");
```

Instead, you'll have the Kotlin compiler figure out the type for you in almost all cases:

```kotlin
val fis = FileInputStream("filename")
```

> Note: You may also notice here that there's no `new` keyword in Kotlin for constructor calls.

The simple number literal we had before was inferred to be an `Int`, but you can also use special formats to create other basic numerical types:

```kotlin
val myLong = 1L             // final long myLong = 1;
val myFloat = 1f            // final float myFloat = 1;
val myDouble = 1.0          // final double myDouble = 1;
```

#### Primitives vs boxed types

Java - and the JVM itself - makes a distinction between primitive types and boxed types. Primitives (`int`, `double`, `boolean`, and so on) are much more efficient, as they live on the stack, and only take up the space required to represent them.

The corresponding boxed classes (`Integer`, `Double`, `Boolean`, and more) are reference types, so only references to them are stored on the stack, and their actual instances live on the heap. These instances are also larger than the primitive's size, [sometimes significantly](https://dzone.com/articles/whats-wrong-with-java-boxed-numbers).

Using the primitives is sufficient in most cases, but sometimes the boxed variants are still required. This can happen when you *need* an object for some reason, for example when dealing with generics (there's no `List<int>` in Java!). The boxed instances also have various methods you can call on them, which you can't do with a primitive value.

So where does Kotlin's `Int` (and `Boolean`, and `Double`, and other numeric types) fit in this picture? Well, just like `Int` is sort of between `int` and `Integer` by its looks, its semantics lie somewhere in the middle as well. On the Kotlin language level, we don't make a distinction about primitives and boxed types. The compiler will use a primitive whenever it's possible, and use a boxed type automatically when it needs to.

This doesn't exactly mean that we *never* have to think about this problem, because the performance considerations of what happens under the hood are still important in some cases - but we won't use different types to represent these things in our code.

#### Strings

The last basic type that's worth mentioning here is `String`, which behaves much like a `String` in Java. A literal is declared with quotation marks:

```kotlin
val name = "Sarah"           // final String name = "Sarah";
```

Kotlin also supports *string templates*, which is an easy way to place values inside a `String`, without having to use lots of concatenation:

```kotlin
val sum = "$x + $y + $z = ${x + y + z}"     // outputs "0 + 1 + 2 = 3"
```

Single values can be inserted with just a `$` prefix, and expressions can be computed using additional curly braces `${...}`.

### Functions

#### Our first function

Let's move on to functions, something we'll discuss *a lot* in Kotlin. First, we'll convert this very simple function - which just adds two numbers together, and returns the result - to Kotlin.

```java
int add(int x, int y) {
    return x + y;
}
```

Here's a Kotlin equivalent of this code:

```kotlin
fun add(x: Int, y: Int): Int {
    return x + y
}
```

Some important observations about the syntax:

- We use the `fun` keyword to declare a function. (Yay! 🎉)
- The names precede the types in the parameter list, just like we've seen with variables.
- The return type comes after the rest of the function header as well, following the `name: Type` structure yet again.

For functions as simple as this one, that only evaluate a single expression and return its value, Kotlin offers a shorthand syntax called an *expression body*:

```kotlin
fun add(x: Int, y: Int): Int = x + y
```

Type inference can also be used here, since the type of the `x + y` expression, an addition of two `Int` values is known by the compiler to be an  `Int`:

```kotlin
fun add(x: Int, y: Int) = x + y
```

This function still returns `Int`, but we aren't stating this explicitly.

> Use expression bodies with care, only when the function's implementation is truly a simple one-liner. Otherwise, don't be afraid of using a traditional function body.

#### Functions that don't return anything

There's another case where the return type can be omitted, this is when the function doesn't return anything. This is equivalent to a function having a `void` return type in Java.

```kotlin
fun noReturnValue() {
    /* Empty */
}
```

Technically, functions like this still do return *something* in Kotlin. The language doesn't have the super special case that Java has with `void` functions. Functions where you don't return a meaningful value - like the one above - will implicitly have a return type of `Unit`. You can also write this out explicitly, although the IDE will warn you that it's unnecessary.

```kotlin
fun noReturnValue(): Unit {
    /* Empty */
}
```

`Unit` is an empty class that has a single instance. It's a dummy object with no properties or methods. This makes it perfect for representing "no meaningful value". Returning this from methods like the one above yields some... interesting possibilities. For example, you can assign the return value of this function to a variable, just like you could with any other function that returns any regular type.

```kotlin
val result: Unit = noReturnValue()
println(result) // kotlin.Unit
```

Again, there's no hard distinction between functions that do return something, and functions that don't. If there's nothing to return, we're indicating that by returning `Unit` implicitly (both the declaration of the return type and the actual `return` statement at the end of the function may be implicit).

We'll see that this type also plays well with generics. We won't need the weird distinction that Java makes between `void` and `Void`, we'll just use `Unit` for everything. But we're getting ahead of ourselves. Spoilers!

#### Default and named parameter values

Functions come with some neat new features in Kotlin compared to Java functions. One of these is [*default arguments*](https://kotlinlang.org/docs/functions.html#default-arguments).

> *Arguments* are the concrete values passed in for the *parameters* that a function declares. However, the words "argument" and "parameter" are often used interchangeably.

To demonstrate, let's write a function that mimics the registration of a user.

```kotlin
fun register( 
    username: String, 
    password: String = "12345678", 
    email: String = "",
) {
  // Pretend that there's something useful here.
  println("$username $password $email")
}
```

This function takes three parameters, and it defines default argument values for the last two. Note the formatting of each parameter on a separate line, this is conventional in Kotlin for functions with long signatures.

> Since Kotlin 1.4, Kotlin allows [trailing commas](https://kotlinlang.org/docs/reference/whatsnew14.html#trailing-comma) in places like parameter lists. You might have noticed this in the previous snippet. This makes it easier to rearrange lines (even in simple text editors), and also makes version control history neater.

Having these default arguments in place means that we can call this method with three, two, or just one argument. For any parameters that are not provided, the default value will be used instead.

```kotlin
register("piglet", "0h_d34r", "piglet@hundred-acre-wood.co.uk")
register("owl", "tea_party")
register("eeyore")
```

Another feature that works nicely in conjunction with default values is [*named arguments*](https://kotlinlang.org/docs/functions.html#named-arguments). For any function defined in Kotlin, you can optionally specify the names of the arguments when you call the function. Our previous calls could be made like this (note the formatting of the lengthy call, on multiple lines):

```kotlin
register(
    username = "piglet",
    password = "0h_d34r",
    email = "piglet@hundred-acre-wood.co.uk"
)
register(username = "owl", password = "tea_party")
register(username = "eeyore")
```

Naming arguments - especially in cases like this where several of the same type are being passed in - can help us avoid mixing up their order, making the code safer. It also improves readability, as which argument fulfills which parameter is immediately clear at the call site.

Combined with default values, we can also use this to omit arguments that have default values, but are not at the end of the parameter list:

```kotlin
register("tigger", email = "tigger@hundred-acre-wood-co.uk")
```

Here, we're passing in a value for `email`, but opting to use the default value for the `password` parameter.

> By default, Java clients of a Kotlin function with default arguments must provide all arguments, and can't make use of the default arguments. However, you can add the [`@JvmOverloads`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/) annotation to improve interoperability:
>
> ```kotlin
> @JvmOverloads
> fun register( 
>     username: String, 
>     password: String = "12345678", 
>     email: String = "",
> )
> ```
>
> This will generate overloaded methods that are callable by Java clients. For each parameter with a default value (starting from the end of the parameter list), a new method will be generated, which omits that parameter, and uses the default value for it instead.
>
> ```java
> register("kanga");
> register("kanga", "roo");
> register("kanga", "roo", "kanga.and.roo@hundred-acre-wood.co.uk");
> ```
>
> Note how this makes parameter ordering quite important, as parameters can only be omitted from the end of the list. For example, you could not omit just the second `password` parameter when calling from Java. Make sure you're placing your most-defaulted parameters as far back in the parameter list as possible!
>
> We'll take note of similar interop features along the course. There's also a dedicated [documentation page](https://kotlinlang.org/docs/java-to-kotlin-interop.html) covering these.

### Control structures

Let's continue with the basics and get to know our control structures. Most of these will be familiar already, so you'll have no problem getting started with them, but Kotlin does offer some extra capabilities here that are worth knowing about.

#### Conditionals

The classic `if` statement is available in Kotlin just like you'd expect:

```kotlin
if (age < drinkingAge) {
    println("We can't serve you")
} else {
    println("Have a beer")
}
```

It comes with the exciting twist of being not only a statement, but also an *expression*, i.e. it has a return value. This return value is whatever the last expression is in the branch that was executed.

```kotlin
val discount = if (age < adultAge) {
    println("Calculating discount")
    val diff = adultAge - age
    100 - diff * 5
} else {
    println("No discount available")
    0
}
```

If you omit the braces, you get a very concise syntax for these expressions:

```kotlin
val max = if (a > b) a else b
```

For this reason, the so-called ternary operator (`a > b ? a : b`) is not present in the language (see [detailed discussion](https://youtrack.jetbrains.com/issue/KT-5823) and [conclusion with explanation](https://www.youtube.com/watch?v=0FF19HJDqMo&t=1357s)).

#### Switches get ~~stitches~~ improvements

The well-known `switch` statement is an interesting control structure. Many languages (Scala, Swift, or C#, just to mention a few) have taken it beyond its original capabilities by adding *pattern matching* of various kinds to it. Even Java [got some upgrades](https://openjdk.java.net/jeps/361) to its `switch` in Java 14.
  
How does Kotlin measure up? Like in most times when it's compared on a scale from Java to Scala, it's somewhere in the comfortable middle.

Kotlin's replacement for the `switch` is the `when` expression. First of all, it does the things that you expect a regular `switch` to do, with slightly different syntax:

```kotlin
val grade: Int = getGrade()
when (grade) {
    1 -> {
        println("Failed")
    }
    2 -> { println("Adequate") }
    3 -> { println("Average") }
    4 -> { println("Good") }
    5 -> { println("Excellent") }
    else -> {
        /* "This shouldn't happen" */
        throw RuntimeException("Invalid grade!")
    }
}
```

Instead of cases, `when` features branches, which follow whatever value it matched. There is no fall-through between these branches, so there's no need to `break` at their end. Instead of a `default` case, you can use `else` to indicate the branch that should be executed if none of the others have matched.

It also has some more advanced features:

```kotlin
when (val rating = calculateRating()) {
    0 -> {
        println("Terrible")
    }
    1, 2, 3 -> println("Bad")
    in 4..6 -> println("Average")
    in 7 until 10 -> println("Good")
    10 -> println("Perfect")
}
```

In this example, you can see that:

- You can declare the variable that you're performing the check against in the argument of `when` ([since Kotlin 1.3](https://kotlinlang.org/docs/reference/whatsnew13.html#capturing-when-subject-in-a-variable)). This variable will only be accessible within `when`'s body, neatly limiting its scope.
- You can list multiple values that will execute the same branch when one of them matches.
- If your branch is a single expression, you can omit the curly braces.
- You can perform containment-in-`Range` checks.

---

Of course, `when` is an expression too, which means that it can be used to return a value - the last expression of whatever branch was executed. This can reduce code duplication when all branches perform the same action with, for example, a different argument:

```kotlin
val description = when (grade) {
    1 -> "Failed"
    2 -> "Adequate"
    3 -> "Average"
    4 -> "Good"
    5 -> "Excellent"
    else -> {
        // "This shouldn't happen"
        throw RuntimeException("Invalid grade!")
    }
}
println(description)
```

In this case, the `else` block is mandatory, because without it we could run into a scenario where none of the branches were executed, and we have nothing to assign to the variable that the result of `when` is to be stored in.

Exhaustive branches (either all cases covered, or an `else` branch present) are also required in some other cases, such as when the argument to `when` is a `Boolean` value. For example, take the following code:

```kotlin
val enabled = false
when (enabled) {
    true -> println("Enabled!")
}
```

This produces an error:

```
'when' expression must be exhaustive, add necessary 'false' branch or 'else' branch instead
```

The same requirement applies when the argument is an enum value or a sealed class - we'll cover both those features in the [next chapter](2.md).

---

Finally, it's worth noting that `when` can also be used without an argument, as a replacement for a long `if-else if` chain. In this case, each branch has a condition that evaluates to a `Boolean`, and the first one to evaluate to `true` will execute its branch.

```kotlin
when {
    x < 40 -> println("x is too small")
    y in 0..50 -> println("y is in invalid range")
    x % y == 0 -> println("y should divide x")
    !check1(x, y) || !check2(x, y) -> {
        println("x and y didn't pass advanced validation")
    }
}
```

We'll see even more of `when`'s powers later when we get to enums, classes and typechecks.

#### Exceptions

Exceptions in Kotlin are handled using a `try-catch` block (with an optional `finally` clause):

```kotlin
db.open()
db.beginTransaction()
try {
    db.insert(Customer(name = "Ann", balance = 1_000_000))
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
} finally {
    db.close()
}
```

> Note how underscores can be used to break up long number constants and improve readability.

As you might expect at this point, `try-catch` is also an expression, and it returns the last expression in the `try` branch if nothing is thrown from that branch, and the last expression of the `catch` branch otherwise:

```kotlin
val input: String = readUserInput()
val value: Double = try {
    input.toDouble()
} catch(e: NumberFormatException) {
    0.0
}
```

> Note that instead of using [`Double.parseDouble`](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#parseDouble-java.lang.String-) and similar methods, Kotlin offers methods on the `String` type that let you easily convert them to other types, such as [`toDouble`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double.html) or [`toInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html).

One last notable design choice here is that there are *no checked exceptions* in Kotlin. This means that there's no requirement of declaring what exceptions a given function may throw, and you're not forced to handle non-`RuntimeExeptions` by the compiler either.

This choice was made based on the experience that Java's checked exceptions did a lot more to inconvenience developers than to actually improve the safety of code, and often resulted in just empty `try-catch` wrappers around functions that declared exceptions being thrown from them.

> For Java interoperability, you can annotate functions with [`@Throws`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/) to specify what exceptions they can throw, and force Java callers to handle those exceptions.
> 
> ```kotlin
> @Throws(IOException::class)
> fun readScoresFromDisk() { /* Disk reading things */  }
> ```
> 

#### Loops

Last but not least, let's talk about loops. `while` and `do-while` loops have nothing special about them. They check a condition at the beginning or end of the loop respectively, and run until their condition evaluates to `true`.

```kotlin
val entries = ...
while (entries.hasNext()) {
    println("Entry: ${entries.next()}")
}
```

`for` loops, on the other hand, are more interesting. The C-style `for` loop with three parts in its header separated by semicolons is not present in the language. Instead, anything that can provide an `Iterator` can be iterated with `for` loops.

> We'll explore what makes an object compatible with usage in a `for` loop in [later](./8.md#iteration).

For example, here's how you can iterate over a list of numbers, created with the [`listOf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html) factory function:

```kotlin
val myNumbers = listOf(1, 2, 5, 14, 42, 132, 429)
for (number in myNumbers) {
    println(number)
}
```

But what if we just want to iterate on numbers, for example from 0 to 10? It would be very wasteful to create a `List` and fill it up with elements just to get a simple loop. (We'd also be inclined to write the same `for` loop to populate the list with these numbers...)

Here's where the concept of a `Range` comes in. We'll explore these in detail [later](./8.md#custom-ranges), but the basic idea is that the syntax `0..10` creates a `Range` from 0 to 10. This creates a closed range, which includes both its lower and upper bound.

This range can provide an iterator that can be used with a `for` loop:

```kotlin
for (i in 0..10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 10 
```

> It might seem wasteful to create this `Range` object and then an `Iterator` of some kind just to loop through numbers like this. Worry not, this is optimized by the compiler, and we'll inspect what happens under the hood [in a later chapter](./8.md#performance-of-built-in-ranges).

What if we wanted to iterate slightly differently, excluding the upper bound of the range? This is common when we want to iterate valid indexes of a collection, for example. We can create a half-open interval using the `0 until 10` syntax:

```kotlin
for (i in 0 until 10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 
```

Other ways to create ranges include `downTo` which lets you create a descending range, and `step`, which lets you progress in larger increments at a time (this option can be added on to any range):

```kotlin
for (i in 10 downTo 1 step 2) {
    print("$i ")
} // 10 8 6 4 2
```

## Summary

Kotlin is a modern language with a strong, static type system. It aims to achieve readability, safety, and interoperability with all the platforms that it targets. The creators of the language are JetBrains, who also ship all the tooling for the language in IntelliJ IDEA.

Variables are declared with `val` or `var`, functions with `fun`. Types are declared *after* identifiers. Functions come with many conveniences: expression bodies, named and default parameters are a few of the basic ones. Kotlin features most common control structures, and most of them can be used as expressions. `when` is an advanced replacement for a `switch`. `try-catch-finally` works as expected, and there are no checked exceptions. `for` loops work on anything that's iterable, for example on `List` and `Range` objects.

## Sources

- [KotlinConf 2018 - Conference Opening Keynote by Andrey Breslav](https://youtu.be/PsaFVLr8t4E?t=120)
  - Goals of Kotlin, often misunderstood
- [It's a Kotlin, Kotlin, Kotlin World - Jake Wharton - Londroid 2017 @Telegraph Engineering](https://youtu.be/CtZL_IjR5Ww?t=378)
  - Explanation of the interaction between the Java and Kotlin compilers.
- Official documentation
  - [Getting Started with IntelliJ IDEA](https://www.jetbrains.com/help/idea/get-started-with-kotlin.html)
  - [Running Code Snippets](https://kotlinlang.org/docs/run-code-snippets.html)
  - [Using Gradle](https://kotlinlang.org/docs/gradle.html)
  - [Basic Syntax](https://kotlinlang.org/docs/basic-syntax.html)
  - [Basic Types](https://kotlinlang.org/docs/basic-types.html)
  - [Control Flow](https://kotlinlang.org/docs/control-flow.html)
  - [Functions](https://kotlinlang.org/docs/functions.html)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/java-to-kotlin-interop.html)

# Chapter 2: Object-Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object-oriented code. While [Java is clearly and strictly an object-oriented language](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html), the same can not be said for Kotlin. We'll see later on that it supports more than just this one paradigm. For now though, let's see how Kotlin does OOP.

### Classes 101

It only makes sense to start with the simplest possible class:

```kotlin
class Person
```

This is what an empty class looks like in Kotlin. Classes usually have bodies bounded by curly braces `{}`, but these can be omitted if the body of the class is empty - which will happen in Kotlin more than you might think.

Classes have two kinds of constructors - we'll deal with *primary constructors* first. These are declared right in the header of the class, and simply list the parameters you need to construct a class:

```kotlin
class Person(name: String, age: Int)
```

Just adding these parameters doesn't make much sense, we'd at the very least want to store them somewhere, so that we can work with them later. In Java, we'd use fields for this. In Kotlin, we'll use *properties* instead, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable. Similarly to local variables, a `val` is a read-only property, while a `var` is a read-write property.

```kotlin
class Person(name: String, age: Int) {
    val name: String
    var age: Int
}
```

This code won't compile yet, as our properties are not initialized. Therefore, constructing an instance of `Person` wouldn't be safe: what would happen when someone reads the value of `name` or `age`?

There are two ways of initializing this property within the body of the class. It can either be done at its declaration, or inside an *initializer block*, which is executed when the class is constructed:

```kotlin
class Person(name: String, age: Int) {
    val name: String = name
    var age: Int

    init {
        this.age = age
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand syntax for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Person(val name: String, var age: Int)
```

This is used extensively in Kotlin classes.

### Properties

We've seen that properties can be declared either in the primary constructor, or in the body of the class.

Let's take the following example of using the class that we've created:

```kotlin
fun main() {
    val person = Person("Mandy", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - from this syntax, it seems like we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here.

Properties are a higher level concept, which encompass a field, a getter, and a setter (in the case of `var`s) into a single entity. This becomes very apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Mandy", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

The properties that we use in Kotlin are exposed to Java clients as getters and setters, which is the usual way of accessing values stored in a class there. Kotlin tries to blend in to the platform it's targeting and interoperate with it as seamlessly as possible. If you pay attention to some details, client code written in Java will never have to know that it's calling into your Kotlin code.

We can even jump into the Kotlin decompiler and view a decompiled version of the class, which shows us an approximation of what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

While the getters and setters we use here are public, the fields that actually hold the data still remain private. Encapsulation checks out!

> This comparison of one-liner model classes vs the lengthy syntax of Java is often shown off when showcasing the strengths of Kotlin.

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*, the field created behind-the-scenes by the compiler to store a value for the property.

We can change this behaviour by adding a custom getter or setter implementation to the property. To do this, we'll have to move our property from the primary constructor to the body of the class - the primary constructor is only for simple, straightforward properties.

```kotlin
class Person(val name: String, age: Int) {
    var age: Int = age
        get() {
          return field
        }
        set(value) {
          field = value
        }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter. The getter can take no parameter, and the setter takes a single parameter, usually named `value` by convention.

> The compiler marks these implementations as redundant, as we get the same getter/setter by default.

> Be careful not to write down something like `age = value` inside the setter. This would set the value of the *property* instead of the *field*, which would invoke its setter again, resulting in an infinite loop.

We can customize these functions to our liking now. For example, we might want to lie about our age when asked, or make sure that a person never gets any younger than their current age:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
```

> Note the usage of an expression body with the getter, just like with any other function.

Notice how Kotlin's type inference is at work here. The type of the property is not specified anywhere in its now lengthy declaration, instead, it's inferred from the type of the constructor parameter that it's initialized with.

The full syntax of the property with very explicit typing would look like this:

```kotlin
var age: Int = age
    get(): Int = field - 5
    set(value: Int) {
        if (value > field) {
            field = value
        }
    }
```

This contains a lot of unnecessary typing, but specifying the type of at least the property itself on the first line may be a good idea - doing so prevents it from accidentally changing its type if the constructor parameter's type changes.

It's also important to note that even though we're now writing a getter and setter in the implementation of our class, the external usage remains the same as before. We can read and write our property by just referencing its name directly:

```kotlin
val person = Person("Dave", 38)
println(person.age) // 33
person.age = 20
println(person.age) // 33
```

However we implement a property - whether we rely on the default implementation or do it ourselves - they're always encapsulated, and use accessor functions under the hood. This helps us with [maintaining the APIs](https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/) of classes, while allowing them to change their internals in a broad variety of ways.

> Some Java libraries work by reading and writing the values of Java *fields*. These fields often have to be publicly accessible as well. As Kotlin's properties always use private backing fields, these libraries can have trouble operating on Kotlin classes. The solution is using the [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) annotation in these cases, which turns a Kotlin property into a plain Java field.
>
> ```kotlin
> class Person {
>     @JvmField
>     val name: String = "Anonymous"
> }
> ```
>
> Instead of calling a getter for this property, we can now directly access it in Java code:
>
> ```java
> System.out.println(new Person().name);
> ```

##### Property delegation

Custom getters and setters tend to follow the same patterns over and over again. One the most common patterns is *lazy initialization*, computing a value only when it's first needed (saving resources until then), and then storing it for later use (saving resources on subsequent accesses).

Here's an example of a `pi` property which is computed only if it hasn't been accessed yet, and otherwise it returns an already stored when the getter is invoked:

```kotlin
private var _pi: Double? = null
val pi: Double
    get() {
        if (_pi == null) {
            // Some expensive computation
            val sum = (1..50_000).sumOf { 1.0 / it / it }
            _pi = sqrt(sum * 6.0)
        }
        return _pi!!
    }
```

> This property uses another property to store its data instead of its own backing field - a [*backing property*](https://kotlinlang.org/docs/reference/properties.html#backing-properties) - because the types of the property and the data it needs to store are different. This is due to nullability concerns, which will be covered in the next chapter.

> The computation itself also uses some advanced features that we didn't cover yet, but you can attempt to figure out how it works!

If we were to now write code that lazily computes *`e`* ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant))), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, and a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var _e: Double? = null
val e: Double
    get() {
        if (_e == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumOf { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            _e = sum
        }
        return _e!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how this works exactly and how to do it ourselves later down the line, but let's see what delegates the Standard Library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword, and create a lazy property with `lazy {}`:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumOf { 1.0 / it / it }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now gone from our own code, and all we have to focus on is the initialization logic itself! This is placed within the braces `{}` - the last expression in here will be assigned as the value of the property.

It's worth mentioning that `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code whenever the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to ["log"](https://stackoverflow.com/questions/31869391/what-is-the-difference-between-java-logger-and-system-out-println) changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you define for it. Here you have to return a `Boolean` value, which when `false` will prevent the new value from being set. Let's perform the previously used aging validation again, this time using `vetoable`:

```kotlin
var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

> This section has been adapted from a blog post that originally appeared on [zsmb.co](https://zsmb.co/primaries-matter-a-discussion-of-constructors/).

Primary constructors play a fundamental role in Kotlin classes. Let's take a closer look at them, understand what exactly is part of a primary constructor, what makes this constructor special, and what the alternatives are.

##### Back to Java for a moment

In Java, class creation isn't exactly strict. The language lets you leave variables uninitialized without any complaints. Take this class for example:

```java
public class Car {
    String model;
    int year;
    double miles;
}
```

It has three fields, and an implicit constructor with no parameters. When you call its constructor with `new Car()`, all of these fields will be initialized to implicit default values: `null`, `0`, and `0.0`, respectively. In general, primitive types are initialized to some resemblance of `0`, while reference types are initialized to `null`.

##### Kotlin's safety guarantees

In contrast, Kotlin is very strict about creating instances. We've seen that a class like this does not compile in Kotlin, because initializing each property when an instance is created is mandatory.

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double
}
```

> *e: Property must be initialized or be abstract*

*This forces you to explicitly initialize every value in one way or another, and guarantees that your properties won't have implicit values stored in them.* Whenever you read a property, you'll get a value out of it that *you* have put there, intentionally.

##### The primary constructor

We've also seen already that there are two ways to initialize these properties. You can initialize them inline at their declarations, or in one or more initializer (`init`) blocks.

```kotlin
class Car(model: String, year: Int) {
    val model: String = model
    val year: Int
    var miles: Double = 0.0

    init {
        this.year = year
    }
}
```

These two kinds of initializations are performed from top to bottom, in order. In the example, `model` and `miles` would be initialized first, and then finally `year` would get its value. *Any parameters that the primary constructor takes may be used for these initializations*.

Let's simplify by moving both `model` and `year` into the primary constructor. Properties in the primary constructor will be initialized before anything in the body of the class, and again, they'll be initialized in the order that they're declared in.

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0
}
```

Previously initialized variables within the class body will also be in scope during initialization if you want to rely on their values:

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0

    val age: Int

    init {
        age = getCurrentYear() - year
    }

    val description: String = "$model ($age years, $miles miles)"
}
```

We can only initialize `description` this way after `age` has been initialized. If we placed it before the `init` block, we'd again see an error:
  
> *e: Variable 'age' must be initialized*

##### A look under the hood

If we decompile the bytecode produced for this class using the decompiler of the Kotlin IDEA plugin, we'll see this corresponding Java source (comments added):

```java
public final class Car {
    private double miles;
    private final int age;
    private final String description;
    private final String model;
    private final int year;

    // Getters & setters ...

    public Car(String model, int year) {
        // Properties in the primary constructor
        this.model = model;
        this.year = year;

        // Initialization at the declaration
        // (This is actually optimized away if we init to 0)
        this.miles = 0.0D;

        // init block
        this.age = Utils.getCurrentYear() - this.year;

        // Initialization at the declaration
        this.description = this.model + " (" + this.age + " years, " + this.miles + " miles)";
    }
}
```

This shows us how all the different kinds of initializations end up in the body of a single constructor together, in order.

##### Initialization rules, recap

To review, the initialization order:

- Properties in the primary constructor, in declaration order.
- Initializations at property declarations and in initializer blocks, interleaved, in the order that they appear in the class body.

Essentially, you can read the initialization statements in the class top to bottom, and that's what you'll get in the "body" of the primary constructor.

In each of these initializations, you can use the values of:

- Constructor parameters, even if they're not stored in properties.
- Previously initialized *(not just declared!)* properties.

*Due to these restrictions and safety guarantees, classes created via the primary constructor will always be in a valid state.*

![A representation of our single, primary constructor, which is in a valid state.](./images/2_primary.png)

##### Secondary constructors

Of course, there are cases when you want to create class instances with different sets of parameters, which normally requires multiple constructors. Kotlin's [default arguments](./1.md#default-and-named-parameter-values) make this possible to some extent while still keeping just a primary constructor. However, if you need a constructor that has entirely new parameters or parameters with different types, you'll need a *secondary constructor*.

For our example, let's say we need to be able to create cars with a model, year, and mileage, all provided as strings. Our primary constructor can't accommodate these parameters, so it's time to write a new one. This could be our first attempt:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
}
```

This code would fail at constructing a valid `Car` instance, and so it doesn't compile (though it certainly would in Java). For example, it doesn't set the `age` and `description` properties of the instance, which we expect to be initialized by every constructor.

> We also get an error for trying to set `year` and `miles` here: *Val cannot be reassigned*. As a `val` can only be initialized once, that one initialization will always have to happen in the primary constructor (if there is one).

![A secondary constructor that doesn't call the primary constructor is invalid.](./images/2_primary_and_invalid_secondary.png)

The fix, and the rule for secondary constructors is simple: it has to first call the primary constructor, and only after that can it perform further initialization on the instance that was created. *After the primary constructor is called by the secondary constructor, the instance is already in a well-constructed, known valid state*, so it's safe to operate on it in the body of the secondary constructor.

Let's change our secondary constructor to invoke the primary constructor first:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
): this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor that calls the primary constructor directly.](./images/2_primary_and_valid_secondary.png)

The call to the primary constructor doesn't have to be direct, it can also happen indirectly through calling another secondary constructor, but this chain eventually has to end in a call to a primary constructor.

Here's an example of yet another new constructor, which calls the previous secondary constructor:

```kotlin
constructor(data: Array<String>) : this(
        model = data[1],
        year = data[3],
        mileage = data[7],
)
```

![A secondary constructor that calls the primary constructor indirectly.](./images/2_primary_and_valid_secondaries.png)

What we really have here is a graph of the various constructors in our class calling each other.

- A primary constructor is valid if it initializes all properties. 
- A secondary constructor is valid if it eventually calls the primary constructor, i.e. if there's a directed path to the node representing the primary constructor from the node of the secondary constructor.
  - This also means that there can be no cycles within secondary constructor nodes, and no disconnected nodes.

![A graph of constructors.](./images/2_graph.png)

##### Without primaries [Extra content]

Another option when designing classes is to have no primary constructor at all, and use just secondary constructors. See [the extras for this chapter](./2-extras.md#without-primaries) to learn more.

### Data classes

One of the very frequently advertised features of Kotlin is *data classes*. To create a data class, simply add the `data` keyword to a class. Getting back to our favourite `Person` example:

```kotlin
data class Person(val name: String, var age: Int)
```

Adding this keyword adds some new functionality to this class, in the form of automatically generated methods. The first three of these are the `equals`, `hashCode`, and `toString` methods, which you already know from Java.

> In Java, these methods are present on the [`java.lang.Object`] type, which every class implicitly has as a supertype. In Kotlin, the type in the same role is called [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/), and maps exactly to `Object` when you're running Kotlin on the JVM.

The generated `equals` and `hashCode` methods will always consider all properties that are in the primary constructor, and only those. If you need different behaviour, you can still override these implementations yourself. (Though in this case, you might be better off without a data class.)

The generated `toString` method will give you a nicely formatted string that contains the name of the class, as well as the names and values of its primary constructor properties:

```kotlin
val emma = Person("Emma", 19)
println(emma) // Person(name=Emma, age=19)
```

> You might argue that you're not writing these methods anyway, even in Java, but generating them with IDE shortcuts. However, those generated methods are part of the codebase, and have to be maintained. With data classes, these are generated every time the class is compiled, so they're guaranteed to follow any changes to the class, for example, a new property being added.

There are also some methods generated that are only useful for Kotlin users. One of these kinds of methods are the `component1`, `component2`, etc. methods, which can be used with [destructuring declarations](https://kotlinlang.org/docs/destructuring-declarations.html), a feature that allows you to declare and initialize multiple variables at the same time, with an assignment like this:

```kotlin
val (name, age) = emma
println(name) // Emma
```

Note that destructuring works in a positional way, and that these variables can have arbitrary names. For example, swapping the names of these two variables will lead to very unexpected results:

```kotlin
val (age, name) = emma
println(name) // 19
```

Finally, the last generated method for data classes is `copy`, which allows you to... make a copy of your current instance.

```kotlin
val clone = emma.copy()
println(clone) // Person(name=Emma, age=19)
```

Its real power lies in the fact that it actually has as many parameters as the class does in its primary constructor - they just all default to taking the value of the original instance. This means that you can choose to change them one by one, using named parameters, for example:

```kotlin
val olderEmma = emma.copy(age = 26)
println(olderEmma) // Person(name=Emma, age=26)
```

We've provided only the `age` parameter, so the other properties of the class will take their values from the original instance.

The `copy` method comes in especially handy when using it on completely read-only data classes, which only have `val` properties. Since you can't change these, you have to create new instances whenever you need to represent slightly changed data, and this can get very tedious when you have to copy the old values for several properties. The `copy` method does this for you, allowing you to only change what you want to change for the new instance, easily.

> Notice how this is part of Kotlin's general push to prefer immutability. The less mutable state a class holds, the easier it is to reason about how it will behave at any given point in time. Immutability also has huge advantages in multi-threaded environments. You don't have to synchronize accesses to immutable objects, as they never change! So whether it's a local variable or a property, remember to always go with a `val` first.

> The `copy` method performs a shallow copy. Any references to other objects will therefore be the same in the original and the copy created.

Data classes do have some requirements:
- Their primary constructor can't be empty, it needs to contain at least one property.
- All primary constructor parameters need to be properties, either `val` or `var`.
- Inheritance is also restricted: data classes can not be inherited from.

The last point here is especially important, and can be quite restrictive in some cases. Remember that regular Kotlin classes are already very concise and powerful if you just need them to hold a couple values as properties. [Not everything has to be a data class.](https://zsmb.co/data-classes-arent-that-magical/)

> Hint: The generated code for data classes is a very interesting thing to look at with a decompiler!

> Java 16 introduced [records](https://docs.oracle.com/en/java/javase/18/language/records.html), which achieve something similar to data classes, automatically generating lots of boilerplate for simple data holders. [Kotlin has support for records](https://kotlinlang.org/docs/jvm-records.html) as well, allowing you to use Java-declared records, as well as to declare records in Kotlin code.

### Objects

An `object` is a construct similar to a class in Kotlin, with one difference: while you create instances of classes, an object is an instance on its own. What's more, it's the *only* instance of its type! This is essentially a very concise way to declare a [singleton](https://en.wikipedia.org/wiki/Singleton_pattern):

```kotlin
object Logger {
    var isEnabled = true
    
    fun log(message: String) {
        if (isEnabled) {
            println(message)
        }
    }
}
```

An `object` can not have a constructor, and its single instance can be accessed simply by its name:

```kotlin
Logger.log("Hello world") // Hello world
Logger.isEnabled = false
Logger.log("Oh no, where's my log") //
```

Objects may be declared inside classes. In this case, they can access the internals of the class that they're nested in, and they can be used with the following syntax:

```kotlin
class Document {
    object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

fun main() {
    repeat(5) {
        Document()
    }
    println(Document.Counter.count) // 5
}
```

> [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) is a simple way to execute a piece of code a given number of times.

How would you add a counter like this in Java? You would simply use a static variable inside the class. Kotlin doesn't have static members, neither properties nor functions. However, if you mark a nested `object` inside the class as the *companion object* of the class, you'll get the following familiar syntax for accessing anything inside that `object`:

```kotlin
class Document {
    companion object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

println(Document.count)
```

What makes this work is that writing down the name of the class -`Document` in this example - will actually give you the reference to the companion object. You can confirm this easily, with this slightly odd line of code:

```kotlin
val counter: Document.Counter = Document
```

Naturally, classes can only have one companion object. This object is special, as it doesn't have to have an explicit name. If you don't name it, it will be named `Companion` implicitly:

```kotlin
class Document {
    companion object {
        var count: Int = 0
    }

    val id = count++
}

val counter: Document.Companion = Document
println(Document.count) // 5
```

As far as Kotlin syntax is concerned, this is as good as having static variables and functions - you simply place these inside a companion object. However, these things are still members in an inner class of `Document`, which we're then using just a single instance of. They're not *really* static members of the `Document` class.

> This can cause issues with certain Java-based frameworks that work with static fields and methods, and the syntax for Java clients isn't completely smooth either:
>
> ```java
> Document.Companion.getCount();
> ```
> 
> If you need real static declarations for Java compatibility, you can use the [`@JvmStatic`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-static/) annotation on methods or properties inside a companion object:
> 
> ```kotlin
> class Document {
>     companion object {
>         @JvmStatic
>         var count: Int = 0
>     }
> }
> ```
> 
> This will expose them as real static declarations:
> 
> ```java
> Document.getCount();
> ```
> 
> You can also use [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) to turn properties in the companion into static fields. To read more about the various possibilities for static interop, see [the table in this blog post](https://zsmb.co/top-10-kotlin-stack-overflow-questions-2/#5-replacing-static-things). 


### Nested classes

A quick word about nested classes. They work similarly to the ones in Java, with one significant difference: *they don't hold a reference to the outer class by default*. This helps avoid accidentally capturing references to outer classes, which can lead to memory leaks. In Java, this behaviour would be achieved by adding the `static` keyword in front of the nested class.

```kotlin
class Outer {
    var outerValue = 0
    
    class Inner {
        init {
            println(outerValue)
                 // ^ Unresolved reference: outerValue
        }
    }
}
```

If you do want an implicit reference to the outer class stored in the nested class, use the `inner` keyword - this gives you the behaviour that would be the default in Java:

```kotlin
class Outer {
    var outerValue = 0

    inner class Inner {
        init {
            println(outerValue) // 0
        }
    }
}
```

### Inheritance

Let's create a simple game to learn about how Kotlin deals with inheritance. For a start, we'll create an `Entity` base class, which will store the current position of an entity on screen, as two coordinates:

```kotlin
class Entity(var x: Double, var y: Double)
```

We can extend this `Entity` class with a concrete implementation using the following syntax:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y)
```

This `UFO` class has a primary constructor that takes two parameters, and this primary constructor calls into the superclass' constructor, passing on both parameters.

> Note that even if `Entity` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Entity()` syntax.

The code above, somewhat surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be inherited from unless that's explicitly allowed, by making them `open`:

```kotlin
open class Entity(var x: Double, var y: Double)
```

This design choice falls in line with one of the often cited items of the [Effective Java](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/) book - *Item 19: Design and document for inheritance or else prohibit it*. Extending a class that was not designed with inheritance in mind can lead to a wide variety of problems, and *final by default* serves as a safeguard against this.

> Items of this book will be referenced by these materials every now and again, as Kotlin promotes many Java best practices naturally, through its language design. If you haven't read it yet, you should really consider it.

In our specific case, it also doesn't make sense to let clients create `Entity` instances directly, which we can prevent by making this base class `abstract`. This works the same way as Java's abstract classes: it prevents creating instances of this class, while still allowing inheritance from it. Abstract classes, of course, are always `open`.

```kotlin
abstract class Entity(var x: Double, var y: Double)
```

Next up, we'll add a `progress` method to the base class, which will be invoked by our "game engine" to indicate that time has passed.

Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no default implementation provided for it - this will force concrete subclasses to override it.

For our `progress` method, we'll choose an `open` method, which will have an empty body:

```kotlin
abstract class Entity(var x: Double, var y: Double) {
    open fun progress() {
        /* Empty */
    }
}
```

In Java, [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) is an optional annotation. In Kotlin, it's a required keyword. Let's add some random movement to our UFO class in its `progress` method:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y) {
    override fun progress() {
        x += Random.nextDouble(from = -5.0, until = 5.0)
        y += Random.nextDouble(from = -10.0, until = 10.0)
    }
}
```

> [`java.util.Random`](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) is still available to use in Kotlin when you're on the JVM, but the [`kotlin.random.Random`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/) class from the Standard Library provides a simple, platform independent random API, which you should use in most cases. This is what's used in the previous code snippet.

We'll keep track of our entities in a list in a `Game` class:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun tick() {
        for (entity in entities) {
            entity.progress()
        }
    }
}
```

### Interfaces and type checks

Next up, let's draw our game on the screen, and learn about interfaces.

Kotlin's interfaces are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods (much like Java 8 interfaces).

Let's introduce a `Renderable` interface, which will be implemented by entities that can be displayed on the screen:

```kotlin
interface Renderable {
    val isVisible: Boolean
    fun render(canvas: Canvas)
}
```

This interface requires implementations to be able to tell whether they're currently visible, and to `render` themselves onto a `Canvas` when asked to do so.

Our `UFO` class will implement this interface:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y), Renderable {
    companion object {
        const val WIDTH = 40.0
        const val HEIGHT = 40.0
    }

    override var isVisible: Boolean = true

    override fun render(canvas: Canvas) {
        // Drawing logic using JavaFX
        val context = canvas.graphicsContext2D
        context.fill = Color.DIMGRAY
        context.fillOval(x, y, WIDTH, HEIGHT)
        context.fill = Color.DODGERBLUE
        context.fillOval(x + WIDTH / 4, y + HEIGHT / 4, WIDTH / 2, HEIGHT / 2)
    }

    /* ... */
}
```

A couple of things to note here:

- Implementing interfaces uses nearly the same syntax as extending classes, except there are no parentheses indicating a constructor call.
- [Constants](https://kotlinlang.org/docs/properties.html#compile-time-constants) which would be static in Java can't reside directly in classes - in that case, they would just be properties, being present as a value in each instance. However, they may be placed inside an `object`, which can then be nested in the class. This is often - but not necessarily - the companion object. By marking these with the `const` keyword, we get to use them in annotations, and their values will be inlined to any use sites.

The implementation of `isVisible` is especially interesting. The `Renderable` interface declares it as a `val` of `Boolean` type. This lets implementations of the interface choose from a wide variety of implementations, as long as a getter exists for this property.

In the `UFO` class, we've implemented this as a `var`, which will create a field, a getter, and a setter inside the class. We can also implement this property with a custom getter, as a delegate, or as a *computed property*:

```kotlin
override val isVisible: Boolean
    get() {
        return x > y
    }
```

Computed properties are properties where the getter (and setter, if it's a `var`) doesn't reference its backing field. In this case, a backing field won't be generated inside the class for the property at all. The accessors of these properties can rely on other methods or properties that are in scope.

This means that computed properties can even be present in interfaces, as they store no state - they're just getters/setters with default implementations.

Let's update our `Game` class, to add support for rendering `Renderable` entities:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun renderScene(canvas: Canvas) {
        canvas.graphicsContext2D.fill = Color.BLACK
        canvas.graphicsContext2D.fillRect(0.0, 0.0, canvas.width, canvas.height)

        for (entity in entities) {
            if (entity is Renderable && entity.isVisible) {
                entity.render(canvas)
            }
        }
    }
    
    /* ... */
}
```

The `renderScene` method fills the background of the game, and then renders each `Renderable` entity in a loop. Within the loop, we check whether each entity implements this interface with the `is Renderable` syntax (essentially an `instanceof` check).

The surprising part of this code is that there's no casting to a `Renderable` after this check passes. We just use the `isVisible` property and the `render` method of the entity that passed the type check directly.

This is thanks to a feature called [*smart casts*](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts). Whenever the compiler can reason about the type of a variable based on type checks and control flow, it will automatically make the variable available as the known type, performing the cast for us.

This would even work if we checked for non-conformance to the `Renderable` interface, with the `!is` operator:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) {
        continue
    }
    if (entity.isVisible) {
        entity.render(canvas)
    }
}
```

> `continue` is a somewhat rarely used keyword in C-style languages, which terminates the current iteration of a loop, and skips to the next one.

Smart casts replace most manual casting in Kotlin, but casting explicitly is still possible with the `as` keyword. `entity as Renderable` will throw an exception if `entity` is not a `Renderable`, and return it with the `Renderable` type if it is.

This completes the interesting bits of implementation for our UFO game - find the full code of the game [in this project](../projects/chapters/chapter-2-inheritance-demo).

### Class delegation (implementation by delegation) [Extra content]

Classes can also implement interfaces _by delegation_. Instead of implementing the members declared in the interface in the class itself, the class may delegate to another instance that already implements that interface.

This looks something like this:

```kotlin
class RocketShip(delegate: Renderable) : Renderable by delegate
```

Whenever a member of `Renderable` is invoked on the `RocketShip` instance, it will forward that call to the same member of `delegate`.

Learn more about why this is useful in the [extras for this chapter](./2-extras.md#class-delegation-implementation-by-delegation).

### Sealed classes

> Nothing to do with C# sealed classes!

At times, it's handy to be able to restrict inheritance from a class. *Sealed classes* prevent unknown subclasses of a base class by allowing it to be extended only by classes that are in the same package ([before Kotlin 1.5: in the same file](https://kotlinlang.org/docs/whatsnew15.html#package-wide-sealed-class-hierarchies)).

> [Before Kotlin 1.1](https://kotlinlang.org/docs/reference/whatsnew11.html#sealed-and-data-classes), subclasses had to be *nested* in the sealed class. You can still see this pattern of nesting in many usages of sealed classes today.

For example, we may represent the response from a network call with a sealed class:

```kotlin
sealed class Response
class Success(val data: String) : Response()
class Error(val exception: IOException) : Response()
```

Then, instead of the unfriendly APIs that throw exceptions at us when something goes wrong, we can provide an API that will always return a `Response` instance as the result of a network call.

```kotlin
fun getDataFromAPI(): Response {
    return try {
        val data = URL("https://www.kotlinlang.org/").readText()
        Success(data)
    } catch (e: IOException) {
        Error(e)
    }
}
```

> Remember, `try-catch` is an expression!

We know that this `Response` will either be an instance of `Success` or `Error`. This small set of possible values can only change if someone has access to this source file, and can recompile it.

This brings us to a frequently used capability of `when`, its ability to perform type checks:

```kotlin
when (val response = getDataFromAPI()) {
    is Success -> {
        println("Network success")
        println(response.data)
    }
    is Error -> {
        System.err.println("Network error")
        response.exception.printStackTrace()
    }
}
```

> Notice that in each branch, the value of `response` is smart cast to its concrete type, making properties like `data` and `exception` accessible on them!

If we use `when` as an expression (we return a value from it), we can do so with sealed classes without having to provide an `else` branch. The compiler can guarantee that the statement is already exhaustive with just these two branches, since we know all existing implementations of `Response`:

```kotlin
val message = when (getDataFromAPI()) {
    is Success -> "Network success"
    is Error -> "Network error"
}
println(message)
```

> Using sealed classes for error handling is a neat way of avoiding having to deal with exceptions in Kotlin. For more error handling strategies, watch [this KotlinConf 2019 talk by Nat Pryce and Duncan McGregor](https://www.youtube.com/watch?v=pvYAQNT4o0I). Spoiler alert: contains quite a few advanced Kotlin features that we haven't covered yet.

Since Kotlin 1.5, [sealed interfaces are also available](https://kotlinlang.org/docs/whatsnew15.html#sealed-interfaces). The rules for implementing these interfaces are the same as subclassing sealed classes. A prominent use case for sealed interfaces is using them in libraries to ensure that users of the library can never implement a given interface.

> Java 17 also introduced [sealed classes](https://openjdk.org/jeps/409) with slightly different syntax.

### Enums

Enums are classes in Kotlin, and a basic enum declaration looks like this:

```kotlin
enum class Sizes {
    S, M, L
} 
```

It's useful to think of enums as a class with a very specific number of instances. In the example above, `S`, `M`, and `L` are the only three instances of `Sizes` that will ever exist.

> You could also think of enums as sealed classes, with all of their subclasses being `object`s. If that makes sense to you, you're getting a good grasp of OOP in Kotlin! (Please note though that this is not actually the case - enums are their own thing.)

Enums may also have properties and methods, just like any regular class. These can be implemented once for each of them, in the "base class", or be "abstract" and implemented by each value separately:

```kotlin
enum class MenuItem(val price: Double) {
    Hamburger(4.65),
    Fries(3.50),
    Coke(2.50) {
        override fun purchase() {
            super.purchase()
            println("It's a coke!")
        }
    }; // !
    
    open fun purchase() {
        println("Spending $price")
    }
}
```

> The semicolon separating the list of instances from the enum's methods is one of the very very few required semicolons in the Kotlin language.

### Visibility

Kotlin has similar [visibility modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html) to Java on first sight, but they come with a few significant changes. These modifiers can be applied to declarations of various types: classes, objects, properties, and so on.

- `public` declarations are accessible from anywhere. *This is the default visibility in Kotlin*, and it's implicit. The "package" visibility that was the default in Java is not available in Kotlin.
- `private` declarations in classes are only accessible within the same class, while top-level* `private` declarations are only accessible in the same file.
- `protected` declarations are only accessible in the containing class or its subclasses. They are *not* also accessible from code in the same package, like they are in Java.
- `internal` declarations are accessible within the same compilation unit, for example, the same Gradle module. This is a visibility unique to Kotlin, and it's especially useful for keeping library internals private from clients.

**top-level: Declarations that are declared directly in a file, and not nested in classes. Really, these are package level declarations, it's their package that contains them lexically.*

Some non-obvious use cases of visibility modifiers would be applying them to constructors, or auto-generated getters/setters:

```kotlin
class SecretValue internal constructor(initialValue: Int) {
    var state: Int = initialValue
        private set
}
```

This class cannot be instantiated from another module due to the limited visibility of its constructor. Note that in this case, the `constructor` keyword must be added to the primary constructor.
 
 Additionally, while its `state` property is a `var`, its setter will not be visible externally, essentially making it a `val` to the outside world.

## Summary

The elements of object-oriented programming in Kotlin are very similar to mainstream OO languages such as Java, with a few notable exceptions.

Instead of fields, getters, and setters, Kotlin operates on the abstraction level of properties. These properties can have auto-implemented accessors or custom ones. They may also be delegated, or be computed (have no backing field).

The primary constructor is the main way of initializing instances, and it comes with special safety guarantees. Secondary constructors have to rely on the primary constructor to perform the basic initialization of the class in most cases.

Data classes come with auto-generated utility methods in exchange for suffering a few restrictions. `object` declarations are a brief way to create singletons in Kotlin. Nested objects and companion objects can act as the "static" parts of classes. Inner classes are "static" by default, and have to be marked with `inner` to get a reference to the outer class.

Classes are final by default, and have to be marked with `open` (or `abstract`) to be inherited from. Interfaces can contain property and function declarations, as well as default implementations for functions. Casting in Kotlin is mostly done via smart casts which happen automatically after a successful type check. Sealed classes are a way to restrict an inheritance hierarchy, which can guarantee exhaustive checks on what the type of a given instance is.

Visibility modifiers are slightly different than in Java. Declarations are `public` by default, and Kotlin offers an `internal` modifier.

## Sources

- [Execution in the Kingdom of Nouns - Steve Yegge](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)
  - A tale of how functions are treated in Java.
- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Data classes aren't (that) magical](https://zsmb.co/data-classes-arent-that-magical/)
- Official documentation
  - [Classes and Inheritance](https://kotlinlang.org/docs/reference/classes.html)
  - [Interfaces](https://kotlinlang.org/docs/reference/interfaces.html)
  - [Properties and Fields](https://kotlinlang.org/docs/reference/properties.html)
  - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)
  - [Data Classes](https://kotlinlang.org/docs/reference/data-classes.html)
  - [Sealed Classes](https://kotlinlang.org/docs/reference/sealed-classes.html)
  - [Nested and Inner Classes](https://kotlinlang.org/docs/reference/nested-classes.html)
  - [Enum Classes](https://kotlinlang.org/docs/reference/enum-classes.html)
  - [Visibility Modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html)

# Chapter 3: Nullability

Safety, as we've discussed in the [introduction](1.md#chapter-1-introduction), is a defining property of the Kotlin language. So why do we need safety guarantees from languages?

The worst kind of errors are runtime errors: they happen while users are interacting with the application, likely resulting in an unpleasant experience. Compile time errors are better than runtime errors, as developers face these instead. Even better than compile time errors are edit time errors (or design time errors, if you will): not having to build the project, but seeing the error immediately when making it while writing the code. For Kotlin, the latter two categories of errors are essentially the same, as IntelliJ will show you nearly all compilation errors in real time (as it runs the exact same code to analyze Kotlin code as the compiler).

To move as many errors as possible to compile/edit time, Kotlin is...

- A statically typed language, meaning that each variable has a fixed type which is known at compile time, and doesn't change later. This allows verification such as making sure that whatever methods are called on a variable do, in fact, exist.
- A strongly typed language, which means that values are almost never converted to other types implicitly.

> JavaScript is an excellent counter-example for both of these traits.

Another safety feature, which is perhaps the most often touted one in Kotlin, is *null safety*. This is often advertised as *"Kotlin doesn't have NullPointerExceptions!"*. While this statement is categorically false, we'll see that Kotlin really does do a lot to minimize nullability problems.

### The issue on the table

What's the problem with nulls in the first place? For example, that even this trivial Java method isn't "safe":

```java
public static boolean isEmpty(String str) {
    return str.length() == 0;
}
```

For example, if you pass in `null` as its parameter, it will throw an exception. Would you ever expect a method like this to do that?

The core problem is that you have to keep `null` in mind constantly as you write Java code. These are everyday questions with Java:

- Will a given method accept `null` as its parameter? Will it throw a validation exception for the parameter, or will it crash unexpectedly somewhere halfway?
- Will a given method ever return a `null` value? Do you need to check for that before you operate on it? 
- Does this field in this class ever hold `null`, or can you trust that it's always initialized?

Null checks themselves aren't the problem. It's not knowing when they're needed for certain that's the issue. You can't feasibly null check every value you ever call a function on, which means that sooner or later you'll try to do it on a `null` value. And of course, you'll only find this out at runtime, with the infamous `NullPointerException` (NPE).

Null - the absence of value - is something we need to be able to express, and it can actually [be your friend](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5) if the language allows you to [deal with it safely](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903).

### Nullability

Null safety means that each type in the Kotlin language is either nullable or non-nullable. The former allows a `null` value, while the latter forbids it. This is known at compile time, and the compiler enforces null safety as part of type checking.

The types we've seen so far have all been non-nullable: `Int`, `Person`, and `FileInputStream` are examples of this. You can't assign `null` to a variable of any of these types:

```kotlin
val person: Person = null
```

> e: Null can not be a value of a non-null type Person

The nullable counterparts of these types are denoted by a `?` at the end of the typename: `Int?`, `Person?`, and `FileInputStream?` are all nullable. A variable with one of these types is able to hold `null`, in addition to being able to hold a reference to an object of the given type. This code will compile:

```kotlin
var person: Person? = null
person = Person("Ann", 37)
person = null
```

> The `?` syntax implies uncertainty, or even a question: does a variable of type `Person?` hold an actual `Person`? Maybe. It's a person (?). It's a `Person?`.

If you choose a nullable type, the compiler will know that you have a possibly `null` value, and prevent you from accidentally calling something on this reference - whether that's a method invocation, or reading a property:

```kotlin
println(person.name)
```

> e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Person?

The error message tells us that this call is not allowed, and even suggests some ways to fix the issue of trying to work on a nullable value.

Thankfully, Kotlin provides several convenient features to perform a null check. Let's start with the simplest one, an actual, explicit null check using `if`:

```kotlin
if (person != null) {
    println(person.name)
}
```

This code works, because inside the `if` statement, we receive a *smart cast*. The `person` variable's type changes from `Person?` to `Person` within that scope, and we can operate on it as usual.

Note how this gets us from a broader type to a more specific type, just like a smart cast from an `Animal` type to a `Dog` type would in this scenario:

```kotlin
abstract class Animal
class Dog(val name: String) : Animal()

fun dogCheck(animal: Animal) {
    if (animal is Dog) {
        println("${animal.name} is a good boy")
    }
}
```

Null handling in the type system isn't as special as it seems. We'll take a deeper look at how it works in [chapter 9](./9.md#the-parallel-nullable-and-non-nullable-type-hierarchies).

### Safe calls

One of the basic ways to handle a `null` value is the safe call operator `?.`. It simply replaces the regular accessor `.` of a property access or method call:

```kotlin
println(person?.name)
```

If the operand of `?.` is `null`, it will skip the operation on it, and the entire expression (`person?.name` in the example) will just evaluate to `null`.

This operator can be chained if you have nested data models, where any of them might be `null` along the way. If this happens, the entire chain will short circuit and return `null`.

```kotlin
val street: String? = person?.company?.address?.building
```

While the safe call operator lets you make method calls safely, without the possibility of an NPE, it's not perfect:

- It will never get you a non-nullable value. Whatever values you get from a safe call will always be nullable, as the call might have been skipped.
- It can hide certain issues in your code if you use it carelessly. A call such as `service?.sendEmail()` silently skips sending the email if `service` happens to be `null`, and you don't get to handle the error case. The safe call is shorthand for an `if-else` statement with an implicitly empty `else` branch:

    ```kotlin
    if (service != null) {
        service.sendEmail()
    } else {
        /* Do nothing */
    }
    ```

    Only use this operator if your calls are *truly* optional, and you don't mind if they don't happen.

### Elvis operator

The Elvis operator `?:` (tilt your head to the left) is a path from the nullable world to the non-nullable one. Here's how it's used:

```kotlin
val message: String? = getMessage()
val length: Int = message?.length ?: 0
```

If the value on the left side of the operator is not `null`, it will return that value. Otherwise, the Elvis expression returns the right hand side value. That's it!

This operator is often used to provide a default value of sorts if something happens to be `null`, like in the example above. It also comes in handy to throw an exception or return from a method due to a `null` value:

```kotlin
fun processInput() {
    while (true) {
        val input: String = readLine() ?: return
        println("Input was: $input")
    }
}
```

> The [`readLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/read-line.html) function from the Standard Library reads a line from the standard input stream, and returns `null` if the end of the input has been reached.

We'll look at how the evaluation and inference of types works exactly when using the Elvis operator [later on](./9.md#elvis-revisited), when we dive deeper into the Kotlin type system.

> Fun fact: this operator is also referred to as the [null coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator), and is present in many languages.

### `!!` operator

If you really want to shoot yourself in the foot, Kotlin provides you the tool to do so. The *not-null assertion operator* is a favourite of NPE lovers. It's very simple: it either returns whatever you've applied it to with a non-null type, or it throws an exception ~~(a `KotlinNullPointerException`, to be precise)~~ (a regular [`NullPointerException`](https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html), [since Kotlin 1.3.50](https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/)).

```kotlin
println(person!!.name)
```

This code is equivalent to the following:

```kotlin
val person: Person? = null
if (person == null) {
    throw NullPointerException()
}
println(person.name)
```

Note that unlike the safe call operator `?.`, this operator doesn't include the `.` accessor. It can be used just on its own in an expression to force a null check / smart cast, as it will be evaluated, and throw an exception if it fails the check:

```kotlin
person!!
println(person.name) // person is smart cast to `Person` here
```

For the same reason, you'll never be able to construct an instance of a class like this one, as it will always throw an exception while it's being constructed:

```kotlin
class Episode {
    var airdate: Date = null!!
}
```

### Safe casts

We see that handling nullable values is convenient in Kotlin, since the language provides many tools for this purpose. *Safe casts* let us make use of these tools when we need to perform type checks, by transforming a question of type conformance to a question of nullability:

```kotlin
val renderable: Renderable? = entity as? Renderable
```

A safe cast performed with `as?` will either succeed and return the original value as the given type, or fail and return `null` instead. Handling this `null` value is often more convenient than performing a type check, or attempting a regular cast and catching a possible exception.

Take this slightly modified example from our game in the previous chapter, which uses a type check:

```kotlin
for (entity in entities) {
    if (entity is Renderable) {
        entity.render(canvas)
    }
}
```

We can easily rewrite this using a safe cast, and then a safe call:

```kotlin
for (entity in entities) {
    (entity as? Renderable)?.render(canvas)
}
```

Similarly, if you take this loop, with an inverted condition:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) continue
    entity.render(canvas)
}
```

... you can rewrite it using a safe cast and an Elvis operator:

```kotlin
for (entity in entities) {
    val renderable = entity as? Renderable ?: continue
    renderable.render(canvas)
}
```

These may or may not be more legible than the original code for you at this point. As you get used to Kotlin and read more Kotlin code, such patterns will surely become familiar.

### lateinit

The language's strict class initialization rules require every property to be initialized when an instance is constructed. This applies to nullable properties as well, even if you're just initializing them to `null`.

However, there are several frameworks that rely on lifecycle callbacks for initialization rather than the constructor. When working with these, you may end up having to make properties nullable just because you're initializing them later than "constructor-time":

```kotlin
class MyApplication : Application() {
    private var timer: AnimationTimer? = null

    override fun start(primaryStage: Stage) {
        // Setup things
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }
    }
}
```

> Here's a new use of the `object` keyword, an [*object expression*](https://kotlinlang.org/docs/object-declarations.html#object-expressions)! This is the way to create anonymous implementations of interfaces or anonymous subclasses in Kotlin. It's equivalent to using `new AnimationTimer() {}` in Java. Note the parentheses indicating the call to the superclass constructor in the Kotlin syntax, which is the same as with regular subclassing.

The compiler will guarantee null safety by continuously forcing us to perform null checks of one kind or another when we interact with this `timer` property. This is inconvenient, since we know that `timer` will be initialized in time, and never be `null` when we're trying to use it. Both of these calls will work, but they are both unnecessarily verbose, and introduce complexity in the code:

```kotlin
timer?.start()
timer!!.stop()
```

What's even worse is that regular null checks will not work on `timer`, as it's a class-level, mutable property:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer = object : AnimationTimer() { ... }

    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

> e: Smart cast to 'AnimationTimer' is impossible, because 'timer' is a mutable property that could have been changed by this time

The compiler's worry here is that the class might be used in a multithreaded environment, where a thread executing in parallel to the current one may change the value of `timer` between the `if` statement's condition being evaluated and its body executing, which could lead to an NPE.

> We'll see a neat way to perform a null check for such a `var` later on.

The solution for this is the `lateinit` keyword, which signals to the compiler that a property will be initialized late - later than constructor time. (In the case of a `lateinit` local variable, later than declaration time.)

By using it, you, the developer, will bear the responsibility of initializing the property before you start using it. In turn, the compiler will stop worrying about it, and let you use it freely. Using this keyword is the equivalent of turning `null` safety off, but it's appropriate and useful in situations like these.

Adding it to `timer` lets us make it non-nullable (in fact, `lateinit` declarations can not be nullable), and use it freely:

```kotlin
class MyApplication : Application() {
    private lateinit var timer: AnimationTimer

    override fun start(primaryStage: Stage) {
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }

        timer.start()
        timer.stop()
    }
}
```

What happens if you fail to initialize such a property in time? You'll get a nicely formatted `UninitializedPropertyAccessException`, with a message like this:

> lateinit property timer has not been initialized

If you ever forget to set a `lateinit` variable in time, this is still more useful for tracking down the issue than getting a generic NPE.

### Java interop, platform types

Kotlin prides itself on interoperability with the native languages and tools of whatever platform you're running it on. Since Java doesn't have a language level concept of nullability, how can Kotlin's strict null handling be reconciled with going back and forth between the two languages?

##### Kotlin to Java interop

By default, declarations coming from Java have _platform types_. This means that their nullability is just... Unknown. ¯\\\_(ツ)\_/¯

For example, consider this class, which - like most Java code - contains no nullability information.

```java
public class JavaTest {
    String platform;

    public JavaTest(String platform) {
        this.platform = platform;
    }
}
```

This is true about the data it's storing, as well as its constructor parameter. Both of these will have the platform type of `String!` when looking at them from Kotlin. Platform types are *non-denotable*, meaning that while they're a part of the language, they can not be used directly in source code. They will only show up in IDE hints and compiler messages.

Whenever we use this class from Kotlin, we are free to pass in either a nullable or non-nullable value as the constructor parameter:

```kotlin
val test1 = JavaTest(null)
val test2 = JavaTest("string")
```

We're also allowed to either perform null handling when we read the value of `platform`, or not:

```kotlin
val test = JavaTest(null)
println(test.platform.length)
println(test.platform?.length)
```

When we work with platform types, our null safety drops to the level of safety that Java provides - *none*. We either perform null checks when something may be null, or we don't, and then we might crash with an NPE.

This seems like a major blow for Kotlin's null safety - and, well, it is. This is the cost of interoperating with a language that inherently doesn't care about nullability, and you'll have to keep this in mind whenever you call a Java-based API. You can hope for the best and just use values that have platform types directly, you can treat all of them as if they were nullable (though the Kotlin compiler won't enforce this), or you can try to balance the two somehow.

> Fun fact: in early stages of the interop design, _everything_ coming from Java was considered nullable, and had to be checked or handled accordingly. While super safe, this turned out to be unfeasible in practice, and was replaced by platform types.

It's a good idea to make your choices about how you treat something with a platform type explicit, by not letting the compiler infer platform types for variables. Instead of this declaration, which implicitly creates a variable with the type `String!`:

```kotlin
val str = test.platform
```

You should choose one of these explicitly typed declarations, which essentially documents whether you thought this value was nullable or not:

```kotlin
val str1: String = test.platform
val str2: String? = test.platform
```

If you choose the former, and `platform` does happen to be `null`, you'll get an exception immediately here, at the assignment. This is *much* easier to track down if it happens than giving the variable a platform type here, and crashing later in your code, when you try to actually use it.

> The bytecode performing the check is interesting to take a look at!

##### Nullability support from Java

So what's the solution for existing code that's written in Java, and all the existing libraries in the JVM ecosystem? How can they aid Kotlin's null safety?

The ultimate solution is to _"just"_ migrate that code to Kotlin, and while [this has been done](https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin), it's certainly not feasible for all of the code in every project. You can still be a good citizen even if you're maintaining Java APIs though, thanks to the Kotlin compiler's support for [nullability annotations](https://kotlinlang.org/docs/java-interop.html#nullability-annotations).

These have been slowly gaining adoption in Java over the years, and several sets of them exist. There's a JSR implementation, and Lombok, Android, and of course JetBrains have their own too, just to mention a few. Each slightly different, each in different packages. The Kotlin compiler supports all of the ones mentioned and more, see [the compiler's source](https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt) for the up-to-date list.

We'll use the JetBrains flavour of these annotations for the examples here. Using these, you can annotate your types in Java like this:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;
}
```

If you're using an IDE that supports these annotations, you'll see a warning on `notNull` here immediately, as it's not initialized by the implicit, empty constructor, and is therefore `null` when an instance of this class is created. 

> This code will still compile, however. These annotations are not enforced by the Java compiler!

This can be fixed by adding a proper constructor:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;

    public JavaTest(@Nullable String nullable, @NotNull String notNull) {
        this.nullable = nullable;
        this.notNull = notNull;
    }
}
```

These annotations will be picked up when using this class from Kotlin, which means that the constructor will have a `String?` and a `String` parameter. You'll be forced to perform a `null` check when you try using `nullable`, and the compiler will warn you that a `null` check is unnecessary if you add one for `notNull`.

```kotlin
val test = JavaTest(null, "string")

println(test.nullable.length) // e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
println(test.nullable?.length) // ok

println(test.notNull.length) // ok
println(test.notNull?.length) // w: Unnecessary safe call on a non-null receiver of type String
```

These annotations are trusted by the compiler, but unlike Kotlin's nullability, they aren't actually verified at compile time. You can easily write and compile code like this, as it only shows an IDE warning:

```java
@NotNull
String getData() {
    return null;
}
```

This method would be visible with a non-nullable return type in Kotlin, and probably cause crashes on the Kotlin side at some point.

It's your responsibility that you annotate your APIs correctly with these annotations. Providing these annotations makes the lives of both your Java and Kotlin clients easier, and if you are maintaining a Java API, you should definitely make use of them.

> In the Android community, the adoption of these annotations escalated quickly as Kotlin gained more and more popularity.

##### Java to Kotlin interop

What about the other direction, calling Kotlin code from Java? If you are using an IDE that understands nullability annotations in pure Java code, it will likely also pick up Kotlin nullability information, as the compiler injects these annotations into the bytecode produced from Kotlin sources.

Yet again, this won't be enforced when compiling Java code against a Kotlin API, but it will be present for you as extra information when you're writing your Java code, letting you code safer.

### Nullable basic types

Basic types (such as `Int`) are represented as a primitive at the bytecode level whenever possible. For example, the parameter of this function will be a primitive:

```kotlin
fun calculate(x: Int) { ... }
```

Decompiled, we'd be looking at code like this:

```java
void calculate(int x) { ... }
```

However, if we use a nullable type, the boxed variants of basic types will have to be used instead. Since primitives are not reference types, they can't hold `null` as their value.

```kotlin
fun configure(x: Int?) { ... }
```

Decompiled, we'll see the boxed type, which allows us to potentially pass `null` into this function:

```java
void configure(@Nullable Integer x) { ... }
```

### Runtime checks

Until now, we've talked about the compile time checks that are performed to grant null safety. These, however, aren't quite enough on their own. When you're calling into Kotlin from Java, you can easily pass in `null` for a parameter that's declared as non-nullable, and the implementation of the method won't be prepared for this.

As an example, let's take this method that takes a `String` as a parameter, and prints its characters line by line. It also modifies some state at the start and end of the method, which prevents multiple invocations printing two strings at the same time (let's ignore the threading issues with setting a regular `Boolean` flag here).

```kotlin
var printing = false

fun printCharacters(str: String) {
    if (printing) return
    printing = true

    for (c in str) {
        println(c)
    }

    printing = false
}
```

You can easily pass in `null` as the parameter if you call this method from Java:

```java
public static void main(String[] args) {
    Printer().printCharacters(null);
}
```

This would cause an exception when the `for` loop attempts to iterate it. As the `printing` flag has already been set at that point, this would leave your application in a broken state, never being able to print anything again. (Assuming that you've handled the exception, and the method has a chance to be called again.)

To prevent this kind of unexpected failure, caused by the presumed safety that you had when you implemented the Kotlin method, the compiler performs additional null checks at runtime, by injecting code during compilation. These pieces of code, again, can be found by decompiling the bytecode:

```java
public final void printCharacters(@NotNull String str) {
    Intrinsics.checkParameterIsNotNull(str, "str");
    if (!printing) {
        printing = true;
        /* ... For loop ... */
        printing = false;
    }
}
```

Since these checks are performed immediately at the beginning of the function before any of your code is executed, a failing check throwing an exception means that it's as if the incorrect call never even happened. This prevents your application from ending up in an unexpected, invalid state by aborting execution somewhere halfway through your method.

These kinds of null checks, and many other utility methods are contained by the [`Intrinsics`](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Intrinsics.java) class. You'll see static calls to it all over decompiled bytecode: for values of parameters and fields, return values, when using the `!!` operator or `lateinit` variables, and more.

It's also worth noting that these checks will generate nicely formatted, specific exception messages, which is why you'll see identifiers, and sometimes even longer pieces of code being passed into them as strings (such as the name of the parameter in the example above).

## Summary

Nullability is a core part of Kotlin's type system. Types are all nullable or non-nullable. When operating on nullable values, the compiler enforces performing null checks.

Safe calls `?.` skip calls to methods if the reference they were (would have been) invoked on is `null`. The Elvis operator `?:` yields its left-hand value if that's not `null`, and the right-hand value otherwise. The `!!` operator is a quick way to throw an NPE.

`lateinit` takes the responsibility of checking nullability out of the compiler's hand, and is useful when working with frameworks.

Safe casts `as?` allow rewriting type checks to nullability problems.

By default, Java declarations show up with platform types in Kotlin, which are unsafe to use. This can be improved upon by using nullability annotations.

## Sources

- [Null is your friend, not a mistake - Roman Elizarov](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5)
- [Dealing with absence of value - Roman Elizarov](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903)
- Official documentation:
  - [Nullability](https://kotlinlang.org/docs/reference/null-safety.html)
  - [Calling Java from Kotlin](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#null-safety)

# Chapter 4: Functional Programming

In [chapter 2](2.md), we've looked at Kotlin's support for object-oriented programming. The other major paradigm that Kotlin supports is [*functional programming*](https://en.wikipedia.org/wiki/Functional_programming).

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside a class, they are just parts of classes - the larger, *more important* concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. This is how a mathematical function tends to work. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify that state.
  - Pure functions have many advantages, the most important one of these is perhaps *referential transparency*, which means that they always produce the same results for the same inputs. This makes it very easy to reason about them, and also facilitates testing.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code, as you have to keep thinking about the current state of the application as you're performing actions. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - Shared mutable state being accessed from multiple threads in an application is also a frequent source of bugs.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy` method generated for data classes. We'll find more of the same when we get to collection types in the next chapter.
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's [collection handling](./5.md#collection-processing), which we'll learn about later.

So when can a language declare that it's functional? Does it have to meet some, or all of the requirements above? Maybe even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

JetBrains' stance on the matter is that they consider the support for top-level functions the determining factor. This makes Kotlin a functional language, in addition to being object-oriented.

## Code organization

We've seen that Kotlin has top-level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

> Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin allows for top-level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of each file. Just like classes, other top-level declarations can be used in other packages by importing them.

> Unlike with Java, the packages that files reside in don't *have to* match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the source folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str == null || str.length == 0
}
```

Compiling this, we end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null || str.length() == 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix, leaking the implementation detail of these utilities being written in Kotlin:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/) annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

> In the previous code snippet, `@file` is an [annotation use-site target](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets). These are used to specify what exactly you want to apply an annotation to, when it would otherwise be ambiguous. For example, on a property declared in a primary constructor, you might want to annotate the parameter `@param:`, the property `@property:`, the backing field `@field:`, or the getter `@get:` of the property. This is useful sometimes when using Java-based tools with Kotlin code.

> In combination with `@JvmName`, you can also add the [`@JvmMultifileClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-multifile-class/) annotation to files. This lets you use the same `@JvmName` for multiple files, and all top-level declarations from those files will be combined into a single class in the bytecode!

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (types, really) that you don't own!

For example, if you need a quick and easy-to-read way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is specified before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* of the extension function.
- Invoking an extension has the same syntax as calling a real method of the class. If it's in a different package, it does have to be imported, like any other top-level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, these extensions are implemented as simple static functions on the bytecode level (top-level extensions, that is - member extensions are discussed [below](#member-extensions)).

If we decompile the bytecode from the code above, we'll see just that:

```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation. You can't implement anything with an extension that you couldn't implement in a function that takes the receiver as a parameter - you just get much nicer syntax.

> The [`CharSequence.last()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/last.html) function is actually part of the Standard Library.

---

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method defined in the `Cat` class is invoked. This feature - [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch) - is the basis of polymorphism, a core concept of object-oriented programming. It allows choosing the concrete implementation that is invoked at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the decision about which one to call has to be made at compile time (statically). At that time, all we know for certain is that we have an `Animal` instance. Any concrete `Animal` could (in theory) end up in that reference by the time we have to call `identify` at runtime. Therefore, the definitely-fitting overload is chosen out of our two static functions.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing many, many extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen can be done with the following API, which requires you to pass in a [`Context`](https://developer.android.com/reference/android/content/Context) object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context` itself (like an often-used Android [`Activity`](https://developer.android.com/reference/android/app/Activity)):

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide fewer parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension-oriented design

A significant amount of the functions in the Standard Library are defined as extensions. Many of them extend commonly used types, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on Standard Library types (which could be easily added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, allowing it to more easily change later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

It can be argued that the `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself could be just a data holder, which doesn't have any behaviour.

> This member function also prevents anyone from adding their own function named `traverse` as an extension, which might not be desirable. Members always take precedence over extensions in case of signature clashes.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order), or different actions during the traversal (e.g. draw the tree instead of printing its values to the console).

> What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This syntax is also useful if you want to conveniently use multiple classes with the same name, without having to fully qualify one of them everywhere in a file.

This pattern is referred to as [*extension-oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the Standard Library's collection processing functions, sequences, and coroutines.

> The `@JvmName` annotation mentioned earlier can also be used on individual declarations, like functions. For example, we could rename the `traverse` function above just for Java users by adding an annotation to it.
> 
> ```kotlin
> @file:JvmName("Utils")
>
> @JvmName("traverseNode")
> fun Node.traverse() { ... }
> ```
> 
> Usage from Java would now look something like this (while Kotlin usage remains unchanged):
> 
> ```java
> Utils.traverseNode(node);
> ```
> 
> This comes in handy when something makes sense in the context of Kotlin (for example, as the name of an extension function or an [operator](./8.md#operators)), but results in an odd-to-read call site from Java code, where it's the name of a static method. 

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be "computed" properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is available as `this`, as you might expect.

### Member extensions

Extensions may also be declared *inside a class* (or interface, or object) as a member. In these cases, the extensions behave differently from top-level extensions.

First of all, they will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence (in other words, the closer `this` scope):

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These member extensions are *not* static, instead, they are regular member functions under the hood. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

You can make these extensions `open` or `abstract`, and have subtypes implement them:

```kotlin
abstract class Validator {
    protected abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

While this is technically possible, it's often simpler to use regular functions that take the receiver as an explicit parameter.

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local (covered later, [in chapter 6](./6.md#local-functions)) extensions instead, if applicable.

### Context receivers

Context receivers are an [upcoming feature in Kotlin](https://kotlinlang.org/docs/whatsnew1620.html#prototype-of-context-receivers-for-kotlin-jvm), and they're essentially a variant of extension functions. 

They are currently available only as a prototype, and only on the JVM target, therefore we won't cover them here, other than to note their existence.

You can learn more about them in [this official Kotlin video](https://www.youtube.com/watch?v=GISPalIVdQY).

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun createGreeting(person: Person): String {
    return "Hello, ${person.name}"
}
```

This function takes a `Person` parameter, and returns a `String`. The type of this function is `(Person) -> String`. The function type that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val greetingCreator: (Person) -> String = ::createGreeting
```

Or declare the entire function in-line, and assign it to a variable with a function type immediately (this is very, very rarely used):

```kotlin
val greetingCreator: (Person) -> String = fun(person: Person): String {
    return "Hello, ${person.name}"
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `greetingCreator` function could be implemented in a lambda like this:

```kotlin
val greetingCreator = { person: Person -> "Hello, ${person.name}" }
```

This variable still has the same type as before (`(Person) -> String`), but we are now letting the compiler infer it based on the expression on the right-hand side.

To explain the syntax briefly: the braces `{}` create a new function literal. The input parameters of the function are listed at the very start, inside the braces. As usual, types come after names, and multiple parameters are separated by commas. Then, the `->` separates the parameter list from the body of the lambda.

Lambdas may contain multiple expressions, and they implicitly return their last expression, without a `return` keyword:

```kotlin
val greetingCreator = { person: Person ->
    println("Creating greeting for ${person.name}...")
    "Hello, ${person.name}"
}
```

This function, now defined as a lambda, can still be invoked the same way as before, as the type of the variable hasn't changed:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

If we provide the type of the variable that holds a lambda on the left-hand side, we can omit the type of the lambda's parameter, and let type inference work the other way:

```kotlin
val greetingCreator: (Person) -> String = { person -> "Hello, ${person.name}" }
```

For lambdas that have *only a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether (given that its type can be inferred from context). In this case, it will be available via the implicit name `it`:

```kotlin
val greetingCreator: (Person) -> String = { "Hello, ${it.name}" }
```

> It's common to see long, complex lambdas use this implicit `it` name for their parameter. Be wary of doing this - naming the parameter can go a long way towards increasing readability and avoiding mistakes of operating on the wrong object. A good rule of thumb is to use an explicit name when your lambda doesn't fit on a single line.

### Method references and bound references

We've seen references to top-level functions. You can also reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
val rebecca = Person("Rebecca")
speak(grace) // "Hi, I'm Grace!"
speak(rebecca) // "Hi, I'm Rebecca!"
```

References may also be bound to a specific instance, for example:

```kotlin
val claudia = Person("Claudia")
val speak: () -> Unit = claudia::speak
speak() // "Hi, I'm Claudia!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

> To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher-order functions

### Introduction

A *higher-order function* is a function that takes another function as a parameter or returns a function.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher-order functions, one that executes the function (i.e. a given piece of code) passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it at any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and the corresponding argument is a lambda, we can move that lambda outside the parentheses:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct, such as a `for` loop...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin lambdas on the JVM are implemented as anonymous classes, which implement certain interfaces. For example, the `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on. Here's the declaration of these two interfaces, *simplified* (you can always check out their [full source](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt)):

```kotlin
interface Function0<R> {
    fun invoke(): R
}

interface Function1<P1, R> {
    fun invoke(p1: P1): R
}
```

> These numbered function types only go up to `Function22`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with function types that have more than 22 parameters!

These functional interfaces - such as `Function1` - all define just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of interfaces like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand.

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

> `Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return `Unit.INSTANCE`, unlike with `void` methods, where you can simply omit the return statement.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java, however...

```java
repeat(3, (Function0)null.INSTANCE);
```

It turns out the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with for the time being. If we use a better decompiler (such as [jadx](https://github.com/skylot/jadx)), we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE = new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever created and used over the lifetime of our program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see there is this:

```java
repeat(3, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), which means they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(times, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to... But the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this might feel unsolvable at first, and needs some kind of workaround. In Kotlin, the code above compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This reference to the `ObjectRef` instance is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new `String` instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type for performance reasons - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

These aren't types you need to use yourself - the Kotlin compiler will deploy them as necessary when you capture values from outer scopes that you want to mutate. However, it's good to know that this happens, as it might cause memory leaks if you're not careful.

> If you're writing Java code, you can make use of this pattern manually to solve similar problems.

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions "for free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the following `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you'll see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant, as function calls are not too expensive in general. It's up to you to decide in each case whether inlining a certain function is worth it.

> If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be copied to the call site, bloating your compilation output.

Where inlining is definitely useful and often recommended is with higher-order functions, as it can get rid of allocations! Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the inline function. That sounds complex, but let's take a look at it in practice.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` present anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher-order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult-to-use APIs with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

> The [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) function is actually part of the Standard Library, so you shouldn't implement it yourself.

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside this `repeat` function (changed to be non-inline again!) on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function.

Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the lambda containing a `return` from `test` wouldn't make any sense!

> The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return from:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda?

Yes! The solution for this is to inline the `repeat` function. This way, we know that the lambda we pass to it will only be executed in place, within the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties for later use.

> TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context.

For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created will have no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val runnable = object: Runnable {
        override fun run() { 
            body()
        }
    }
    runnable.run()
}

fun test() {
    funky {
        // Return could not work here
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

Instead of this, we can use `crossinline`, which will still inline the lambda's contents (*inside* the `run` method of the `Runnable` being created), but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable runnable = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    runnable.run();
}
```

> TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

In general, you don't need to worry about remembering the exact mechanics of `noinline` and `crossinline`, as they are rarely used. But it's useful to know they exist so that you can look them up as needed. When you get into the special situations that require them while writing your own code, your IDE will most likely suggest adding them automatically.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

### Inline classes

You might find it odd that we're discussing a type of class here instead of in the earlier chapter about object-oriented programming. However, inline classes relate to two topics we've just covered: inline functions and typealiases. 

An inline class is a wrapper around a single value: it must have exactly one property in its primary constructor. At runtime, usages of the inline class will be replaced by just its contained value ([wherever possible](https://typealias.com/guides/inline-classes-and-autoboxing/) - same as usages of primitives). The idea for these classes is very similar to that of inline functions: allowing you to create extra constructs in your source code, but then eliminating runtime overhead by rewriting the code during compilation.

If your inline class wraps a primitive type, you'll even get all the [performance benefits of using a primitive](./1.md#primitives-vs-boxed-types) at runtime.

Let's take the example of a class that represents an RGB color value. To declare an inline class, we have to use both the `value` keyword and the `@JvmInline` annotation.

```kotlin
@JvmInline
value class Color(private val value: Int)
```

> The `@JvmInline` annotation might seem excessive - why not just `inline class` instead? Inline classes are just one small usages of a more general concept, *value classes*, which will get more support in Kotlin in the future. You can read about this in great detail in the [value classes KEEP document](https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md). 

Since this is a class, we can add properties and methods to it - with the limitation that it can't have properties that would require backing fields. Since the usage of this class is replaced at runtime with just a primitive `Int`, there would be nowhere to store such values.

We can still add properties without backing fields, for example, convenient accessors for each component of the color:

```kotlin
@JvmInline
value class Color(private val value: Int) {
    val red: Int
        get() = (value shr 16) and 0xFF
    val green: Int
        get() = (value shr 8) and 0xFF
    val blue: Int
        get() = (value shr 0) and 0xFF
}
```

The class is used the same way as any other: we can create instances via the constructor, and access members:

```kotlin
val myColor = Color(0x005FFF)
println(myColor.red)    // 0   (00)
println(myColor.green)  // 95  (05)
println(myColor.blue)   // 255 (FF)
```

However, if we decompile the bytecode that this usage of our inline class outputs, we'll see something like this (simplified here!):

```java
int myColor = Color.constructor-impl(24575);
System.out.println(Color.getRed-impl(myColor));
System.out.println(Color.getGreen-impl(myColor););
System.out.println(Color.getBlue-impl(myColor));
```

`myColor` is just a simple primitive `int` value, giving us great runtime performance. The methods and properties of the `Color` class are turned into static functions, which receive the `$this` value to operate on as a parameter (this "trick" should be familiar by now!):

```java
public static int getRed_impl(int $this) { return $this >> 16 & 255; }
public static int constructor_impl(int value) { return value; }
```

> This `Color` class could be improved by adding some range checks to its constructor (into an `init` block). Thanks to how inline classes work, that code would actually be invoked at runtime and could perform its task - even though no class instance is actually constructed.

While typealiases for the same type (and the original type itself) are cross-compatible, inline classes *create new types*, which means that this code won't compile:

```kotlin
val color: Color = 0 // e: The integer literal does not conform to the expected type Color 
```

Kotlin supports [unsigned numerical values](https://kotlinlang.org/docs/basic-types.html#unsigned-integers) such as `UInt` and `ULong`. Under the hood, these are implemented as inline classes as well, simply wrapping their signed counterparts! This way these unsigned types can also be represented as primitives when used on the JVM.

### SAM conversion, SAM constructor

Getting back to the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lack truly standard function types, so libraries usually introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner, often instantiated with lambda syntax.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

The compiler will perform the heavy lifting here, creating an object instance under the hood that implements `View.OnclickListener` and contains the code of the lambda inside the `onClick` method.

When the conversion would be ambiguous due to overloads, or you want to be more explicit about creating an instance, the slightly more verbose *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

> One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

### Functional interfaces in Kotlin

You can declare functional interfaces in Kotlin as well. These are marked not by an annotation (as the Java convention), but with a keyword instead: the `fun` keyword!

```kotlin
fun interface OnClickListener {
    fun onClick(view: View)
}
```

A functional interface can only have a single abstract method (but may have other, non-abstract methods as well). When you need to pass in an instance of such an interface somewhere, you can use the full object expression syntax, but you can also make use of SAM conversions or SAM constructors, exactly as seen in the previous section.

> Fun interfaces are a relatively new feature, available [since Kotlin 1.4](https://kotlinlang.org/docs/whatsnew14.html#sam-conversions-for-kotlin-interfaces). Previously, SAM conversions only worked for interfaces declared in Java, as it was specifically an interop feature for convenience. SAM conversion for Kotlin-declared interfaces was not supported, the reasoning being that you could just use function types in Kotlin instead of interfaces. However, there are times when using a dedicated interface type is more practical than using those function types.

## Summary

One of Kotlin's most advertised features is extensions, which allow you add new functionality onto existing types, even ones that you don't own yourself.

Functions are first-class citizens, just like classes or objects. They can be declared as top-level constructs in a file, and imported individually. Function types are a core part of the language, and they allow functions to be stored in variables, or passed around as parameters. Lambda expressions (function literals) are a concise way to define functions, especially if you're immediately passing them in as parameters.

Functions that take functions as parameters or return functions are called higher-order functions. The cost of passing function parameters to them (implemented as instances of classes under the hood) can be mitigated by making them inline. In certain situations, `noinline` and `crossinline` can come in handy.

Finally, Kotlin provides SAM conversion and SAM constructors as a way to interop with functional interfaces that are declared in Java code, and it also supports declaring functional interfaces.

## Sources

- Official documentation:
  - [Extensions](https://kotlinlang.org/docs/reference/extensions.html)
  - [Higher-Order Functions and Lambdas](https://kotlinlang.org/docs/reference/lambdas.html)
  - [Inline functions](https://kotlinlang.org/docs/reference/inline-functions.html)
  - [Type aliases](https://kotlinlang.org/docs/reference/type-aliases.html)
  - [SAM Conversions](https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions)
  - [Functional (SAM) interfaces](https://kotlinlang.org/docs/reference/fun-interfaces.html)
- [jadx - Dex to Java decompiler](https://github.com/skylot/jadx)

# Chapter 1: Introduction

Programming languages. There's a lot of them, and it could be argued that all of them have their uses, their pros and cons.

There are things however that are generally considered positive attributes for languages, and many modern languages are converging in terms of these attributes. During this course, we'll be studying Kotlin, which is a great example of a modern, well-rounded language, but you'll see many similar features and ideas in other languages such as Swift, C#, or Groovy, just to name a few examples.

Why should you start using Kotlin specifically, out of all these languages? Its creators often say that they don't really want to push Kotlin on anyone, they want it to speak for itself. It's a pragmatic language, which they believe solves real problems. Try it, see if it solves problems that you're facing in other languages, and if that's valuable for you. And there really is no substitute for seeing what it's like to use in practice.

The creators also proudly admit that almost none of the features in Kotlin have been invented from scratch. We all stand on the shoulders of giants, there's nothing new under the sun, and [everything is a remix](https://www.youtube.com/watch?v=nJPERZDfyWc). Great creations always take existing pieces of work, and then copy, transform, and combine them into something new. Creating a language is no different from your everyday coding in this regard.

> The original lead language designer for Kotlin, Andrey Breslav gave an [excellent talk](https://www.youtube.com/watch?v=7z_K-hTTeqI) on this in May 2022. Best watched once you're already familiar with Kotlin.

What does make Kotlin unique is how well its features fit together, and what features were omitted on purpose, because they would have broken the language's consistency, or go against its core tenets.

So what are some of these desired attributes that Kotlin aims to achieve?

- **Conciseness**, i.e. less code for expressing the same ideas. Not for the sake of conciseness itself, but to improve **readability** compared to more verbose languages. Not having to write [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code) makes coding faster, and more importantly, not having that boilerplate in your codebase makes navigating and reading your existing code a lot easier.
- **Safety** means that your program misbehaves as little as possible. There's various ways to achieve such safety at the language level. Kotlin does this by having a *strong, static type system*, which reveals most mistakes at compile time (at edit time, really, in almost all cases), rather than letting your code fail at runtime.
- **Interoperability** is another driving principle of Kotlin. It runs on multiple platforms, and on each of them it cooperates with the native environment and libraries as much as possible. We'll look specifically at how it interops with Java when running it on the JVM.
- **Pragmatism** is a way of saying that Kotlin is not an academic language. It's meant for use in real industrial settings, and to solve real, practical problems.
- **Tooling** is something you might overlook at first when evaluating languages, but it's something that can make a good language a true pleasure to use. While there are still proud Vim warriors out there, most developers are used to using rich IDEs for their coding needs, and Kotlin's tooling is as first-party as it gets.

This brings us to Kotlin's origin story.

## History

[JetBrains](https://www.jetbrains.com/), the company behind the IntelliJ platform (and [all the IDEs that are built on it](https://www.jetbrains.com/products/#type=ide-vs), such as IntelliJ IDEA, Android Studio, CLion, PyCharm, and so on) has been developing their products in Java for a decade by 2010. During this time, they've built up immense experience in creating tooling for programming languages, and they also got very familiar with Java's pros and cons.

It was at this time that they started looking for a new language for their own development needs that was better than Java. They've evaluated the existing languages that ran on the Java Virtual Machine (JVM), but they didn't find one at the time that would've satisfied their needs.

>The closest candidate at the time was Scala, but it was notoriously difficult to make tooling for, and it suffered from lengthy compilation times.
 
So they've done what anyone else would've done at this point - created their own.

This, in general, is not a great idea - it's akin to writing your own date library or rolling your own crypto. But with the tooling and language expertise of JetBrains, as well as their strong market position, they've deemed it a viable project, and got started on it.

Some highlights of the language's development:

- 2010: internal development started under the name "JetLang".
- July 2011: [announced to the public](https://blog.jetbrains.com/kotlin/2011/07/hello-world-2/) as Project Kotlin.
- February 2016: [Kotlin 1.0](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), the first stable release.
- March 2017: [version 1.1](https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/), the first major feature update to Kotlin, with initial JavaScript support.
- May 2017: first-class Android support for Kotlin announced at Google I/O.
- November 2017: [version 1.2](https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/), with the first version of multiplatform projects.
- October 2018: [version 1.3](https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/), containing stable coroutines.
- May 2019: Android development going [Kotlin-first](https://developer.android.com/kotlin/first) announced at Google I/O.
- August 2020: [version 1.4](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/), introducing the foundations for a new compiler, and some neat new language features.
- May 2021: [version 1.5](https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/), stabilizing inline classes, adding improvements to sealed types, and stabilizing the new JVM compiler backend.
- November 2021: [version 1.6](https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/), with a preview of the new Kotlin/Native memory model, exhaustive when statements, type inference improvements, and lots of new stable Standard Library APIs.
- June 2022: [version 1.7](https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/), with the new K2 compiler available in alpha, , and yet again many new stabilized language features.  

> Watch [Ten Years of Kotlin: The Story of The Programming Language](https://www.youtube.com/watch?v=uE-1oF9PyiY), a documentary about the language made for its 10-year anniversary.

> Read the blog post from Google [celebrating 5 years of Kotlin on Android](https://android-developers.googleblog.com/2022/08/celebrating-5-years-of-kotlin-on-android.html).

Let's take a moment to review some of the previously mentioned language attributes, with this history now in mind:

- **Interoperability**: JetBrains had hundreds of thousands of lines of Java code in IntelliJ that they could never just throw away. The new code written in Kotlin and the old code written in Java had to be able to communicate efficiently and effortlessly.
- **Pragmatism**: The language was born to serve a specific need, a real industrial project.
- **Tooling**: Language and tooling could be developed side-by-side, in-house, and complement each other perfectly.

Who's using the language? A very rapidly rising number of developers - millions, by now (see [2018 stats](https://youtu.be/PsaFVLr8t4E?t=366), [2020 stats](https://youtu.be/pD58Dw17CLk?t=200)). [(About 6 million as of August 2020.)](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/#compiler-and-ecosystem) 

What are they using the language for? A lot of the focus is on Android development, but Kotlin has a lot of traction outside of mobile too. You can take a look at the [Kotlin Census (2020)](https://www.jetbrains.com/lp/kotlin-census-2020/) or the [State of Developer Ecosystem survey (2021)](https://www.jetbrains.com/lp/devecosystem-2021/kotlin/) ran by JetBrains for some official statistics.

Kotlin is an open-source language. Everything around it - the compiler, the standard library, docs, and so on - are available [on GitHub](https://github.com/jetbrains/kotlin). JetBrains isn't the sole owner and controller of the language, its development is governed by the [Kotlin Foundation](https://kotlinlang.org/foundation/kotlin-foundation.html), co-founded by JetBrains and Google.

Being an open source project, it's rare that surprise product announcements for Kotlin appear, as everything is developed out in the open in the first place. You can take a look at what's planned to be coming up for Kotlin in the next few months (or years) on the [Kotlin roadmap](https://kotlinlang.org/roadmap.html).

## Compilation

Kotlin now positions itself as a modern, multiplatform [application programming language](https://medium.com/@elizarov/application-programming-language-ff7f0063c16). Its original and primary target is the JVM, but Kotlin code can also be compiled to [JavaScript](https://kotlinlang.org/docs/js-overview.html), and even [native](https://kotlinlang.org/docs/native-overview.html) binaries.

In this course, we'll focus on using Kotlin on the JVM. When compiling `.kt` Kotlin sources, the output here is *bytecode* in the form of `.class` files - the same as when compiling Java code.

![Compiling Java or Kotlin to bytecode.](./images/1_kotlin_and_java_basic_compilation.png)

What makes this compilation interesting is the strong interoperability between Kotlin and Java. Code written in one language can call into the other one completely seamlessly. So how can this work out during compilation, if we need to compile Java and Kotlin with their respective compilers? How would the Java compiler know about declarations in Kotlin sources, and vice versa?

Here's how the compilation actually works ([credits to Jake Wharton](https://youtu.be/CtZL_IjR5Ww?t=378)):

![Compiling Java and Kotlin, interop details](./images/1_kotlin_and_java_interop_compilation.png)

The Kotlin compiler, `kotlinc` runs first, and it parses both Java and Kotlin sources. This allows it to compile Kotlin code that references declarations in the Java sources. Next, the Java compiler `javac` is invoked. This again parses the Java sources, plus it receives the output of the Kotlin compiler as already compiled bytecode, which is what allows Java sources to reference Kotlin declarations. Finally, the merged output of these two compilers is bytecode in `.class` files.

## Tooling and environment

Unsurprisingly, JetBrains works very hard to provide the best possible tooling for Kotlin. After all, this is their business angle with the language: building products with it, and selling the tooling for it.

Therefore, [IntelliJ IDEA](https://www.jetbrains.com/idea/) is the definitive IDE for Kotlin development, although other editors support it as well. You can also download the Kotlin compiler and [compile it from the command line](https://kotlinlang.org/docs/command-line.html), if that's your thing.

> [Android Studio](https://developer.android.com/studio) is based on IntelliJ IDEA and offers the same support for Kotlin (although new features from IDEA take a while to trickle down to Studio releases).

Most non-trivial JVM projects use build tools instead of invoking the compiler directly. Kotlin supports both [Maven](https://kotlinlang.org/docs/maven.html) and [Gradle](https://kotlinlang.org/docs/gradle.html), which are the popular build tools in the JVM world. Gradle, which also happens to be the de-facto build system for Android projects, is generally preferred.

> You can even write your Gradle build scripts [in Kotlin](https://docs.gradle.org/current/userguide/kotlin_dsl.html).

IntelliJ has a suite of convenient tools built-in for working with Kotlin. Let's take a quick look at each of these before we get to the code.

### Scratch files

[Scratch files](https://www.jetbrains.com/help/idea/scratches.html) are temporary files that you can use to quickly write and run Kotlin code. They are not associated with any project, and they reside outside your project directory, so they won't be under version control, but only stored locally.

![A simple Kotlin scratch file](./images/1_scratch_file.png)

Despite this, you can reference code in your current project from a scratch file, if you need to. You can create instances of classes, call existing functions, and so on. This makes it really, really easy to perform quick experiments.

To create a scratch file, go to *File -> New -> Scratch File*.

### REPL

Read-Eval-Print Loops, or REPLs, are usually a tool for scripting languages. They allow you to write and execute code line by line, to quickly iterate and try out various things in the language. 

Kotlin comes with this tool as well, which you can either run from the command line, or right inside IntelliJ IDEA (*Tools -> Kotlin -> Kotlin REPL*). Just like with scratch files, you can call into code in your currently open project from the REPL.

![The Kotlin REPL](./images/1_repl.png)

### Decompiler

Sometimes the easiest way to understand what a certain piece of Kotlin code does is to look at what it compiles to. The bytecode that the compiler will output for a given Kotlin source file can be viewed by going to *Tools -> Kotlin -> Show Kotlin Bytecode*.

![The Kotlin bytecode viewer](./images/1_bytecode_viewer.png)

While this can help you figure out what's happening in some cases, most people can't read bytecode very well (nor should they be required to), so there's an even more important feature here. You can decompile this bytecode to Java by choosing the *Decompile* option on the bytecode viewer panel.

![Decompiled Kotlin bytecode](./images/1_decompiled.png)

This gives you a Java source file, which is an attempt at writing Java code that would result in the same compilation result. Keep in mind that this is a best effort step, and not all the bytecode that the Kotlin compiler produces can be represented by Java code in a straightforward way. Most of the time, this decompiled Java code will contain at least a few errors. Still, the decompiler is a very useful tool for gaining a deeper understanding of Kotlin.

### Java-to-Kotlin converter

The Kotlin plugin IntelliJ IDEA also ships with a feature that lets you go the other way around: take existing Java code, and automatically convert it to Kotlin. This comes in really handy when migrating a project to Kotlin. 

![Example of Java-to-Kotlin conversion](./images/1_java_to_kotlin.png)

> You'll find this action under  *Code -> Convert Java File to Kotlin File* when you have a Java file open.

Keep in mind that just like the decompiler, this isn't a perfect tool either. Occasionally the converted Kotlin code won't compile straight away, or it will have some bugs in it. Often it might be messy, Java-like, and require some cleanup to make it more _idiomatic_ Kotlin. But it's usually a good start.

The best use of this feature is perhaps for learning purposes. If you don't know how to express something in Kotlin, but you can write it down in Java, you can always run it through the converter! Again, this might not give you the best possible Kotlin solution, but it'll at least give you one.

> Bonus: pasting Java code into a `.kt` file will also prompt you about converting that code into Kotlin while the paste operation is happening.

## Basic syntax

### Variables

Let's take the first thing you'd want to do in a language, and declare a variable!

>Note: In the beginning, we'll look at the Java equivalents of the Kotlin code in case you need them for reference. Remember, Kotlin *does not* actually compile to Java!

```kotlin
var x: Int = 0              // int x = 0;
```

Let's take note of a couple things:
- You declare variables with the `var` keyword.
- The variable name *precedes* the type.
- Semicolons are... allowed, but optional (in practice, this means that you won't use them).

You should only use `var` when you explicitly want a *mutable* **var**iable.

If that's not the case, use `val` instead, which declares an *immutable* **val**ue.

```kotlin
val y: Int = 1              // final int y = 1;
```

That's better. When declaring variables, `val` should be your default choice.

We can make another improvement to this declaration, by making use of *type inference*.

```kotlin
val z = 2                   // final int z = 2;
```

Kotlin is statically typed and has a very strong, strict type system. This variable is still has a type of `Int` just like before, but you can omit the type from your code, as the compiler can *infer* it itself from context (in this case, from the value being assigned). You'll see a lot of this happening in Kotlin code.

This mechanism means you'll never type out something as verbose as this again:

```java
final FileInputStream fis = new FileInputStream("filename");
```

Instead, you'll have the Kotlin compiler figure out the type for you in almost all cases:

```kotlin
val fis = FileInputStream("filename")
```

> Note: You may also notice here that there's no `new` keyword in Kotlin for constructor calls.

The simple number literal we had before was inferred to be an `Int`, but you can also use special formats to create other basic numerical types:

```kotlin
val myLong = 1L             // final long myLong = 1;
val myFloat = 1f            // final float myFloat = 1;
val myDouble = 1.0          // final double myDouble = 1;
```

#### Primitives vs boxed types

Java - and the JVM itself - makes a distinction between primitive types and boxed types. Primitives (`int`, `double`, `boolean`, and so on) are much more efficient, as they live on the stack, and only take up the space required to represent them.

The corresponding boxed classes (`Integer`, `Double`, `Boolean`, and more) are reference types, so only references to them are stored on the stack, and their actual instances live on the heap. These instances are also larger than the primitive's size, [sometimes significantly](https://dzone.com/articles/whats-wrong-with-java-boxed-numbers).

Using the primitives is sufficient in most cases, but sometimes the boxed variants are still required. This can happen when you *need* an object for some reason, for example when dealing with generics (there's no `List<int>` in Java!). The boxed instances also have various methods you can call on them, which you can't do with a primitive value.

So where does Kotlin's `Int` (and `Boolean`, and `Double`, and other numeric types) fit in this picture? Well, just like `Int` is sort of between `int` and `Integer` by its looks, its semantics lie somewhere in the middle as well. On the Kotlin language level, we don't make a distinction about primitives and boxed types. The compiler will use a primitive whenever it's possible, and use a boxed type automatically when it needs to.

This doesn't exactly mean that we *never* have to think about this problem, because the performance considerations of what happens under the hood are still important in some cases - but we won't use different types to represent these things in our code.

#### Strings

The last basic type that's worth mentioning here is `String`, which behaves much like a `String` in Java. A literal is declared with quotation marks:

```kotlin
val name = "Sarah"           // final String name = "Sarah";
```

Kotlin also supports *string templates*, which is an easy way to place values inside a `String`, without having to use lots of concatenation:

```kotlin
val sum = "$x + $y + $z = ${x + y + z}"     // outputs "0 + 1 + 2 = 3"
```

Single values can be inserted with just a `$` prefix, and expressions can be computed using additional curly braces `${...}`.

### Functions

#### Our first function

Let's move on to functions, something we'll discuss *a lot* in Kotlin. First, we'll convert this very simple function - which just adds two numbers together, and returns the result - to Kotlin.

```java
int add(int x, int y) {
    return x + y;
}
```

Here's a Kotlin equivalent of this code:

```kotlin
fun add(x: Int, y: Int): Int {
    return x + y
}
```

Some important observations about the syntax:

- We use the `fun` keyword to declare a function. (Yay! 🎉)
- The names precede the types in the parameter list, just like we've seen with variables.
- The return type comes after the rest of the function header as well, following the `name: Type` structure yet again.

For functions as simple as this one, that only evaluate a single expression and return its value, Kotlin offers a shorthand syntax called an *expression body*:

```kotlin
fun add(x: Int, y: Int): Int = x + y
```

Type inference can also be used here, since the type of the `x + y` expression, an addition of two `Int` values is known by the compiler to be an  `Int`:

```kotlin
fun add(x: Int, y: Int) = x + y
```

This function still returns `Int`, but we aren't stating this explicitly.

> Use expression bodies with care, only when the function's implementation is truly a simple one-liner. Otherwise, don't be afraid of using a traditional function body.

#### Functions that don't return anything

There's another case where the return type can be omitted, this is when the function doesn't return anything. This is equivalent to a function having a `void` return type in Java.

```kotlin
fun noReturnValue() {
    /* Empty */
}
```

Technically, functions like this still do return *something* in Kotlin. The language doesn't have the super special case that Java has with `void` functions. Functions where you don't return a meaningful value - like the one above - will implicitly have a return type of `Unit`. You can also write this out explicitly, although the IDE will warn you that it's unnecessary.

```kotlin
fun noReturnValue(): Unit {
    /* Empty */
}
```

`Unit` is an empty class that has a single instance. It's a dummy object with no properties or methods. This makes it perfect for representing "no meaningful value". Returning this from methods like the one above yields some... interesting possibilities. For example, you can assign the return value of this function to a variable, just like you could with any other function that returns any regular type.

```kotlin
val result: Unit = noReturnValue()
println(result) // kotlin.Unit
```

Again, there's no hard distinction between functions that do return something, and functions that don't. If there's nothing to return, we're indicating that by returning `Unit` implicitly (both the declaration of the return type and the actual `return` statement at the end of the function may be implicit).

We'll see that this type also plays well with generics. We won't need the weird distinction that Java makes between `void` and `Void`, we'll just use `Unit` for everything. But we're getting ahead of ourselves. Spoilers!

#### Default and named parameter values

Functions come with some neat new features in Kotlin compared to Java functions. One of these is [*default arguments*](https://kotlinlang.org/docs/functions.html#default-arguments).

> *Arguments* are the concrete values passed in for the *parameters* that a function declares. However, the words "argument" and "parameter" are often used interchangeably.

To demonstrate, let's write a function that mimics the registration of a user.

```kotlin
fun register( 
    username: String, 
    password: String = "12345678", 
    email: String = "",
) {
  // Pretend that there's something useful here.
  println("$username $password $email")
}
```

This function takes three parameters, and it defines default argument values for the last two. Note the formatting of each parameter on a separate line, this is conventional in Kotlin for functions with long signatures.

> Since Kotlin 1.4, Kotlin allows [trailing commas](https://kotlinlang.org/docs/reference/whatsnew14.html#trailing-comma) in places like parameter lists. You might have noticed this in the previous snippet. This makes it easier to rearrange lines (even in simple text editors), and also makes version control history neater.

Having these default arguments in place means that we can call this method with three, two, or just one argument. For any parameters that are not provided, the default value will be used instead.

```kotlin
register("piglet", "0h_d34r", "piglet@hundred-acre-wood.co.uk")
register("owl", "tea_party")
register("eeyore")
```

Another feature that works nicely in conjunction with default values is [*named arguments*](https://kotlinlang.org/docs/functions.html#named-arguments). For any function defined in Kotlin, you can optionally specify the names of the arguments when you call the function. Our previous calls could be made like this (note the formatting of the lengthy call, on multiple lines):

```kotlin
register(
    username = "piglet",
    password = "0h_d34r",
    email = "piglet@hundred-acre-wood.co.uk"
)
register(username = "owl", password = "tea_party")
register(username = "eeyore")
```

Naming arguments - especially in cases like this where several of the same type are being passed in - can help us avoid mixing up their order, making the code safer. It also improves readability, as which argument fulfills which parameter is immediately clear at the call site.

Combined with default values, we can also use this to omit arguments that have default values, but are not at the end of the parameter list:

```kotlin
register("tigger", email = "tigger@hundred-acre-wood-co.uk")
```

Here, we're passing in a value for `email`, but opting to use the default value for the `password` parameter.

> By default, Java clients of a Kotlin function with default arguments must provide all arguments, and can't make use of the default arguments. However, you can add the [`@JvmOverloads`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/) annotation to improve interoperability:
>
> ```kotlin
> @JvmOverloads
> fun register( 
>     username: String, 
>     password: String = "12345678", 
>     email: String = "",
> )
> ```
>
> This will generate overloaded methods that are callable by Java clients. For each parameter with a default value (starting from the end of the parameter list), a new method will be generated, which omits that parameter, and uses the default value for it instead.
>
> ```java
> register("kanga");
> register("kanga", "roo");
> register("kanga", "roo", "kanga.and.roo@hundred-acre-wood.co.uk");
> ```
>
> Note how this makes parameter ordering quite important, as parameters can only be omitted from the end of the list. For example, you could not omit just the second `password` parameter when calling from Java. Make sure you're placing your most-defaulted parameters as far back in the parameter list as possible!
>
> We'll take note of similar interop features along the course. There's also a dedicated [documentation page](https://kotlinlang.org/docs/java-to-kotlin-interop.html) covering these.

### Control structures

Let's continue with the basics and get to know our control structures. Most of these will be familiar already, so you'll have no problem getting started with them, but Kotlin does offer some extra capabilities here that are worth knowing about.

#### Conditionals

The classic `if` statement is available in Kotlin just like you'd expect:

```kotlin
if (age < drinkingAge) {
    println("We can't serve you")
} else {
    println("Have a beer")
}
```

It comes with the exciting twist of being not only a statement, but also an *expression*, i.e. it has a return value. This return value is whatever the last expression is in the branch that was executed.

```kotlin
val discount = if (age < adultAge) {
    println("Calculating discount")
    val diff = adultAge - age
    100 - diff * 5
} else {
    println("No discount available")
    0
}
```

If you omit the braces, you get a very concise syntax for these expressions:

```kotlin
val max = if (a > b) a else b
```

For this reason, the so-called ternary operator (`a > b ? a : b`) is not present in the language (see [detailed discussion](https://youtrack.jetbrains.com/issue/KT-5823) and [conclusion with explanation](https://www.youtube.com/watch?v=0FF19HJDqMo&t=1357s)).

#### Switches get ~~stitches~~ improvements

The well-known `switch` statement is an interesting control structure. Many languages (Scala, Swift, or C#, just to mention a few) have taken it beyond its original capabilities by adding *pattern matching* of various kinds to it. Even Java [got some upgrades](https://openjdk.java.net/jeps/361) to its `switch` in Java 14.
  
How does Kotlin measure up? Like in most times when it's compared on a scale from Java to Scala, it's somewhere in the comfortable middle.

Kotlin's replacement for the `switch` is the `when` expression. First of all, it does the things that you expect a regular `switch` to do, with slightly different syntax:

```kotlin
val grade: Int = getGrade()
when (grade) {
    1 -> {
        println("Failed")
    }
    2 -> { println("Adequate") }
    3 -> { println("Average") }
    4 -> { println("Good") }
    5 -> { println("Excellent") }
    else -> {
        /* "This shouldn't happen" */
        throw RuntimeException("Invalid grade!")
    }
}
```

Instead of cases, `when` features branches, which follow whatever value it matched. There is no fall-through between these branches, so there's no need to `break` at their end. Instead of a `default` case, you can use `else` to indicate the branch that should be executed if none of the others have matched.

It also has some more advanced features:

```kotlin
when (val rating = calculateRating()) {
    0 -> {
        println("Terrible")
    }
    1, 2, 3 -> println("Bad")
    in 4..6 -> println("Average")
    in 7 until 10 -> println("Good")
    10 -> println("Perfect")
}
```

In this example, you can see that:

- You can declare the variable that you're performing the check against in the argument of `when` ([since Kotlin 1.3](https://kotlinlang.org/docs/reference/whatsnew13.html#capturing-when-subject-in-a-variable)). This variable will only be accessible within `when`'s body, neatly limiting its scope.
- You can list multiple values that will execute the same branch when one of them matches.
- If your branch is a single expression, you can omit the curly braces.
- You can perform containment-in-`Range` checks.

---

Of course, `when` is an expression too, which means that it can be used to return a value - the last expression of whatever branch was executed. This can reduce code duplication when all branches perform the same action with, for example, a different argument:

```kotlin
val description = when (grade) {
    1 -> "Failed"
    2 -> "Adequate"
    3 -> "Average"
    4 -> "Good"
    5 -> "Excellent"
    else -> {
        // "This shouldn't happen"
        throw RuntimeException("Invalid grade!")
    }
}
println(description)
```

In this case, the `else` block is mandatory, because without it we could run into a scenario where none of the branches were executed, and we have nothing to assign to the variable that the result of `when` is to be stored in.

Exhaustive branches (either all cases covered, or an `else` branch present) are also required in some other cases, such as when the argument to `when` is a `Boolean` value. For example, take the following code:

```kotlin
val enabled = false
when (enabled) {
    true -> println("Enabled!")
}
```

This produces an error:

```
'when' expression must be exhaustive, add necessary 'false' branch or 'else' branch instead
```

The same requirement applies when the argument is an enum value or a sealed class - we'll cover both those features in the [next chapter](2.md).

---

Finally, it's worth noting that `when` can also be used without an argument, as a replacement for a long `if-else if` chain. In this case, each branch has a condition that evaluates to a `Boolean`, and the first one to evaluate to `true` will execute its branch.

```kotlin
when {
    x < 40 -> println("x is too small")
    y in 0..50 -> println("y is in invalid range")
    x % y == 0 -> println("y should divide x")
    !check1(x, y) || !check2(x, y) -> {
        println("x and y didn't pass advanced validation")
    }
}
```

We'll see even more of `when`'s powers later when we get to enums, classes and typechecks.

#### Exceptions

Exceptions in Kotlin are handled using a `try-catch` block (with an optional `finally` clause):

```kotlin
db.open()
db.beginTransaction()
try {
    db.insert(Customer(name = "Ann", balance = 1_000_000))
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
} finally {
    db.close()
}
```

> Note how underscores can be used to break up long number constants and improve readability.

As you might expect at this point, `try-catch` is also an expression, and it returns the last expression in the `try` branch if nothing is thrown from that branch, and the last expression of the `catch` branch otherwise:

```kotlin
val input: String = readUserInput()
val value: Double = try {
    input.toDouble()
} catch(e: NumberFormatException) {
    0.0
}
```

> Note that instead of using [`Double.parseDouble`](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#parseDouble-java.lang.String-) and similar methods, Kotlin offers methods on the `String` type that let you easily convert them to other types, such as [`toDouble`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double.html) or [`toInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html).

One last notable design choice here is that there are *no checked exceptions* in Kotlin. This means that there's no requirement of declaring what exceptions a given function may throw, and you're not forced to handle non-`RuntimeExeptions` by the compiler either.

This choice was made based on the experience that Java's checked exceptions did a lot more to inconvenience developers than to actually improve the safety of code, and often resulted in just empty `try-catch` wrappers around functions that declared exceptions being thrown from them.

> For Java interoperability, you can annotate functions with [`@Throws`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/) to specify what exceptions they can throw, and force Java callers to handle those exceptions.
> 
> ```kotlin
> @Throws(IOException::class)
> fun readScoresFromDisk() { /* Disk reading things */  }
> ```
> 

#### Loops

Last but not least, let's talk about loops. `while` and `do-while` loops have nothing special about them. They check a condition at the beginning or end of the loop respectively, and run until their condition evaluates to `true`.

```kotlin
val entries = ...
while (entries.hasNext()) {
    println("Entry: ${entries.next()}")
}
```

`for` loops, on the other hand, are more interesting. The C-style `for` loop with three parts in its header separated by semicolons is not present in the language. Instead, anything that can provide an `Iterator` can be iterated with `for` loops.

> We'll explore what makes an object compatible with usage in a `for` loop in [later](./8.md#iteration).

For example, here's how you can iterate over a list of numbers, created with the [`listOf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html) factory function:

```kotlin
val myNumbers = listOf(1, 2, 5, 14, 42, 132, 429)
for (number in myNumbers) {
    println(number)
}
```

But what if we just want to iterate on numbers, for example from 0 to 10? It would be very wasteful to create a `List` and fill it up with elements just to get a simple loop. (We'd also be inclined to write the same `for` loop to populate the list with these numbers...)

Here's where the concept of a `Range` comes in. We'll explore these in detail [later](./8.md#custom-ranges), but the basic idea is that the syntax `0..10` creates a `Range` from 0 to 10. This creates a closed range, which includes both its lower and upper bound.

This range can provide an iterator that can be used with a `for` loop:

```kotlin
for (i in 0..10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 10 
```

> It might seem wasteful to create this `Range` object and then an `Iterator` of some kind just to loop through numbers like this. Worry not, this is optimized by the compiler, and we'll inspect what happens under the hood [in a later chapter](./8.md#performance-of-built-in-ranges).

What if we wanted to iterate slightly differently, excluding the upper bound of the range? This is common when we want to iterate valid indexes of a collection, for example. We can create a half-open interval using the `0 until 10` syntax:

```kotlin
for (i in 0 until 10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 
```

Other ways to create ranges include `downTo` which lets you create a descending range, and `step`, which lets you progress in larger increments at a time (this option can be added on to any range):

```kotlin
for (i in 10 downTo 1 step 2) {
    print("$i ")
} // 10 8 6 4 2
```

## Summary

Kotlin is a modern language with a strong, static type system. It aims to achieve readability, safety, and interoperability with all the platforms that it targets. The creators of the language are JetBrains, who also ship all the tooling for the language in IntelliJ IDEA.

Variables are declared with `val` or `var`, functions with `fun`. Types are declared *after* identifiers. Functions come with many conveniences: expression bodies, named and default parameters are a few of the basic ones. Kotlin features most common control structures, and most of them can be used as expressions. `when` is an advanced replacement for a `switch`. `try-catch-finally` works as expected, and there are no checked exceptions. `for` loops work on anything that's iterable, for example on `List` and `Range` objects.

## Sources

- [KotlinConf 2018 - Conference Opening Keynote by Andrey Breslav](https://youtu.be/PsaFVLr8t4E?t=120)
  - Goals of Kotlin, often misunderstood
- [It's a Kotlin, Kotlin, Kotlin World - Jake Wharton - Londroid 2017 @Telegraph Engineering](https://youtu.be/CtZL_IjR5Ww?t=378)
  - Explanation of the interaction between the Java and Kotlin compilers.
- Official documentation
  - [Getting Started with IntelliJ IDEA](https://www.jetbrains.com/help/idea/get-started-with-kotlin.html)
  - [Running Code Snippets](https://kotlinlang.org/docs/run-code-snippets.html)
  - [Using Gradle](https://kotlinlang.org/docs/gradle.html)
  - [Basic Syntax](https://kotlinlang.org/docs/basic-syntax.html)
  - [Basic Types](https://kotlinlang.org/docs/basic-types.html)
  - [Control Flow](https://kotlinlang.org/docs/control-flow.html)
  - [Functions](https://kotlinlang.org/docs/functions.html)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/java-to-kotlin-interop.html)

# Chapter 2: Object-Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object-oriented code. While [Java is clearly and strictly an object-oriented language](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html), the same can not be said for Kotlin. We'll see later on that it supports more than just this one paradigm. For now though, let's see how Kotlin does OOP.

### Classes 101

It only makes sense to start with the simplest possible class:

```kotlin
class Person
```

This is what an empty class looks like in Kotlin. Classes usually have bodies bounded by curly braces `{}`, but these can be omitted if the body of the class is empty - which will happen in Kotlin more than you might think.

Classes have two kinds of constructors - we'll deal with *primary constructors* first. These are declared right in the header of the class, and simply list the parameters you need to construct a class:

```kotlin
class Person(name: String, age: Int)
```

Just adding these parameters doesn't make much sense, we'd at the very least want to store them somewhere, so that we can work with them later. In Java, we'd use fields for this. In Kotlin, we'll use *properties* instead, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable. Similarly to local variables, a `val` is a read-only property, while a `var` is a read-write property.

```kotlin
class Person(name: String, age: Int) {
    val name: String
    var age: Int
}
```

This code won't compile yet, as our properties are not initialized. Therefore, constructing an instance of `Person` wouldn't be safe: what would happen when someone reads the value of `name` or `age`?

There are two ways of initializing this property within the body of the class. It can either be done at its declaration, or inside an *initializer block*, which is executed when the class is constructed:

```kotlin
class Person(name: String, age: Int) {
    val name: String = name
    var age: Int

    init {
        this.age = age
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand syntax for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Person(val name: String, var age: Int)
```

This is used extensively in Kotlin classes.

### Properties

We've seen that properties can be declared either in the primary constructor, or in the body of the class.

Let's take the following example of using the class that we've created:

```kotlin
fun main() {
    val person = Person("Mandy", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - from this syntax, it seems like we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here.

Properties are a higher level concept, which encompass a field, a getter, and a setter (in the case of `var`s) into a single entity. This becomes very apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Mandy", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

The properties that we use in Kotlin are exposed to Java clients as getters and setters, which is the usual way of accessing values stored in a class there. Kotlin tries to blend in to the platform it's targeting and interoperate with it as seamlessly as possible. If you pay attention to some details, client code written in Java will never have to know that it's calling into your Kotlin code.

We can even jump into the Kotlin decompiler and view a decompiled version of the class, which shows us an approximation of what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

While the getters and setters we use here are public, the fields that actually hold the data still remain private. Encapsulation checks out!

> This comparison of one-liner model classes vs the lengthy syntax of Java is often shown off when showcasing the strengths of Kotlin.

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*, the field created behind-the-scenes by the compiler to store a value for the property.

We can change this behaviour by adding a custom getter or setter implementation to the property. To do this, we'll have to move our property from the primary constructor to the body of the class - the primary constructor is only for simple, straightforward properties.

```kotlin
class Person(val name: String, age: Int) {
    var age: Int = age
        get() {
          return field
        }
        set(value) {
          field = value
        }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter. The getter can take no parameter, and the setter takes a single parameter, usually named `value` by convention.

> The compiler marks these implementations as redundant, as we get the same getter/setter by default.

> Be careful not to write down something like `age = value` inside the setter. This would set the value of the *property* instead of the *field*, which would invoke its setter again, resulting in an infinite loop.

We can customize these functions to our liking now. For example, we might want to lie about our age when asked, or make sure that a person never gets any younger than their current age:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
```

> Note the usage of an expression body with the getter, just like with any other function.

Notice how Kotlin's type inference is at work here. The type of the property is not specified anywhere in its now lengthy declaration, instead, it's inferred from the type of the constructor parameter that it's initialized with.

The full syntax of the property with very explicit typing would look like this:

```kotlin
var age: Int = age
    get(): Int = field - 5
    set(value: Int) {
        if (value > field) {
            field = value
        }
    }
```

This contains a lot of unnecessary typing, but specifying the type of at least the property itself on the first line may be a good idea - doing so prevents it from accidentally changing its type if the constructor parameter's type changes.

It's also important to note that even though we're now writing a getter and setter in the implementation of our class, the external usage remains the same as before. We can read and write our property by just referencing its name directly:

```kotlin
val person = Person("Dave", 38)
println(person.age) // 33
person.age = 20
println(person.age) // 33
```

However we implement a property - whether we rely on the default implementation or do it ourselves - they're always encapsulated, and use accessor functions under the hood. This helps us with [maintaining the APIs](https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/) of classes, while allowing them to change their internals in a broad variety of ways.

> Some Java libraries work by reading and writing the values of Java *fields*. These fields often have to be publicly accessible as well. As Kotlin's properties always use private backing fields, these libraries can have trouble operating on Kotlin classes. The solution is using the [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) annotation in these cases, which turns a Kotlin property into a plain Java field.
>
> ```kotlin
> class Person {
>     @JvmField
>     val name: String = "Anonymous"
> }
> ```
>
> Instead of calling a getter for this property, we can now directly access it in Java code:
>
> ```java
> System.out.println(new Person().name);
> ```

##### Property delegation

Custom getters and setters tend to follow the same patterns over and over again. One the most common patterns is *lazy initialization*, computing a value only when it's first needed (saving resources until then), and then storing it for later use (saving resources on subsequent accesses).

Here's an example of a `pi` property which is computed only if it hasn't been accessed yet, and otherwise it returns an already stored when the getter is invoked:

```kotlin
private var _pi: Double? = null
val pi: Double
    get() {
        if (_pi == null) {
            // Some expensive computation
            val sum = (1..50_000).sumOf { 1.0 / it / it }
            _pi = sqrt(sum * 6.0)
        }
        return _pi!!
    }
```

> This property uses another property to store its data instead of its own backing field - a [*backing property*](https://kotlinlang.org/docs/reference/properties.html#backing-properties) - because the types of the property and the data it needs to store are different. This is due to nullability concerns, which will be covered in the next chapter.

> The computation itself also uses some advanced features that we didn't cover yet, but you can attempt to figure out how it works!

If we were to now write code that lazily computes *`e`* ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant))), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, and a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var _e: Double? = null
val e: Double
    get() {
        if (_e == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumOf { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            _e = sum
        }
        return _e!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how this works exactly and how to do it ourselves later down the line, but let's see what delegates the Standard Library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword, and create a lazy property with `lazy {}`:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumOf { 1.0 / it / it }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now gone from our own code, and all we have to focus on is the initialization logic itself! This is placed within the braces `{}` - the last expression in here will be assigned as the value of the property.

It's worth mentioning that `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code whenever the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to ["log"](https://stackoverflow.com/questions/31869391/what-is-the-difference-between-java-logger-and-system-out-println) changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you define for it. Here you have to return a `Boolean` value, which when `false` will prevent the new value from being set. Let's perform the previously used aging validation again, this time using `vetoable`:

```kotlin
var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

> This section has been adapted from a blog post that originally appeared on [zsmb.co](https://zsmb.co/primaries-matter-a-discussion-of-constructors/).

Primary constructors play a fundamental role in Kotlin classes. Let's take a closer look at them, understand what exactly is part of a primary constructor, what makes this constructor special, and what the alternatives are.

##### Back to Java for a moment

In Java, class creation isn't exactly strict. The language lets you leave variables uninitialized without any complaints. Take this class for example:

```java
public class Car {
    String model;
    int year;
    double miles;
}
```

It has three fields, and an implicit constructor with no parameters. When you call its constructor with `new Car()`, all of these fields will be initialized to implicit default values: `null`, `0`, and `0.0`, respectively. In general, primitive types are initialized to some resemblance of `0`, while reference types are initialized to `null`.

##### Kotlin's safety guarantees

In contrast, Kotlin is very strict about creating instances. We've seen that a class like this does not compile in Kotlin, because initializing each property when an instance is created is mandatory.

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double
}
```

> *e: Property must be initialized or be abstract*

*This forces you to explicitly initialize every value in one way or another, and guarantees that your properties won't have implicit values stored in them.* Whenever you read a property, you'll get a value out of it that *you* have put there, intentionally.

##### The primary constructor

We've also seen already that there are two ways to initialize these properties. You can initialize them inline at their declarations, or in one or more initializer (`init`) blocks.

```kotlin
class Car(model: String, year: Int) {
    val model: String = model
    val year: Int
    var miles: Double = 0.0

    init {
        this.year = year
    }
}
```

These two kinds of initializations are performed from top to bottom, in order. In the example, `model` and `miles` would be initialized first, and then finally `year` would get its value. *Any parameters that the primary constructor takes may be used for these initializations*.

Let's simplify by moving both `model` and `year` into the primary constructor. Properties in the primary constructor will be initialized before anything in the body of the class, and again, they'll be initialized in the order that they're declared in.

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0
}
```

Previously initialized variables within the class body will also be in scope during initialization if you want to rely on their values:

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0

    val age: Int

    init {
        age = getCurrentYear() - year
    }

    val description: String = "$model ($age years, $miles miles)"
}
```

We can only initialize `description` this way after `age` has been initialized. If we placed it before the `init` block, we'd again see an error:
  
> *e: Variable 'age' must be initialized*

##### A look under the hood

If we decompile the bytecode produced for this class using the decompiler of the Kotlin IDEA plugin, we'll see this corresponding Java source (comments added):

```java
public final class Car {
    private double miles;
    private final int age;
    private final String description;
    private final String model;
    private final int year;

    // Getters & setters ...

    public Car(String model, int year) {
        // Properties in the primary constructor
        this.model = model;
        this.year = year;

        // Initialization at the declaration
        // (This is actually optimized away if we init to 0)
        this.miles = 0.0D;

        // init block
        this.age = Utils.getCurrentYear() - this.year;

        // Initialization at the declaration
        this.description = this.model + " (" + this.age + " years, " + this.miles + " miles)";
    }
}
```

This shows us how all the different kinds of initializations end up in the body of a single constructor together, in order.

##### Initialization rules, recap

To review, the initialization order:

- Properties in the primary constructor, in declaration order.
- Initializations at property declarations and in initializer blocks, interleaved, in the order that they appear in the class body.

Essentially, you can read the initialization statements in the class top to bottom, and that's what you'll get in the "body" of the primary constructor.

In each of these initializations, you can use the values of:

- Constructor parameters, even if they're not stored in properties.
- Previously initialized *(not just declared!)* properties.

*Due to these restrictions and safety guarantees, classes created via the primary constructor will always be in a valid state.*

![A representation of our single, primary constructor, which is in a valid state.](./images/2_primary.png)

##### Secondary constructors

Of course, there are cases when you want to create class instances with different sets of parameters, which normally requires multiple constructors. Kotlin's [default arguments](./1.md#default-and-named-parameter-values) make this possible to some extent while still keeping just a primary constructor. However, if you need a constructor that has entirely new parameters or parameters with different types, you'll need a *secondary constructor*.

For our example, let's say we need to be able to create cars with a model, year, and mileage, all provided as strings. Our primary constructor can't accommodate these parameters, so it's time to write a new one. This could be our first attempt:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
}
```

This code would fail at constructing a valid `Car` instance, and so it doesn't compile (though it certainly would in Java). For example, it doesn't set the `age` and `description` properties of the instance, which we expect to be initialized by every constructor.

> We also get an error for trying to set `year` and `miles` here: *Val cannot be reassigned*. As a `val` can only be initialized once, that one initialization will always have to happen in the primary constructor (if there is one).

![A secondary constructor that doesn't call the primary constructor is invalid.](./images/2_primary_and_invalid_secondary.png)

The fix, and the rule for secondary constructors is simple: it has to first call the primary constructor, and only after that can it perform further initialization on the instance that was created. *After the primary constructor is called by the secondary constructor, the instance is already in a well-constructed, known valid state*, so it's safe to operate on it in the body of the secondary constructor.

Let's change our secondary constructor to invoke the primary constructor first:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
): this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor that calls the primary constructor directly.](./images/2_primary_and_valid_secondary.png)

The call to the primary constructor doesn't have to be direct, it can also happen indirectly through calling another secondary constructor, but this chain eventually has to end in a call to a primary constructor.

Here's an example of yet another new constructor, which calls the previous secondary constructor:

```kotlin
constructor(data: Array<String>) : this(
        model = data[1],
        year = data[3],
        mileage = data[7],
)
```

![A secondary constructor that calls the primary constructor indirectly.](./images/2_primary_and_valid_secondaries.png)

What we really have here is a graph of the various constructors in our class calling each other.

- A primary constructor is valid if it initializes all properties. 
- A secondary constructor is valid if it eventually calls the primary constructor, i.e. if there's a directed path to the node representing the primary constructor from the node of the secondary constructor.
  - This also means that there can be no cycles within secondary constructor nodes, and no disconnected nodes.

![A graph of constructors.](./images/2_graph.png)

##### Without primaries [Extra content]

Another option when designing classes is to have no primary constructor at all, and use just secondary constructors. See [the extras for this chapter](./2-extras.md#without-primaries) to learn more.

### Data classes

One of the very frequently advertised features of Kotlin is *data classes*. To create a data class, simply add the `data` keyword to a class. Getting back to our favourite `Person` example:

```kotlin
data class Person(val name: String, var age: Int)
```

Adding this keyword adds some new functionality to this class, in the form of automatically generated methods. The first three of these are the `equals`, `hashCode`, and `toString` methods, which you already know from Java.

> In Java, these methods are present on the [`java.lang.Object`] type, which every class implicitly has as a supertype. In Kotlin, the type in the same role is called [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/), and maps exactly to `Object` when you're running Kotlin on the JVM.

The generated `equals` and `hashCode` methods will always consider all properties that are in the primary constructor, and only those. If you need different behaviour, you can still override these implementations yourself. (Though in this case, you might be better off without a data class.)

The generated `toString` method will give you a nicely formatted string that contains the name of the class, as well as the names and values of its primary constructor properties:

```kotlin
val emma = Person("Emma", 19)
println(emma) // Person(name=Emma, age=19)
```

> You might argue that you're not writing these methods anyway, even in Java, but generating them with IDE shortcuts. However, those generated methods are part of the codebase, and have to be maintained. With data classes, these are generated every time the class is compiled, so they're guaranteed to follow any changes to the class, for example, a new property being added.

There are also some methods generated that are only useful for Kotlin users. One of these kinds of methods are the `component1`, `component2`, etc. methods, which can be used with [destructuring declarations](https://kotlinlang.org/docs/destructuring-declarations.html), a feature that allows you to declare and initialize multiple variables at the same time, with an assignment like this:

```kotlin
val (name, age) = emma
println(name) // Emma
```

Note that destructuring works in a positional way, and that these variables can have arbitrary names. For example, swapping the names of these two variables will lead to very unexpected results:

```kotlin
val (age, name) = emma
println(name) // 19
```

Finally, the last generated method for data classes is `copy`, which allows you to... make a copy of your current instance.

```kotlin
val clone = emma.copy()
println(clone) // Person(name=Emma, age=19)
```

Its real power lies in the fact that it actually has as many parameters as the class does in its primary constructor - they just all default to taking the value of the original instance. This means that you can choose to change them one by one, using named parameters, for example:

```kotlin
val olderEmma = emma.copy(age = 26)
println(olderEmma) // Person(name=Emma, age=26)
```

We've provided only the `age` parameter, so the other properties of the class will take their values from the original instance.

The `copy` method comes in especially handy when using it on completely read-only data classes, which only have `val` properties. Since you can't change these, you have to create new instances whenever you need to represent slightly changed data, and this can get very tedious when you have to copy the old values for several properties. The `copy` method does this for you, allowing you to only change what you want to change for the new instance, easily.

> Notice how this is part of Kotlin's general push to prefer immutability. The less mutable state a class holds, the easier it is to reason about how it will behave at any given point in time. Immutability also has huge advantages in multi-threaded environments. You don't have to synchronize accesses to immutable objects, as they never change! So whether it's a local variable or a property, remember to always go with a `val` first.

> The `copy` method performs a shallow copy. Any references to other objects will therefore be the same in the original and the copy created.

Data classes do have some requirements:
- Their primary constructor can't be empty, it needs to contain at least one property.
- All primary constructor parameters need to be properties, either `val` or `var`.
- Inheritance is also restricted: data classes can not be inherited from.

The last point here is especially important, and can be quite restrictive in some cases. Remember that regular Kotlin classes are already very concise and powerful if you just need them to hold a couple values as properties. [Not everything has to be a data class.](https://zsmb.co/data-classes-arent-that-magical/)

> Hint: The generated code for data classes is a very interesting thing to look at with a decompiler!

> Java 16 introduced [records](https://docs.oracle.com/en/java/javase/18/language/records.html), which achieve something similar to data classes, automatically generating lots of boilerplate for simple data holders. [Kotlin has support for records](https://kotlinlang.org/docs/jvm-records.html) as well, allowing you to use Java-declared records, as well as to declare records in Kotlin code.

### Objects

An `object` is a construct similar to a class in Kotlin, with one difference: while you create instances of classes, an object is an instance on its own. What's more, it's the *only* instance of its type! This is essentially a very concise way to declare a [singleton](https://en.wikipedia.org/wiki/Singleton_pattern):

```kotlin
object Logger {
    var isEnabled = true
    
    fun log(message: String) {
        if (isEnabled) {
            println(message)
        }
    }
}
```

An `object` can not have a constructor, and its single instance can be accessed simply by its name:

```kotlin
Logger.log("Hello world") // Hello world
Logger.isEnabled = false
Logger.log("Oh no, where's my log") //
```

Objects may be declared inside classes. In this case, they can access the internals of the class that they're nested in, and they can be used with the following syntax:

```kotlin
class Document {
    object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

fun main() {
    repeat(5) {
        Document()
    }
    println(Document.Counter.count) // 5
}
```

> [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) is a simple way to execute a piece of code a given number of times.

How would you add a counter like this in Java? You would simply use a static variable inside the class. Kotlin doesn't have static members, neither properties nor functions. However, if you mark a nested `object` inside the class as the *companion object* of the class, you'll get the following familiar syntax for accessing anything inside that `object`:

```kotlin
class Document {
    companion object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

println(Document.count)
```

What makes this work is that writing down the name of the class -`Document` in this example - will actually give you the reference to the companion object. You can confirm this easily, with this slightly odd line of code:

```kotlin
val counter: Document.Counter = Document
```

Naturally, classes can only have one companion object. This object is special, as it doesn't have to have an explicit name. If you don't name it, it will be named `Companion` implicitly:

```kotlin
class Document {
    companion object {
        var count: Int = 0
    }

    val id = count++
}

val counter: Document.Companion = Document
println(Document.count) // 5
```

As far as Kotlin syntax is concerned, this is as good as having static variables and functions - you simply place these inside a companion object. However, these things are still members in an inner class of `Document`, which we're then using just a single instance of. They're not *really* static members of the `Document` class.

> This can cause issues with certain Java-based frameworks that work with static fields and methods, and the syntax for Java clients isn't completely smooth either:
>
> ```java
> Document.Companion.getCount();
> ```
> 
> If you need real static declarations for Java compatibility, you can use the [`@JvmStatic`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-static/) annotation on methods or properties inside a companion object:
> 
> ```kotlin
> class Document {
>     companion object {
>         @JvmStatic
>         var count: Int = 0
>     }
> }
> ```
> 
> This will expose them as real static declarations:
> 
> ```java
> Document.getCount();
> ```
> 
> You can also use [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) to turn properties in the companion into static fields. To read more about the various possibilities for static interop, see [the table in this blog post](https://zsmb.co/top-10-kotlin-stack-overflow-questions-2/#5-replacing-static-things). 


### Nested classes

A quick word about nested classes. They work similarly to the ones in Java, with one significant difference: *they don't hold a reference to the outer class by default*. This helps avoid accidentally capturing references to outer classes, which can lead to memory leaks. In Java, this behaviour would be achieved by adding the `static` keyword in front of the nested class.

```kotlin
class Outer {
    var outerValue = 0
    
    class Inner {
        init {
            println(outerValue)
                 // ^ Unresolved reference: outerValue
        }
    }
}
```

If you do want an implicit reference to the outer class stored in the nested class, use the `inner` keyword - this gives you the behaviour that would be the default in Java:

```kotlin
class Outer {
    var outerValue = 0

    inner class Inner {
        init {
            println(outerValue) // 0
        }
    }
}
```

### Inheritance

Let's create a simple game to learn about how Kotlin deals with inheritance. For a start, we'll create an `Entity` base class, which will store the current position of an entity on screen, as two coordinates:

```kotlin
class Entity(var x: Double, var y: Double)
```

We can extend this `Entity` class with a concrete implementation using the following syntax:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y)
```

This `UFO` class has a primary constructor that takes two parameters, and this primary constructor calls into the superclass' constructor, passing on both parameters.

> Note that even if `Entity` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Entity()` syntax.

The code above, somewhat surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be inherited from unless that's explicitly allowed, by making them `open`:

```kotlin
open class Entity(var x: Double, var y: Double)
```

This design choice falls in line with one of the often cited items of the [Effective Java](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/) book - *Item 19: Design and document for inheritance or else prohibit it*. Extending a class that was not designed with inheritance in mind can lead to a wide variety of problems, and *final by default* serves as a safeguard against this.

> Items of this book will be referenced by these materials every now and again, as Kotlin promotes many Java best practices naturally, through its language design. If you haven't read it yet, you should really consider it.

In our specific case, it also doesn't make sense to let clients create `Entity` instances directly, which we can prevent by making this base class `abstract`. This works the same way as Java's abstract classes: it prevents creating instances of this class, while still allowing inheritance from it. Abstract classes, of course, are always `open`.

```kotlin
abstract class Entity(var x: Double, var y: Double)
```

Next up, we'll add a `progress` method to the base class, which will be invoked by our "game engine" to indicate that time has passed.

Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no default implementation provided for it - this will force concrete subclasses to override it.

For our `progress` method, we'll choose an `open` method, which will have an empty body:

```kotlin
abstract class Entity(var x: Double, var y: Double) {
    open fun progress() {
        /* Empty */
    }
}
```

In Java, [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) is an optional annotation. In Kotlin, it's a required keyword. Let's add some random movement to our UFO class in its `progress` method:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y) {
    override fun progress() {
        x += Random.nextDouble(from = -5.0, until = 5.0)
        y += Random.nextDouble(from = -10.0, until = 10.0)
    }
}
```

> [`java.util.Random`](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) is still available to use in Kotlin when you're on the JVM, but the [`kotlin.random.Random`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/) class from the Standard Library provides a simple, platform independent random API, which you should use in most cases. This is what's used in the previous code snippet.

We'll keep track of our entities in a list in a `Game` class:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun tick() {
        for (entity in entities) {
            entity.progress()
        }
    }
}
```

### Interfaces and type checks

Next up, let's draw our game on the screen, and learn about interfaces.

Kotlin's interfaces are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods (much like Java 8 interfaces).

Let's introduce a `Renderable` interface, which will be implemented by entities that can be displayed on the screen:

```kotlin
interface Renderable {
    val isVisible: Boolean
    fun render(canvas: Canvas)
}
```

This interface requires implementations to be able to tell whether they're currently visible, and to `render` themselves onto a `Canvas` when asked to do so.

Our `UFO` class will implement this interface:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y), Renderable {
    companion object {
        const val WIDTH = 40.0
        const val HEIGHT = 40.0
    }

    override var isVisible: Boolean = true

    override fun render(canvas: Canvas) {
        // Drawing logic using JavaFX
        val context = canvas.graphicsContext2D
        context.fill = Color.DIMGRAY
        context.fillOval(x, y, WIDTH, HEIGHT)
        context.fill = Color.DODGERBLUE
        context.fillOval(x + WIDTH / 4, y + HEIGHT / 4, WIDTH / 2, HEIGHT / 2)
    }

    /* ... */
}
```

A couple of things to note here:

- Implementing interfaces uses nearly the same syntax as extending classes, except there are no parentheses indicating a constructor call.
- [Constants](https://kotlinlang.org/docs/properties.html#compile-time-constants) which would be static in Java can't reside directly in classes - in that case, they would just be properties, being present as a value in each instance. However, they may be placed inside an `object`, which can then be nested in the class. This is often - but not necessarily - the companion object. By marking these with the `const` keyword, we get to use them in annotations, and their values will be inlined to any use sites.

The implementation of `isVisible` is especially interesting. The `Renderable` interface declares it as a `val` of `Boolean` type. This lets implementations of the interface choose from a wide variety of implementations, as long as a getter exists for this property.

In the `UFO` class, we've implemented this as a `var`, which will create a field, a getter, and a setter inside the class. We can also implement this property with a custom getter, as a delegate, or as a *computed property*:

```kotlin
override val isVisible: Boolean
    get() {
        return x > y
    }
```

Computed properties are properties where the getter (and setter, if it's a `var`) doesn't reference its backing field. In this case, a backing field won't be generated inside the class for the property at all. The accessors of these properties can rely on other methods or properties that are in scope.

This means that computed properties can even be present in interfaces, as they store no state - they're just getters/setters with default implementations.

Let's update our `Game` class, to add support for rendering `Renderable` entities:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun renderScene(canvas: Canvas) {
        canvas.graphicsContext2D.fill = Color.BLACK
        canvas.graphicsContext2D.fillRect(0.0, 0.0, canvas.width, canvas.height)

        for (entity in entities) {
            if (entity is Renderable && entity.isVisible) {
                entity.render(canvas)
            }
        }
    }
    
    /* ... */
}
```

The `renderScene` method fills the background of the game, and then renders each `Renderable` entity in a loop. Within the loop, we check whether each entity implements this interface with the `is Renderable` syntax (essentially an `instanceof` check).

The surprising part of this code is that there's no casting to a `Renderable` after this check passes. We just use the `isVisible` property and the `render` method of the entity that passed the type check directly.

This is thanks to a feature called [*smart casts*](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts). Whenever the compiler can reason about the type of a variable based on type checks and control flow, it will automatically make the variable available as the known type, performing the cast for us.

This would even work if we checked for non-conformance to the `Renderable` interface, with the `!is` operator:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) {
        continue
    }
    if (entity.isVisible) {
        entity.render(canvas)
    }
}
```

> `continue` is a somewhat rarely used keyword in C-style languages, which terminates the current iteration of a loop, and skips to the next one.

Smart casts replace most manual casting in Kotlin, but casting explicitly is still possible with the `as` keyword. `entity as Renderable` will throw an exception if `entity` is not a `Renderable`, and return it with the `Renderable` type if it is.

This completes the interesting bits of implementation for our UFO game - find the full code of the game [in this project](../projects/chapters/chapter-2-inheritance-demo).

### Class delegation (implementation by delegation) [Extra content]

Classes can also implement interfaces _by delegation_. Instead of implementing the members declared in the interface in the class itself, the class may delegate to another instance that already implements that interface.

This looks something like this:

```kotlin
class RocketShip(delegate: Renderable) : Renderable by delegate
```

Whenever a member of `Renderable` is invoked on the `RocketShip` instance, it will forward that call to the same member of `delegate`.

Learn more about why this is useful in the [extras for this chapter](./2-extras.md#class-delegation-implementation-by-delegation).

### Sealed classes

> Nothing to do with C# sealed classes!

At times, it's handy to be able to restrict inheritance from a class. *Sealed classes* prevent unknown subclasses of a base class by allowing it to be extended only by classes that are in the same package ([before Kotlin 1.5: in the same file](https://kotlinlang.org/docs/whatsnew15.html#package-wide-sealed-class-hierarchies)).

> [Before Kotlin 1.1](https://kotlinlang.org/docs/reference/whatsnew11.html#sealed-and-data-classes), subclasses had to be *nested* in the sealed class. You can still see this pattern of nesting in many usages of sealed classes today.

For example, we may represent the response from a network call with a sealed class:

```kotlin
sealed class Response
class Success(val data: String) : Response()
class Error(val exception: IOException) : Response()
```

Then, instead of the unfriendly APIs that throw exceptions at us when something goes wrong, we can provide an API that will always return a `Response` instance as the result of a network call.

```kotlin
fun getDataFromAPI(): Response {
    return try {
        val data = URL("https://www.kotlinlang.org/").readText()
        Success(data)
    } catch (e: IOException) {
        Error(e)
    }
}
```

> Remember, `try-catch` is an expression!

We know that this `Response` will either be an instance of `Success` or `Error`. This small set of possible values can only change if someone has access to this source file, and can recompile it.

This brings us to a frequently used capability of `when`, its ability to perform type checks:

```kotlin
when (val response = getDataFromAPI()) {
    is Success -> {
        println("Network success")
        println(response.data)
    }
    is Error -> {
        System.err.println("Network error")
        response.exception.printStackTrace()
    }
}
```

> Notice that in each branch, the value of `response` is smart cast to its concrete type, making properties like `data` and `exception` accessible on them!

If we use `when` as an expression (we return a value from it), we can do so with sealed classes without having to provide an `else` branch. The compiler can guarantee that the statement is already exhaustive with just these two branches, since we know all existing implementations of `Response`:

```kotlin
val message = when (getDataFromAPI()) {
    is Success -> "Network success"
    is Error -> "Network error"
}
println(message)
```

> Using sealed classes for error handling is a neat way of avoiding having to deal with exceptions in Kotlin. For more error handling strategies, watch [this KotlinConf 2019 talk by Nat Pryce and Duncan McGregor](https://www.youtube.com/watch?v=pvYAQNT4o0I). Spoiler alert: contains quite a few advanced Kotlin features that we haven't covered yet.

Since Kotlin 1.5, [sealed interfaces are also available](https://kotlinlang.org/docs/whatsnew15.html#sealed-interfaces). The rules for implementing these interfaces are the same as subclassing sealed classes. A prominent use case for sealed interfaces is using them in libraries to ensure that users of the library can never implement a given interface.

> Java 17 also introduced [sealed classes](https://openjdk.org/jeps/409) with slightly different syntax.

### Enums

Enums are classes in Kotlin, and a basic enum declaration looks like this:

```kotlin
enum class Sizes {
    S, M, L
} 
```

It's useful to think of enums as a class with a very specific number of instances. In the example above, `S`, `M`, and `L` are the only three instances of `Sizes` that will ever exist.

> You could also think of enums as sealed classes, with all of their subclasses being `object`s. If that makes sense to you, you're getting a good grasp of OOP in Kotlin! (Please note though that this is not actually the case - enums are their own thing.)

Enums may also have properties and methods, just like any regular class. These can be implemented once for each of them, in the "base class", or be "abstract" and implemented by each value separately:

```kotlin
enum class MenuItem(val price: Double) {
    Hamburger(4.65),
    Fries(3.50),
    Coke(2.50) {
        override fun purchase() {
            super.purchase()
            println("It's a coke!")
        }
    }; // !
    
    open fun purchase() {
        println("Spending $price")
    }
}
```

> The semicolon separating the list of instances from the enum's methods is one of the very very few required semicolons in the Kotlin language.

### Visibility

Kotlin has similar [visibility modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html) to Java on first sight, but they come with a few significant changes. These modifiers can be applied to declarations of various types: classes, objects, properties, and so on.

- `public` declarations are accessible from anywhere. *This is the default visibility in Kotlin*, and it's implicit. The "package" visibility that was the default in Java is not available in Kotlin.
- `private` declarations in classes are only accessible within the same class, while top-level* `private` declarations are only accessible in the same file.
- `protected` declarations are only accessible in the containing class or its subclasses. They are *not* also accessible from code in the same package, like they are in Java.
- `internal` declarations are accessible within the same compilation unit, for example, the same Gradle module. This is a visibility unique to Kotlin, and it's especially useful for keeping library internals private from clients.

**top-level: Declarations that are declared directly in a file, and not nested in classes. Really, these are package level declarations, it's their package that contains them lexically.*

Some non-obvious use cases of visibility modifiers would be applying them to constructors, or auto-generated getters/setters:

```kotlin
class SecretValue internal constructor(initialValue: Int) {
    var state: Int = initialValue
        private set
}
```

This class cannot be instantiated from another module due to the limited visibility of its constructor. Note that in this case, the `constructor` keyword must be added to the primary constructor.
 
 Additionally, while its `state` property is a `var`, its setter will not be visible externally, essentially making it a `val` to the outside world.

## Summary

The elements of object-oriented programming in Kotlin are very similar to mainstream OO languages such as Java, with a few notable exceptions.

Instead of fields, getters, and setters, Kotlin operates on the abstraction level of properties. These properties can have auto-implemented accessors or custom ones. They may also be delegated, or be computed (have no backing field).

The primary constructor is the main way of initializing instances, and it comes with special safety guarantees. Secondary constructors have to rely on the primary constructor to perform the basic initialization of the class in most cases.

Data classes come with auto-generated utility methods in exchange for suffering a few restrictions. `object` declarations are a brief way to create singletons in Kotlin. Nested objects and companion objects can act as the "static" parts of classes. Inner classes are "static" by default, and have to be marked with `inner` to get a reference to the outer class.

Classes are final by default, and have to be marked with `open` (or `abstract`) to be inherited from. Interfaces can contain property and function declarations, as well as default implementations for functions. Casting in Kotlin is mostly done via smart casts which happen automatically after a successful type check. Sealed classes are a way to restrict an inheritance hierarchy, which can guarantee exhaustive checks on what the type of a given instance is.

Visibility modifiers are slightly different than in Java. Declarations are `public` by default, and Kotlin offers an `internal` modifier.

## Sources

- [Execution in the Kingdom of Nouns - Steve Yegge](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)
  - A tale of how functions are treated in Java.
- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Data classes aren't (that) magical](https://zsmb.co/data-classes-arent-that-magical/)
- Official documentation
  - [Classes and Inheritance](https://kotlinlang.org/docs/reference/classes.html)
  - [Interfaces](https://kotlinlang.org/docs/reference/interfaces.html)
  - [Properties and Fields](https://kotlinlang.org/docs/reference/properties.html)
  - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)
  - [Data Classes](https://kotlinlang.org/docs/reference/data-classes.html)
  - [Sealed Classes](https://kotlinlang.org/docs/reference/sealed-classes.html)
  - [Nested and Inner Classes](https://kotlinlang.org/docs/reference/nested-classes.html)
  - [Enum Classes](https://kotlinlang.org/docs/reference/enum-classes.html)
  - [Visibility Modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html)

# Chapter 3: Nullability

Safety, as we've discussed in the [introduction](1.md#chapter-1-introduction), is a defining property of the Kotlin language. So why do we need safety guarantees from languages?

The worst kind of errors are runtime errors: they happen while users are interacting with the application, likely resulting in an unpleasant experience. Compile time errors are better than runtime errors, as developers face these instead. Even better than compile time errors are edit time errors (or design time errors, if you will): not having to build the project, but seeing the error immediately when making it while writing the code. For Kotlin, the latter two categories of errors are essentially the same, as IntelliJ will show you nearly all compilation errors in real time (as it runs the exact same code to analyze Kotlin code as the compiler).

To move as many errors as possible to compile/edit time, Kotlin is...

- A statically typed language, meaning that each variable has a fixed type which is known at compile time, and doesn't change later. This allows verification such as making sure that whatever methods are called on a variable do, in fact, exist.
- A strongly typed language, which means that values are almost never converted to other types implicitly.

> JavaScript is an excellent counter-example for both of these traits.

Another safety feature, which is perhaps the most often touted one in Kotlin, is *null safety*. This is often advertised as *"Kotlin doesn't have NullPointerExceptions!"*. While this statement is categorically false, we'll see that Kotlin really does do a lot to minimize nullability problems.

### The issue on the table

What's the problem with nulls in the first place? For example, that even this trivial Java method isn't "safe":

```java
public static boolean isEmpty(String str) {
    return str.length() == 0;
}
```

For example, if you pass in `null` as its parameter, it will throw an exception. Would you ever expect a method like this to do that?

The core problem is that you have to keep `null` in mind constantly as you write Java code. These are everyday questions with Java:

- Will a given method accept `null` as its parameter? Will it throw a validation exception for the parameter, or will it crash unexpectedly somewhere halfway?
- Will a given method ever return a `null` value? Do you need to check for that before you operate on it? 
- Does this field in this class ever hold `null`, or can you trust that it's always initialized?

Null checks themselves aren't the problem. It's not knowing when they're needed for certain that's the issue. You can't feasibly null check every value you ever call a function on, which means that sooner or later you'll try to do it on a `null` value. And of course, you'll only find this out at runtime, with the infamous `NullPointerException` (NPE).

Null - the absence of value - is something we need to be able to express, and it can actually [be your friend](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5) if the language allows you to [deal with it safely](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903).

### Nullability

Null safety means that each type in the Kotlin language is either nullable or non-nullable. The former allows a `null` value, while the latter forbids it. This is known at compile time, and the compiler enforces null safety as part of type checking.

The types we've seen so far have all been non-nullable: `Int`, `Person`, and `FileInputStream` are examples of this. You can't assign `null` to a variable of any of these types:

```kotlin
val person: Person = null
```

> e: Null can not be a value of a non-null type Person

The nullable counterparts of these types are denoted by a `?` at the end of the typename: `Int?`, `Person?`, and `FileInputStream?` are all nullable. A variable with one of these types is able to hold `null`, in addition to being able to hold a reference to an object of the given type. This code will compile:

```kotlin
var person: Person? = null
person = Person("Ann", 37)
person = null
```

> The `?` syntax implies uncertainty, or even a question: does a variable of type `Person?` hold an actual `Person`? Maybe. It's a person (?). It's a `Person?`.

If you choose a nullable type, the compiler will know that you have a possibly `null` value, and prevent you from accidentally calling something on this reference - whether that's a method invocation, or reading a property:

```kotlin
println(person.name)
```

> e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Person?

The error message tells us that this call is not allowed, and even suggests some ways to fix the issue of trying to work on a nullable value.

Thankfully, Kotlin provides several convenient features to perform a null check. Let's start with the simplest one, an actual, explicit null check using `if`:

```kotlin
if (person != null) {
    println(person.name)
}
```

This code works, because inside the `if` statement, we receive a *smart cast*. The `person` variable's type changes from `Person?` to `Person` within that scope, and we can operate on it as usual.

Note how this gets us from a broader type to a more specific type, just like a smart cast from an `Animal` type to a `Dog` type would in this scenario:

```kotlin
abstract class Animal
class Dog(val name: String) : Animal()

fun dogCheck(animal: Animal) {
    if (animal is Dog) {
        println("${animal.name} is a good boy")
    }
}
```

Null handling in the type system isn't as special as it seems. We'll take a deeper look at how it works in [chapter 9](./9.md#the-parallel-nullable-and-non-nullable-type-hierarchies).

### Safe calls

One of the basic ways to handle a `null` value is the safe call operator `?.`. It simply replaces the regular accessor `.` of a property access or method call:

```kotlin
println(person?.name)
```

If the operand of `?.` is `null`, it will skip the operation on it, and the entire expression (`person?.name` in the example) will just evaluate to `null`.

This operator can be chained if you have nested data models, where any of them might be `null` along the way. If this happens, the entire chain will short circuit and return `null`.

```kotlin
val street: String? = person?.company?.address?.building
```

While the safe call operator lets you make method calls safely, without the possibility of an NPE, it's not perfect:

- It will never get you a non-nullable value. Whatever values you get from a safe call will always be nullable, as the call might have been skipped.
- It can hide certain issues in your code if you use it carelessly. A call such as `service?.sendEmail()` silently skips sending the email if `service` happens to be `null`, and you don't get to handle the error case. The safe call is shorthand for an `if-else` statement with an implicitly empty `else` branch:

    ```kotlin
    if (service != null) {
        service.sendEmail()
    } else {
        /* Do nothing */
    }
    ```

    Only use this operator if your calls are *truly* optional, and you don't mind if they don't happen.

### Elvis operator

The Elvis operator `?:` (tilt your head to the left) is a path from the nullable world to the non-nullable one. Here's how it's used:

```kotlin
val message: String? = getMessage()
val length: Int = message?.length ?: 0
```

If the value on the left side of the operator is not `null`, it will return that value. Otherwise, the Elvis expression returns the right hand side value. That's it!

This operator is often used to provide a default value of sorts if something happens to be `null`, like in the example above. It also comes in handy to throw an exception or return from a method due to a `null` value:

```kotlin
fun processInput() {
    while (true) {
        val input: String = readLine() ?: return
        println("Input was: $input")
    }
}
```

> The [`readLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/read-line.html) function from the Standard Library reads a line from the standard input stream, and returns `null` if the end of the input has been reached.

We'll look at how the evaluation and inference of types works exactly when using the Elvis operator [later on](./9.md#elvis-revisited), when we dive deeper into the Kotlin type system.

> Fun fact: this operator is also referred to as the [null coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator), and is present in many languages.

### `!!` operator

If you really want to shoot yourself in the foot, Kotlin provides you the tool to do so. The *not-null assertion operator* is a favourite of NPE lovers. It's very simple: it either returns whatever you've applied it to with a non-null type, or it throws an exception ~~(a `KotlinNullPointerException`, to be precise)~~ (a regular [`NullPointerException`](https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html), [since Kotlin 1.3.50](https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/)).

```kotlin
println(person!!.name)
```

This code is equivalent to the following:

```kotlin
val person: Person? = null
if (person == null) {
    throw NullPointerException()
}
println(person.name)
```

Note that unlike the safe call operator `?.`, this operator doesn't include the `.` accessor. It can be used just on its own in an expression to force a null check / smart cast, as it will be evaluated, and throw an exception if it fails the check:

```kotlin
person!!
println(person.name) // person is smart cast to `Person` here
```

For the same reason, you'll never be able to construct an instance of a class like this one, as it will always throw an exception while it's being constructed:

```kotlin
class Episode {
    var airdate: Date = null!!
}
```

### Safe casts

We see that handling nullable values is convenient in Kotlin, since the language provides many tools for this purpose. *Safe casts* let us make use of these tools when we need to perform type checks, by transforming a question of type conformance to a question of nullability:

```kotlin
val renderable: Renderable? = entity as? Renderable
```

A safe cast performed with `as?` will either succeed and return the original value as the given type, or fail and return `null` instead. Handling this `null` value is often more convenient than performing a type check, or attempting a regular cast and catching a possible exception.

Take this slightly modified example from our game in the previous chapter, which uses a type check:

```kotlin
for (entity in entities) {
    if (entity is Renderable) {
        entity.render(canvas)
    }
}
```

We can easily rewrite this using a safe cast, and then a safe call:

```kotlin
for (entity in entities) {
    (entity as? Renderable)?.render(canvas)
}
```

Similarly, if you take this loop, with an inverted condition:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) continue
    entity.render(canvas)
}
```

... you can rewrite it using a safe cast and an Elvis operator:

```kotlin
for (entity in entities) {
    val renderable = entity as? Renderable ?: continue
    renderable.render(canvas)
}
```

These may or may not be more legible than the original code for you at this point. As you get used to Kotlin and read more Kotlin code, such patterns will surely become familiar.

### lateinit

The language's strict class initialization rules require every property to be initialized when an instance is constructed. This applies to nullable properties as well, even if you're just initializing them to `null`.

However, there are several frameworks that rely on lifecycle callbacks for initialization rather than the constructor. When working with these, you may end up having to make properties nullable just because you're initializing them later than "constructor-time":

```kotlin
class MyApplication : Application() {
    private var timer: AnimationTimer? = null

    override fun start(primaryStage: Stage) {
        // Setup things
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }
    }
}
```

> Here's a new use of the `object` keyword, an [*object expression*](https://kotlinlang.org/docs/object-declarations.html#object-expressions)! This is the way to create anonymous implementations of interfaces or anonymous subclasses in Kotlin. It's equivalent to using `new AnimationTimer() {}` in Java. Note the parentheses indicating the call to the superclass constructor in the Kotlin syntax, which is the same as with regular subclassing.

The compiler will guarantee null safety by continuously forcing us to perform null checks of one kind or another when we interact with this `timer` property. This is inconvenient, since we know that `timer` will be initialized in time, and never be `null` when we're trying to use it. Both of these calls will work, but they are both unnecessarily verbose, and introduce complexity in the code:

```kotlin
timer?.start()
timer!!.stop()
```

What's even worse is that regular null checks will not work on `timer`, as it's a class-level, mutable property:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer = object : AnimationTimer() { ... }

    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

> e: Smart cast to 'AnimationTimer' is impossible, because 'timer' is a mutable property that could have been changed by this time

The compiler's worry here is that the class might be used in a multithreaded environment, where a thread executing in parallel to the current one may change the value of `timer` between the `if` statement's condition being evaluated and its body executing, which could lead to an NPE.

> We'll see a neat way to perform a null check for such a `var` later on.

The solution for this is the `lateinit` keyword, which signals to the compiler that a property will be initialized late - later than constructor time. (In the case of a `lateinit` local variable, later than declaration time.)

By using it, you, the developer, will bear the responsibility of initializing the property before you start using it. In turn, the compiler will stop worrying about it, and let you use it freely. Using this keyword is the equivalent of turning `null` safety off, but it's appropriate and useful in situations like these.

Adding it to `timer` lets us make it non-nullable (in fact, `lateinit` declarations can not be nullable), and use it freely:

```kotlin
class MyApplication : Application() {
    private lateinit var timer: AnimationTimer

    override fun start(primaryStage: Stage) {
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }

        timer.start()
        timer.stop()
    }
}
```

What happens if you fail to initialize such a property in time? You'll get a nicely formatted `UninitializedPropertyAccessException`, with a message like this:

> lateinit property timer has not been initialized

If you ever forget to set a `lateinit` variable in time, this is still more useful for tracking down the issue than getting a generic NPE.

### Java interop, platform types

Kotlin prides itself on interoperability with the native languages and tools of whatever platform you're running it on. Since Java doesn't have a language level concept of nullability, how can Kotlin's strict null handling be reconciled with going back and forth between the two languages?

##### Kotlin to Java interop

By default, declarations coming from Java have _platform types_. This means that their nullability is just... Unknown. ¯\\\_(ツ)\_/¯

For example, consider this class, which - like most Java code - contains no nullability information.

```java
public class JavaTest {
    String platform;

    public JavaTest(String platform) {
        this.platform = platform;
    }
}
```

This is true about the data it's storing, as well as its constructor parameter. Both of these will have the platform type of `String!` when looking at them from Kotlin. Platform types are *non-denotable*, meaning that while they're a part of the language, they can not be used directly in source code. They will only show up in IDE hints and compiler messages.

Whenever we use this class from Kotlin, we are free to pass in either a nullable or non-nullable value as the constructor parameter:

```kotlin
val test1 = JavaTest(null)
val test2 = JavaTest("string")
```

We're also allowed to either perform null handling when we read the value of `platform`, or not:

```kotlin
val test = JavaTest(null)
println(test.platform.length)
println(test.platform?.length)
```

When we work with platform types, our null safety drops to the level of safety that Java provides - *none*. We either perform null checks when something may be null, or we don't, and then we might crash with an NPE.

This seems like a major blow for Kotlin's null safety - and, well, it is. This is the cost of interoperating with a language that inherently doesn't care about nullability, and you'll have to keep this in mind whenever you call a Java-based API. You can hope for the best and just use values that have platform types directly, you can treat all of them as if they were nullable (though the Kotlin compiler won't enforce this), or you can try to balance the two somehow.

> Fun fact: in early stages of the interop design, _everything_ coming from Java was considered nullable, and had to be checked or handled accordingly. While super safe, this turned out to be unfeasible in practice, and was replaced by platform types.

It's a good idea to make your choices about how you treat something with a platform type explicit, by not letting the compiler infer platform types for variables. Instead of this declaration, which implicitly creates a variable with the type `String!`:

```kotlin
val str = test.platform
```

You should choose one of these explicitly typed declarations, which essentially documents whether you thought this value was nullable or not:

```kotlin
val str1: String = test.platform
val str2: String? = test.platform
```

If you choose the former, and `platform` does happen to be `null`, you'll get an exception immediately here, at the assignment. This is *much* easier to track down if it happens than giving the variable a platform type here, and crashing later in your code, when you try to actually use it.

> The bytecode performing the check is interesting to take a look at!

##### Nullability support from Java

So what's the solution for existing code that's written in Java, and all the existing libraries in the JVM ecosystem? How can they aid Kotlin's null safety?

The ultimate solution is to _"just"_ migrate that code to Kotlin, and while [this has been done](https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin), it's certainly not feasible for all of the code in every project. You can still be a good citizen even if you're maintaining Java APIs though, thanks to the Kotlin compiler's support for [nullability annotations](https://kotlinlang.org/docs/java-interop.html#nullability-annotations).

These have been slowly gaining adoption in Java over the years, and several sets of them exist. There's a JSR implementation, and Lombok, Android, and of course JetBrains have their own too, just to mention a few. Each slightly different, each in different packages. The Kotlin compiler supports all of the ones mentioned and more, see [the compiler's source](https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt) for the up-to-date list.

We'll use the JetBrains flavour of these annotations for the examples here. Using these, you can annotate your types in Java like this:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;
}
```

If you're using an IDE that supports these annotations, you'll see a warning on `notNull` here immediately, as it's not initialized by the implicit, empty constructor, and is therefore `null` when an instance of this class is created. 

> This code will still compile, however. These annotations are not enforced by the Java compiler!

This can be fixed by adding a proper constructor:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;

    public JavaTest(@Nullable String nullable, @NotNull String notNull) {
        this.nullable = nullable;
        this.notNull = notNull;
    }
}
```

These annotations will be picked up when using this class from Kotlin, which means that the constructor will have a `String?` and a `String` parameter. You'll be forced to perform a `null` check when you try using `nullable`, and the compiler will warn you that a `null` check is unnecessary if you add one for `notNull`.

```kotlin
val test = JavaTest(null, "string")

println(test.nullable.length) // e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
println(test.nullable?.length) // ok

println(test.notNull.length) // ok
println(test.notNull?.length) // w: Unnecessary safe call on a non-null receiver of type String
```

These annotations are trusted by the compiler, but unlike Kotlin's nullability, they aren't actually verified at compile time. You can easily write and compile code like this, as it only shows an IDE warning:

```java
@NotNull
String getData() {
    return null;
}
```

This method would be visible with a non-nullable return type in Kotlin, and probably cause crashes on the Kotlin side at some point.

It's your responsibility that you annotate your APIs correctly with these annotations. Providing these annotations makes the lives of both your Java and Kotlin clients easier, and if you are maintaining a Java API, you should definitely make use of them.

> In the Android community, the adoption of these annotations escalated quickly as Kotlin gained more and more popularity.

##### Java to Kotlin interop

What about the other direction, calling Kotlin code from Java? If you are using an IDE that understands nullability annotations in pure Java code, it will likely also pick up Kotlin nullability information, as the compiler injects these annotations into the bytecode produced from Kotlin sources.

Yet again, this won't be enforced when compiling Java code against a Kotlin API, but it will be present for you as extra information when you're writing your Java code, letting you code safer.

### Nullable basic types

Basic types (such as `Int`) are represented as a primitive at the bytecode level whenever possible. For example, the parameter of this function will be a primitive:

```kotlin
fun calculate(x: Int) { ... }
```

Decompiled, we'd be looking at code like this:

```java
void calculate(int x) { ... }
```

However, if we use a nullable type, the boxed variants of basic types will have to be used instead. Since primitives are not reference types, they can't hold `null` as their value.

```kotlin
fun configure(x: Int?) { ... }
```

Decompiled, we'll see the boxed type, which allows us to potentially pass `null` into this function:

```java
void configure(@Nullable Integer x) { ... }
```

### Runtime checks

Until now, we've talked about the compile time checks that are performed to grant null safety. These, however, aren't quite enough on their own. When you're calling into Kotlin from Java, you can easily pass in `null` for a parameter that's declared as non-nullable, and the implementation of the method won't be prepared for this.

As an example, let's take this method that takes a `String` as a parameter, and prints its characters line by line. It also modifies some state at the start and end of the method, which prevents multiple invocations printing two strings at the same time (let's ignore the threading issues with setting a regular `Boolean` flag here).

```kotlin
var printing = false

fun printCharacters(str: String) {
    if (printing) return
    printing = true

    for (c in str) {
        println(c)
    }

    printing = false
}
```

You can easily pass in `null` as the parameter if you call this method from Java:

```java
public static void main(String[] args) {
    Printer().printCharacters(null);
}
```

This would cause an exception when the `for` loop attempts to iterate it. As the `printing` flag has already been set at that point, this would leave your application in a broken state, never being able to print anything again. (Assuming that you've handled the exception, and the method has a chance to be called again.)

To prevent this kind of unexpected failure, caused by the presumed safety that you had when you implemented the Kotlin method, the compiler performs additional null checks at runtime, by injecting code during compilation. These pieces of code, again, can be found by decompiling the bytecode:

```java
public final void printCharacters(@NotNull String str) {
    Intrinsics.checkParameterIsNotNull(str, "str");
    if (!printing) {
        printing = true;
        /* ... For loop ... */
        printing = false;
    }
}
```

Since these checks are performed immediately at the beginning of the function before any of your code is executed, a failing check throwing an exception means that it's as if the incorrect call never even happened. This prevents your application from ending up in an unexpected, invalid state by aborting execution somewhere halfway through your method.

These kinds of null checks, and many other utility methods are contained by the [`Intrinsics`](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Intrinsics.java) class. You'll see static calls to it all over decompiled bytecode: for values of parameters and fields, return values, when using the `!!` operator or `lateinit` variables, and more.

It's also worth noting that these checks will generate nicely formatted, specific exception messages, which is why you'll see identifiers, and sometimes even longer pieces of code being passed into them as strings (such as the name of the parameter in the example above).

## Summary

Nullability is a core part of Kotlin's type system. Types are all nullable or non-nullable. When operating on nullable values, the compiler enforces performing null checks.

Safe calls `?.` skip calls to methods if the reference they were (would have been) invoked on is `null`. The Elvis operator `?:` yields its left-hand value if that's not `null`, and the right-hand value otherwise. The `!!` operator is a quick way to throw an NPE.

`lateinit` takes the responsibility of checking nullability out of the compiler's hand, and is useful when working with frameworks.

Safe casts `as?` allow rewriting type checks to nullability problems.

By default, Java declarations show up with platform types in Kotlin, which are unsafe to use. This can be improved upon by using nullability annotations.

## Sources

- [Null is your friend, not a mistake - Roman Elizarov](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5)
- [Dealing with absence of value - Roman Elizarov](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903)
- Official documentation:
  - [Nullability](https://kotlinlang.org/docs/reference/null-safety.html)
  - [Calling Java from Kotlin](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#null-safety)

# Chapter 4: Functional Programming

In [chapter 2](2.md), we've looked at Kotlin's support for object-oriented programming. The other major paradigm that Kotlin supports is [*functional programming*](https://en.wikipedia.org/wiki/Functional_programming).

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside a class, they are just parts of classes - the larger, *more important* concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. This is how a mathematical function tends to work. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify that state.
  - Pure functions have many advantages, the most important one of these is perhaps *referential transparency*, which means that they always produce the same results for the same inputs. This makes it very easy to reason about them, and also facilitates testing.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code, as you have to keep thinking about the current state of the application as you're performing actions. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - Shared mutable state being accessed from multiple threads in an application is also a frequent source of bugs.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy` method generated for data classes. We'll find more of the same when we get to collection types in the next chapter.
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's [collection handling](./5.md#collection-processing), which we'll learn about later.

So when can a language declare that it's functional? Does it have to meet some, or all of the requirements above? Maybe even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

JetBrains' stance on the matter is that they consider the support for top-level functions the determining factor. This makes Kotlin a functional language, in addition to being object-oriented.

## Code organization

We've seen that Kotlin has top-level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

> Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin allows for top-level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of each file. Just like classes, other top-level declarations can be used in other packages by importing them.

> Unlike with Java, the packages that files reside in don't *have to* match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the source folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str == null || str.length == 0
}
```

Compiling this, we end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null || str.length() == 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix, leaking the implementation detail of these utilities being written in Kotlin:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/) annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

> In the previous code snippet, `@file` is an [annotation use-site target](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets). These are used to specify what exactly you want to apply an annotation to, when it would otherwise be ambiguous. For example, on a property declared in a primary constructor, you might want to annotate the parameter `@param:`, the property `@property:`, the backing field `@field:`, or the getter `@get:` of the property. This is useful sometimes when using Java-based tools with Kotlin code.

> In combination with `@JvmName`, you can also add the [`@JvmMultifileClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-multifile-class/) annotation to files. This lets you use the same `@JvmName` for multiple files, and all top-level declarations from those files will be combined into a single class in the bytecode!

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (types, really) that you don't own!

For example, if you need a quick and easy-to-read way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is specified before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* of the extension function.
- Invoking an extension has the same syntax as calling a real method of the class. If it's in a different package, it does have to be imported, like any other top-level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, these extensions are implemented as simple static functions on the bytecode level (top-level extensions, that is - member extensions are discussed [below](#member-extensions)).

If we decompile the bytecode from the code above, we'll see just that:

```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation. You can't implement anything with an extension that you couldn't implement in a function that takes the receiver as a parameter - you just get much nicer syntax.

> The [`CharSequence.last()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/last.html) function is actually part of the Standard Library.

---

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method defined in the `Cat` class is invoked. This feature - [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch) - is the basis of polymorphism, a core concept of object-oriented programming. It allows choosing the concrete implementation that is invoked at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the decision about which one to call has to be made at compile time (statically). At that time, all we know for certain is that we have an `Animal` instance. Any concrete `Animal` could (in theory) end up in that reference by the time we have to call `identify` at runtime. Therefore, the definitely-fitting overload is chosen out of our two static functions.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing many, many extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen can be done with the following API, which requires you to pass in a [`Context`](https://developer.android.com/reference/android/content/Context) object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context` itself (like an often-used Android [`Activity`](https://developer.android.com/reference/android/app/Activity)):

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide fewer parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension-oriented design

A significant amount of the functions in the Standard Library are defined as extensions. Many of them extend commonly used types, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on Standard Library types (which could be easily added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, allowing it to more easily change later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

It can be argued that the `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself could be just a data holder, which doesn't have any behaviour.

> This member function also prevents anyone from adding their own function named `traverse` as an extension, which might not be desirable. Members always take precedence over extensions in case of signature clashes.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order), or different actions during the traversal (e.g. draw the tree instead of printing its values to the console).

> What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This syntax is also useful if you want to conveniently use multiple classes with the same name, without having to fully qualify one of them everywhere in a file.

This pattern is referred to as [*extension-oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the Standard Library's collection processing functions, sequences, and coroutines.

> The `@JvmName` annotation mentioned earlier can also be used on individual declarations, like functions. For example, we could rename the `traverse` function above just for Java users by adding an annotation to it.
> 
> ```kotlin
> @file:JvmName("Utils")
>
> @JvmName("traverseNode")
> fun Node.traverse() { ... }
> ```
> 
> Usage from Java would now look something like this (while Kotlin usage remains unchanged):
> 
> ```java
> Utils.traverseNode(node);
> ```
> 
> This comes in handy when something makes sense in the context of Kotlin (for example, as the name of an extension function or an [operator](./8.md#operators)), but results in an odd-to-read call site from Java code, where it's the name of a static method. 

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be "computed" properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is available as `this`, as you might expect.

### Member extensions

Extensions may also be declared *inside a class* (or interface, or object) as a member. In these cases, the extensions behave differently from top-level extensions.

First of all, they will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence (in other words, the closer `this` scope):

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These member extensions are *not* static, instead, they are regular member functions under the hood. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

You can make these extensions `open` or `abstract`, and have subtypes implement them:

```kotlin
abstract class Validator {
    protected abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

While this is technically possible, it's often simpler to use regular functions that take the receiver as an explicit parameter.

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local (covered later, [in chapter 6](./6.md#local-functions)) extensions instead, if applicable.

### Context receivers

Context receivers are an [upcoming feature in Kotlin](https://kotlinlang.org/docs/whatsnew1620.html#prototype-of-context-receivers-for-kotlin-jvm), and they're essentially a variant of extension functions. 

They are currently available only as a prototype, and only on the JVM target, therefore we won't cover them here, other than to note their existence.

You can learn more about them in [this official Kotlin video](https://www.youtube.com/watch?v=GISPalIVdQY).

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun createGreeting(person: Person): String {
    return "Hello, ${person.name}"
}
```

This function takes a `Person` parameter, and returns a `String`. The type of this function is `(Person) -> String`. The function type that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val greetingCreator: (Person) -> String = ::createGreeting
```

Or declare the entire function in-line, and assign it to a variable with a function type immediately (this is very, very rarely used):

```kotlin
val greetingCreator: (Person) -> String = fun(person: Person): String {
    return "Hello, ${person.name}"
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `greetingCreator` function could be implemented in a lambda like this:

```kotlin
val greetingCreator = { person: Person -> "Hello, ${person.name}" }
```

This variable still has the same type as before (`(Person) -> String`), but we are now letting the compiler infer it based on the expression on the right-hand side.

To explain the syntax briefly: the braces `{}` create a new function literal. The input parameters of the function are listed at the very start, inside the braces. As usual, types come after names, and multiple parameters are separated by commas. Then, the `->` separates the parameter list from the body of the lambda.

Lambdas may contain multiple expressions, and they implicitly return their last expression, without a `return` keyword:

```kotlin
val greetingCreator = { person: Person ->
    println("Creating greeting for ${person.name}...")
    "Hello, ${person.name}"
}
```

This function, now defined as a lambda, can still be invoked the same way as before, as the type of the variable hasn't changed:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

If we provide the type of the variable that holds a lambda on the left-hand side, we can omit the type of the lambda's parameter, and let type inference work the other way:

```kotlin
val greetingCreator: (Person) -> String = { person -> "Hello, ${person.name}" }
```

For lambdas that have *only a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether (given that its type can be inferred from context). In this case, it will be available via the implicit name `it`:

```kotlin
val greetingCreator: (Person) -> String = { "Hello, ${it.name}" }
```

> It's common to see long, complex lambdas use this implicit `it` name for their parameter. Be wary of doing this - naming the parameter can go a long way towards increasing readability and avoiding mistakes of operating on the wrong object. A good rule of thumb is to use an explicit name when your lambda doesn't fit on a single line.

### Method references and bound references

We've seen references to top-level functions. You can also reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
val rebecca = Person("Rebecca")
speak(grace) // "Hi, I'm Grace!"
speak(rebecca) // "Hi, I'm Rebecca!"
```

References may also be bound to a specific instance, for example:

```kotlin
val claudia = Person("Claudia")
val speak: () -> Unit = claudia::speak
speak() // "Hi, I'm Claudia!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

> To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher-order functions

### Introduction

A *higher-order function* is a function that takes another function as a parameter or returns a function.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher-order functions, one that executes the function (i.e. a given piece of code) passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it at any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and the corresponding argument is a lambda, we can move that lambda outside the parentheses:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct, such as a `for` loop...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin lambdas on the JVM are implemented as anonymous classes, which implement certain interfaces. For example, the `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on. Here's the declaration of these two interfaces, *simplified* (you can always check out their [full source](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt)):

```kotlin
interface Function0<R> {
    fun invoke(): R
}

interface Function1<P1, R> {
    fun invoke(p1: P1): R
}
```

> These numbered function types only go up to `Function22`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with function types that have more than 22 parameters!

These functional interfaces - such as `Function1` - all define just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of interfaces like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand.

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

> `Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return `Unit.INSTANCE`, unlike with `void` methods, where you can simply omit the return statement.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java, however...

```java
repeat(3, (Function0)null.INSTANCE);
```

It turns out the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with for the time being. If we use a better decompiler (such as [jadx](https://github.com/skylot/jadx)), we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE = new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever created and used over the lifetime of our program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see there is this:

```java
repeat(3, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), which means they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(times, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to... But the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this might feel unsolvable at first, and needs some kind of workaround. In Kotlin, the code above compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This reference to the `ObjectRef` instance is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new `String` instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type for performance reasons - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

These aren't types you need to use yourself - the Kotlin compiler will deploy them as necessary when you capture values from outer scopes that you want to mutate. However, it's good to know that this happens, as it might cause memory leaks if you're not careful.

> If you're writing Java code, you can make use of this pattern manually to solve similar problems.

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions "for free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the following `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you'll see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant, as function calls are not too expensive in general. It's up to you to decide in each case whether inlining a certain function is worth it.

> If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be copied to the call site, bloating your compilation output.

Where inlining is definitely useful and often recommended is with higher-order functions, as it can get rid of allocations! Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the inline function. That sounds complex, but let's take a look at it in practice.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` present anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher-order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult-to-use APIs with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

> The [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) function is actually part of the Standard Library, so you shouldn't implement it yourself.

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside this `repeat` function (changed to be non-inline again!) on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function.

Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the lambda containing a `return` from `test` wouldn't make any sense!

> The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return from:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda?

Yes! The solution for this is to inline the `repeat` function. This way, we know that the lambda we pass to it will only be executed in place, within the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties for later use.

> TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context.

For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created will have no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val runnable = object: Runnable {
        override fun run() { 
            body()
        }
    }
    runnable.run()
}

fun test() {
    funky {
        // Return could not work here
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

Instead of this, we can use `crossinline`, which will still inline the lambda's contents (*inside* the `run` method of the `Runnable` being created), but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable runnable = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    runnable.run();
}
```

> TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

In general, you don't need to worry about remembering the exact mechanics of `noinline` and `crossinline`, as they are rarely used. But it's useful to know they exist so that you can look them up as needed. When you get into the special situations that require them while writing your own code, your IDE will most likely suggest adding them automatically.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

### Inline classes

You might find it odd that we're discussing a type of class here instead of in the earlier chapter about object-oriented programming. However, inline classes relate to two topics we've just covered: inline functions and typealiases. 

An inline class is a wrapper around a single value: it must have exactly one property in its primary constructor. At runtime, usages of the inline class will be replaced by just its contained value ([wherever possible](https://typealias.com/guides/inline-classes-and-autoboxing/) - same as usages of primitives). The idea for these classes is very similar to that of inline functions: allowing you to create extra constructs in your source code, but then eliminating runtime overhead by rewriting the code during compilation.

If your inline class wraps a primitive type, you'll even get all the [performance benefits of using a primitive](./1.md#primitives-vs-boxed-types) at runtime.

Let's take the example of a class that represents an RGB color value. To declare an inline class, we have to use both the `value` keyword and the `@JvmInline` annotation.

```kotlin
@JvmInline
value class Color(private val value: Int)
```

> The `@JvmInline` annotation might seem excessive - why not just `inline class` instead? Inline classes are just one small usages of a more general concept, *value classes*, which will get more support in Kotlin in the future. You can read about this in great detail in the [value classes KEEP document](https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md). 

Since this is a class, we can add properties and methods to it - with the limitation that it can't have properties that would require backing fields. Since the usage of this class is replaced at runtime with just a primitive `Int`, there would be nowhere to store such values.

We can still add properties without backing fields, for example, convenient accessors for each component of the color:

```kotlin
@JvmInline
value class Color(private val value: Int) {
    val red: Int
        get() = (value shr 16) and 0xFF
    val green: Int
        get() = (value shr 8) and 0xFF
    val blue: Int
        get() = (value shr 0) and 0xFF
}
```

The class is used the same way as any other: we can create instances via the constructor, and access members:

```kotlin
val myColor = Color(0x005FFF)
println(myColor.red)    // 0   (00)
println(myColor.green)  // 95  (05)
println(myColor.blue)   // 255 (FF)
```

However, if we decompile the bytecode that this usage of our inline class outputs, we'll see something like this (simplified here!):

```java
int myColor = Color.constructor-impl(24575);
System.out.println(Color.getRed-impl(myColor));
System.out.println(Color.getGreen-impl(myColor););
System.out.println(Color.getBlue-impl(myColor));
```

`myColor` is just a simple primitive `int` value, giving us great runtime performance. The methods and properties of the `Color` class are turned into static functions, which receive the `$this` value to operate on as a parameter (this "trick" should be familiar by now!):

```java
public static int getRed_impl(int $this) { return $this >> 16 & 255; }
public static int constructor_impl(int value) { return value; }
```

> This `Color` class could be improved by adding some range checks to its constructor (into an `init` block). Thanks to how inline classes work, that code would actually be invoked at runtime and could perform its task - even though no class instance is actually constructed.

While typealiases for the same type (and the original type itself) are cross-compatible, inline classes *create new types*, which means that this code won't compile:

```kotlin
val color: Color = 0 // e: The integer literal does not conform to the expected type Color 
```

Kotlin supports [unsigned numerical values](https://kotlinlang.org/docs/basic-types.html#unsigned-integers) such as `UInt` and `ULong`. Under the hood, these are implemented as inline classes as well, simply wrapping their signed counterparts! This way these unsigned types can also be represented as primitives when used on the JVM.

### SAM conversion, SAM constructor

Getting back to the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lack truly standard function types, so libraries usually introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner, often instantiated with lambda syntax.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

The compiler will perform the heavy lifting here, creating an object instance under the hood that implements `View.OnclickListener` and contains the code of the lambda inside the `onClick` method.

When the conversion would be ambiguous due to overloads, or you want to be more explicit about creating an instance, the slightly more verbose *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

> One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

### Functional interfaces in Kotlin

You can declare functional interfaces in Kotlin as well. These are marked not by an annotation (as the Java convention), but with a keyword instead: the `fun` keyword!

```kotlin
fun interface OnClickListener {
    fun onClick(view: View)
}
```

A functional interface can only have a single abstract method (but may have other, non-abstract methods as well). When you need to pass in an instance of such an interface somewhere, you can use the full object expression syntax, but you can also make use of SAM conversions or SAM constructors, exactly as seen in the previous section.

> Fun interfaces are a relatively new feature, available [since Kotlin 1.4](https://kotlinlang.org/docs/whatsnew14.html#sam-conversions-for-kotlin-interfaces). Previously, SAM conversions only worked for interfaces declared in Java, as it was specifically an interop feature for convenience. SAM conversion for Kotlin-declared interfaces was not supported, the reasoning being that you could just use function types in Kotlin instead of interfaces. However, there are times when using a dedicated interface type is more practical than using those function types.

## Summary

One of Kotlin's most advertised features is extensions, which allow you add new functionality onto existing types, even ones that you don't own yourself.

Functions are first-class citizens, just like classes or objects. They can be declared as top-level constructs in a file, and imported individually. Function types are a core part of the language, and they allow functions to be stored in variables, or passed around as parameters. Lambda expressions (function literals) are a concise way to define functions, especially if you're immediately passing them in as parameters.

Functions that take functions as parameters or return functions are called higher-order functions. The cost of passing function parameters to them (implemented as instances of classes under the hood) can be mitigated by making them inline. In certain situations, `noinline` and `crossinline` can come in handy.

Finally, Kotlin provides SAM conversion and SAM constructors as a way to interop with functional interfaces that are declared in Java code, and it also supports declaring functional interfaces.

## Sources

- Official documentation:
  - [Extensions](https://kotlinlang.org/docs/reference/extensions.html)
  - [Higher-Order Functions and Lambdas](https://kotlinlang.org/docs/reference/lambdas.html)
  - [Inline functions](https://kotlinlang.org/docs/reference/inline-functions.html)
  - [Type aliases](https://kotlinlang.org/docs/reference/type-aliases.html)
  - [SAM Conversions](https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions)
  - [Functional (SAM) interfaces](https://kotlinlang.org/docs/reference/fun-interfaces.html)
- [jadx - Dex to Java decompiler](https://github.com/skylot/jadx)

# Chapter 6: Functions, Functions, Functions!

[Previously](./4.md), we've covered Kotlin's first-class support for functions and function types. Now, let's dive even further into some of its capabilities related to functions.

### Local functions

We've seen that we can have functions that exist outside of classes, as top-level declarations in a file - these functions exist on the _package level_. On the other extreme, functions can also exist in very small scopes: within another function. This can come in handy for quick helper functions that won't be used anywhere else in the application.

For example, let's say you have to populate a details screen such as this one:

![A detail screen with a name, role, and address field.](images/6_detail_screen.png)

Here's the model class which contains the value of each field:

```kotlin
class FormData(
        val name: String?,
        val role: String?,
        val address: String?
)
```

The business rule is that for any fields that are missing a value, both the title and the corresponding value field should be hidden. Instead of writing this logic over and over again for each field, we can extract it into a local function, which will only be in scope within the enclosing function:

```kotlin
private fun updateFormData(formData: FormData) {
    fun setTextAndVisibility(title: Text, content: Text, text: String?) {
        val shouldBeVisible = text.isNullOrBlank().not()
        title.isVisible = shouldBeVisible
        content.isVisible = shouldBeVisible
        content.text = text
    }

    setTextAndVisibility(nameTitle, nameContent, formData.name)
    setTextAndVisibility(roleTitle, roleContent, formData.role)
    setTextAndVisibility(addressTitle, addressContent, formData.address)
}
```

> [`isNullOrBlank`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-null-or-blank.html) is one of the many handy `String` extensions from the Kotlin Standard Library. We'll take a look at more of them in the [next chapter](./7.md#strings).

Note that this function also has access to the parameters of the enclosing function - it acts as a closure.

### Function literals with receivers

As stated before, Kotlin doesn't generally claim to have original features. Almost everything it does has been done in other languages before - though Kotlin does often improve on syntax and cohesion.

One feature that Kotlin does claim to have uniquely is *function literals with receivers* (or lambdas with receivers). This a powerful combination of two features that we've looked at before: lambdas and extension functions.

Not only can a function type in Kotlin have parameters and a return type, it can also have a *receiver*. For example, take the following, simple extension function from earlier:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}
```

If we create a reference to this, and assign it to a variable, we can type it like so:

```kotlin
val ref: String.() -> Char = String::lastChar
```

> Notice that an extension function on a type can be referenced with the `::` syntax, just like any real member of that type.

Similarly to how `String.` preceded the function name at its declaration to indicate that it's an extension on the `String` type, when declaring a function type that's an extension, the same `String.` syntax can show up before the parentheses of the parameter list.

Next, we'll look at two examples of higher order functions which make excellent use of this feature.

#### The StringBuilder example

First, let's take a look at an example that showcases that we can be placed in the scope of *any* object with such a lambda, even ones that we don't create ourselves.

[`StringBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) is a well-known class from Java that allows us to assemble strings from pieces without having to create many intermediate `String` instances, which would then be thrown away, wasting allocations. The basic usage of its API looks like this:

```kotlin
// 1
val builder = StringBuilder()
// 2
builder.append("Little Timmy is ")
builder.append(age)
builder.append(" years old today")
// 3
val result = builder.toString()
println(result)
```

There's a pattern here, which is repeated every time a `StringBuilder` is used.
 
 1. We create an instance.
 2. We perform a set of actions on it (various `append` calls).
 3. Finally, we call `toString` on it, to fetch the `String` that we've built.

Let's extract this to a higher order function, using lambdas with receivers:

```kotlin
inline fun buildString(actions: StringBuilder.() -> Unit): String {
    val builder = StringBuilder() // 1
    builder.actions()             // 2
    return builder.toString()     // 3
}
```

This function receives a lambda as a parameter, which itself *is an extension on `StringBuilder`*. This is practically the same as a lambda that receives a `StringBuilder` as a parameter, it just takes that reference as its *receiver* instead - either way, it can operate on it.

Inside `buildString`, we perform the pattern pointed out earlier:
 
 1. We create a new instance of `StringBuilder`.
 2. We perform the `actions` *on* it - which we can do, as `actions` is an extension on `StringBuilder`.
 3. We extract and return the result stored in the builder.

The real magic, however, happens on the call site, which looks like this:

```kotlin
val result = buildString {
    this.append("Little Timmy is ")
    append(age)
    append(" years old today")
}
println(result)
```

Within the curly braces defining the lambda that we're passing in to `buildString`, we are in the body of an extension on the `StringBuilder` type. This means that `this` refers to *some instance* of a `StringBuilder` (in this case, this will be the one being created inside the `buildString` function). Methods on `StringBuilder` can also be called without a qualifier in front of them, as if we were within the body of that class.

> It's important to see that all we are doing is defining an extension function on `StringBuilder` (with a lambda, for the sake of this example), because that's what the `buildString` function requires as a parameter. After we pass this parameter in, we don't actually know what `StringBuilder` instance (or instances) this lambda will be called on, how many times, or at what time.

Being able to "set the scope" of a lambda to any object so that it can operate *on* it is an immensely powerful language feature, and we'll see it used for various purposes.

#### The database example

Another classic example of using a function literal with a receiver, as well as some other functional language features, is that of a database transaction (as presented [by Jake Wharton in this talk](https://youtu.be/A2LukgT2mKc?t=1463)). Let's say we have the following database interface:

```kotlin
interface Database {
    fun beginTransaction()
    fun commitTransaction()
    fun rollbackTransaction()
    fun insert(item: Int)
    fun delete(item: Int)
}
```

We'll assume that `insert` and `delete` might throw exceptions (`IllegalStateException`, specifically) if the item being inserted already exists, or if there's nothing to delete. Every modification has to happen inside a transaction, which can be started with `beginTransaction`, and then either cancelled with `rollbackTransaction` in the case of an error, or completed with `commitTransaction` if everything went well.

So basic usage when we need to interact with this database will look like this:

```kotlin
db.beginTransaction()
try {
    db.insert(11)
    db.delete(12)
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
}
```

We'd ideally want to focus on just the one tiny bit of code in the middle that matters to us from the example above - the insert and delete operations. Everything else is just boilerplate we'll repeat every time we touch the database. We can easily introduce a higher order function that takes care of all the ceremony of handling transactions and exceptions for us, extracting just that inner code into a parameter:

```kotlin
fun inTransaction(db: Database, block: () -> Unit) {
    db.beginTransaction()
    try {
        block()
        db.commitTransaction()
    } catch (e: IllegalStateException) {
        db.rollbackTransaction()
    }
}
```

We can now use this function as clients, by passing in our two operations in a lambda:

```kotlin
inTransaction(db) {
    db.insert(11)
    db.delete(12)
}
```

Now, let's make use of extension functions, and make our helper function an extension on `Database`, to make the call site even nicer:

```kotlin
fun Database.inTransaction(block: () -> Unit) {
    beginTransaction()
    try {
        block()
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}

db.inTransaction {
    db.insert(11)
    db.delete(12)
}
```

Next, let's make the lambda we're passing in take the `Database` as a parameter, so that we can make sure that our block of code operates on the same instance that we've started the transaction on:

```kotlin
fun Database.inTransaction(block: (Database) -> Unit) {
    beginTransaction()
    try {
        block(this)
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}
```

We now get the `Database` in our lambda as the single parameter, which means that it can be referred to as `it` by default:

```kotlin
db.inTransaction {
    it.insert(11)
    it.delete(12)
}
```

Now, to put our newly acquired knowledge of lambdas with receivers to work, it's time for another improvement. Even better than giving the lambda supplied by our clients a `Database` as a parameter, we can *put them in the scope of the `Database`* that they'll operate on, by making the lambda parameter an extension on that type.

```kotlin
fun Database.inTransaction(block: Database.() -> Unit) {
    beginTransaction()
    try {
        this.block() // or just block()
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}
```

With that, the call site is as clean as can be - inside the braces, we're writing code as if we were in the `Database` class. We're also still in a transaction.

```kotlin
db.inTransaction {
    insert(11)
    delete(12)
}
```

Of course, we mustn't forget performance. Passing in a lambda would mean an object allocation, which we can avoid by making the method `inline`:

```kotlin
inline fun Database.inTransaction(block: Database.() -> Unit) { /* ... */ }
```

Having the code handling transactions and performing the try-catch inlined will result in bytecode that's the same as if we've written these structures around our database operations everywhere in our codebase where we perform them. However, at the source level, we don't have to implement it over and over again. We've abstracted out the logic for it into a reusable function, and we did this, yet again, *for free*.

### Tail recursion

It's a relatively well-known fact (at least in computer science circles) that anything that can be solved iteratively can also be solved with recursion, and vice versa. Many problems lend themselves naturally to the recursive approach, calculating [factorials](https://en.wikipedia.org/wiki/Factorial) being one of them. The trivial recursive implementation of factorial looks like this:

```kotlin
fun fact(n: Int): Int {
    if (n == 0) 
        return 1
    return n * fact(n - 1)
}
```

This function works well enough - ignoring the upper limits of the `Int` type for the sake of this section - but it builds a call stack which is as deep as the parameter that was passed in. Why is this call stack maintained? Because when the last call of `fact` in the stack returns `1`, each level of the stack has to be visited backwards, so they can multiply the result calculated so far with their own `n` value, before returning it, thus removing their function call's frame from the stack.

There's another way to implement this same recursion, using an accumulator variable, `res`, which we'll expect clients to set to `1` initially. Inside the function, if we've reached the end of the recursion, we return whatever value is in `res`. Otherwise, we go a level deeper, decrementing `n`, and performing the multiplication on `res`.

```kotlin
fun fact(n: Int, res: Int): Int {
    if (n == 0)
        return res
    return fact(n - 1, res * n)
}
```

This means that instead of doing the multiplication going upwards, while unwinding the stack, we're instead performing it on the way down to the bottom. When we reach the bottom, we already have our final value computed. At this point, all the intermediate steps of walking back through the stack are unnecessary. Nothing happens in those intermediate functions anymore, they all just return what they've received from a level down. We don't really need the call stack here!

This is a well-known pattern, called [*tail recursion*](https://en.wikipedia.org/wiki/Tail_call). A function is tail-recursive if all of its recursive calls to itself are the very last call in the function (in a given execution branch, that is), and if the result of that recursive call is returned *as-is*, without any additional operations being performed.

In such functions, the recursive calls and the stack building can be optimized away, so that the recursion is replaced with an iterative solution *at compile time*. The trick is simple: instead of performing a recursive call at the tail of the function, simply rewrite the values of the function's parameter with those values that are in the recursive call's parameter list (in the current call frame), and then jump back to the beginning of the function to execute it again! This is semantically the same as performing the recursive call, but it doesn't deepen the stack.

Some compilers perform this optimization automatically when they notice that a function is tail recursive. Kotlin, however, chooses to be explicit about this. You have to mark your function with the `tailrec` keyword for the optimization to kick in:

```kotlin
tailrec fun fact(n: Int, res: Int): Int {
    if (n == 0)
        return res
    return fact(n - 1, res * n)
}
```

[Why?](https://stackoverflow.com/q/51638557/4465208) Well, mostly to make sure that whatever you want optimized is truly eligible for the optimization. If you mark a function that's not truly tail recursive with the keyword, you'll get a warning.

This tail-recursive implementation comes with the downside of requiring callers to pass in an extra `1` as a parameter, which is a bit odd. This can be easily fixed by adding a one-parameter helper function for clients to use (and the recursive function could then be marked `private`):

```kotlin
fun fact(n: Int) = fact(n, 1)
```

### The Standard Library's scoping functions

The Standard Library contains a small suite of very simple functions that perform basic "scoping" operations, using features we've learned about: higher order functions and function literals with receivers.

These are used so frequently in Kotlin that they are often seen as language features - but it's important to see that these are not special whatsoever, and you could implement any of them in a minute. They, as many other constructs in the language, are just *functions*.

#### The `let` function

Let's start with [`let`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html). `let` is defined as an extension on a generic `T` type, so you can invoke it on any value. It takes a lambda as its parameter, which accepts the same `T` type, and returns some `R` type.

This all sounds rather abstract, so let's just take a look at the implementation:

```kotlin
public inline fun <T, R> T.let(block: (T) -> R): R {
    return block(this)
}
```

So what does `let` do, in simple terms? It executes the piece of code you pass to it (usually as a lambda). Your lambda will be called with the receiver of `let` as its parameter. Whatever you return from the lambda will also be the return value of the `let` call. 

Take this example:

```kotlin
val length = File("./README.md").let {
    println(it.name)
    println(it.absoluteFile)
    println(it.length())
    it.length()
}
```

Inside the lambda, `it` will refer to the `File` instance, as that's what you've called it *on* - that's the receiver of `let`. The last expression of the lambda will be the return value of the entire `let` call.

> Remember the [`map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html) function? You can think of `let` as a `map` operation on a single element.

You can use `let` instead of creating a local variable to introduce a temporary name for an object, if you give the lambda's incoming parameter an explicit name. Take a look at this usage of `let`:

```kotlin
File("./README.md").let { file ->
    println(file.name)
    println(file.length())
    println(file.absoluteFile)
}
```

Since `let` is `inline`, this is exactly equivalent* to the following code, which creates a regular local variable, with no extra cost at runtime (no actual lambda allocation, for example).

_*except `let` also contains the variable in its own scope_

```kotlin
val file = File("./README.md")
println(file.name)
println(file.length())
println(file.absoluteFile)
```

A popular use case for `let` is using it to perform `null` checks. Since there's a function invocation (not really, due to inlining, but semantically and on the source level) right before the actions are executed on the receiver of `let`, a safe call can be injected here:

```kotlin
val someFile: File? = ...
someFile?.let { file: File ->
    println(file.name)
}
```

If `someFile` happens to be `null`, the function call `let` will simply not be invoked by the safe call operator. If it *is* invoked, we get the receiver inside the lambda with a non-null type. This makes sense: if it *was* null, the lambda wouldn't be executing in the first place. This is a `null` check, which conditionally executes the code inside the lambda that we've passed in!

This `null` check is a versatile one. It can, for example, be used in the situation of dealing with a nullable, class level property which is declared as a `var`. We've seen before that these can not be `null`-checked and smart cast by regular means:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

The issue was that the value of `timer` was being read again inside the body of the `if` statement, and it might have a new value by that time, which might be `null`.

This isn't an issue for the `?.let {}` idiom, however. Take the following code:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer?.let {
        it.stop()
    }
}
```

If `timer` is not `null`, its current value is passed into the `let` function and then back into the lambda as a parameter. If the value of the property changes in the meantime, that change won't be reflected in the reference that the lambda receives - that reference is held onto as a parameter value, and can not change.

The `let` call here is equivalent to this longer, more manual solution:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
   val t = timer
   if (t != null) {
       t.stop()
   }
}
```

In essence, we are using `let` to very concisely create this local, temporary copy of the reference that's stored in the property.

#### The `apply` function

Along with `let`, [`apply`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html) is one of the most used scoping functions in Kotlin.

`apply` can also be called on any generic type, and it also takes a lambda as its parameter. This lambda is an extension on the type that `apply` was called on, and `apply` invokes the lambda on its receiver. In other words, the lambda is *applied to* the object. Finally, `apply` returns the original object. 

Here's all of that in code:

```kotlin
public inline fun <T> T.apply(block: T.() -> Unit): T {
    this.block()
    return this
}
```

Let's see a real-life use case. Take a `Rectangle` class, which only has a no-param constructor. If you want to create an instance and initialize it, you'll end up writing code like this:

```kotlin
val rect = Rectangle()
rect.x = 8.0
rect.y = 9.0
rect.width = 100.0
rect.height = 200.0
```

Using `apply`, you can move your code *into the scope of* that `Rectangle`, as its parameter will be an extension on the `Rectangle` type, and executed on the receiver. This lets you be a lot more concise with these assignments:

```kotlin
val rect = Rectangle().apply {
    x = 8.0
    y = 9.0
    width = 100.0
    height = 200.0
}
```

Remember our earlier `buildString` implementation?

```kotlin
inline fun buildString(actions: StringBuilder.() -> Unit): String {
    val builder = StringBuilder()
    builder.actions()
    return builder.toString()
}
```

We can now rewrite this using `apply`, to avoid having to create a local variable:

```kotlin
inline fun buildString(builderAction: StringBuilder.() -> Unit): String =
    StringBuilder().apply(builderAction).toString()
```

> The [`buildString`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/build-string.html) function is actually part of the Standard Library, with this exact implementation.

This is all that `apply` does: it executes an extension on its receiver, and then returns the original object. It's a quick way to open a lambda into the scope of an object, and is usually used at object creation and initialization.

#### Also, run.

There are two more extensions that are more rarely used variations on these previous two.

[`also`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html) is similar to `apply`, as it returns its receiver. It also executes the lambda passed to it, but it passes in its receiver as a parameter (unlike `apply`, which exposed it to the lambda as a receiver). 

```kotlin
public inline fun <T> T.also(block: (T) -> Unit): T {
    block(this)
    return this
}
```

Like `apply`, this is usually used around object creation, to perform side effects:

```kotlin
fun register(name: String): Person {
    return Person(name).also {
        log(it)
    }
}
```

> This could also be done by using `apply`, it would simply change the syntax inside the lambda to `log(this)`. In general, a good rule of thumb is that you shouldn't really need to reference `this` inside an `apply` call. If you find yourself doing that, consider using `also` instead.

---

[`run`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html) is similar to `let`, it returns the result of the lambda passed to it, performing a mapping operation. However, inside the lambda, it exposes its receiver as a receiver (unlike `let`, which uses a regular function parameter instead).

```kotlin
public inline fun <T, R> T.run(block: T.() -> R): R {
    return block()
}
```

---

Here's a handy chart to sum it all up:

![Chart of scope functions](images/6_scope_functions.png)

The [`with`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html) function deserves an honourable mention. It's just like `run`, as it places code into the scope of a given object. However, instead of being an extension, it's a regular function that takes its "receiver" as the first parameter.

```kotlin
with(robot) {
    goForward()
    turnLeft()
    goForward()
    turnRight()
}
```

#### The `use` function

An excellent example of just how powerful Kotlin's features around functions are is its [`use`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html) function. This function is equivalent to the try-with-resources construct in Java, which automatically closes a given resource when the end of its block is reached:

```java
try (PrintWriter writer = new PrintWriter(new File("test.txt"))) {
    writer.println("Hello World");
}
```

In Kotlin, we can replace this language construct with a simple call to a higher order function:

```kotlin
PrintWriter(File("test.txt")).use { writer -> 
    writer.println("Hello World") 
}
```

Here's a (greatly simplified) version of the `use` function's implementation, to give you an idea of how it works:

```kotlin
public inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {
    try {
        return block(this)
    } catch (e: Throwable) {
        throw e
    } finally {
        close()
    }
}
```

> The real implementation has a lot more error handling - exceptions and Closables are a complex topic.

## Summary

Kotlin has a lot to offer when it comes to functions. It has functions in many scopes: top-level, member, and even local functions.

One of its most powerful functional features is *function literals with receivers*, which allows you to place the caller of your function into the scope of a specific type when they're defining a lambda.

The Standard Library offers several of its own scoping functions (building on lambdas with receivers, as well as higher order functions in general) that make simple, everyday tasks easier.

## Sources

- Official documentation:
  - [Local functions](https://kotlinlang.org/docs/reference/functions.html#local-functions)
  - [Function literals with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver)
  - [Scope Functions](https://kotlinlang.org/docs/reference/scope-functions.html)

# Chapter 7: Standard Library Showcase

The [Kotlin Standard Library](https://kotlinlang.org/api/latest/jvm/stdlib/) contains a vast amount of useful functions. This includes various utilities (some of which we've already seen), as well as extensions for many common types that makes working with them a lot easier than their original APIs. In this chapter, we'll look at some small helper functions used to describe preconditions, and then two commonly used groups of extensions, for the `String` and `File` types.

Finally, to put what we've learned about collection processing earlier into practice, we'll perform some processing on an interesting data set - crime statistics from Chicago.

## Preconditions

Whenever we define a function, we list the parameters that it takes, and the types of these parameters. This, however, is not quite enough to describe the _contract_ of a function. We might also want to specify how and when the function may be called. We might place a restriction on the current state of the application, or the values of the arguments that are being passed in. To look at how Kotlin helps us clearly state these expectations, we'll use a simple `Reader` interface:

```kotlin
interface Reader {
    fun open()
    fun close()
    fun readBytes(byteCount: Int): ByteArray
}
```

We'll implement a `FileReader` based on this interface, which can read the contents of a given file:

```kotlin
class FileReader(private val fileName: String) : Reader {

    private var inputStream: FileInputStream? = null

    override fun open() {
        inputStream = FileInputStream(File(fileName))
    }

    override fun close() {
        inputStream?.close()
        inputStream = null
    }

    override fun readBytes(byteCount: Int): ByteArray {
        val arr = ByteArray(byteCount)
        inputStream!!.read(arr)
        return arr    
    }

}
```

The reader can be initialized with a filename, and uses a [`FileInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html) to read from that file.

If we take a good look at `readBytes` method, we can find a couple of issues in it:

- There is a use of the `!!` operator here, which will result in a `NullPointerException` if the `open` method hasn't been called yet. Not exactly friendly behaviour.
- The other issue is less obvious: if a negative value is passed in as the parameter, we'll attempt to allocate an array with a negative length, which is invalid, and also produces an exception.

How can we make sure that these things don't happen? For starters, documenting these methods might be a good idea:

```kotlin
/**
 * Opens the reader. Every call to this method
 * must be followed by a call to [close] to
 * free up underlying resources, when the
 * reader is no longer being used.
 */
fun open()

/**
 * Closes the reader, freeing up any resources
 * associated with it.
 */
fun close()

/**
 * Reads bytes from the reader. The reader must
 * be open for this operation.
 * 
 * @param byteCount The number of bytes to read.
 *                  Must be a positive number.
 */
fun readBytes(byteCount: Int): ByteArray
```

> Kotlin's documentation format is called [KDoc](https://kotlinlang.org/docs/kotlin-doc.html). Its syntax is very similar to JavaDoc, but it extends it with Markdown support and some additional block tags that are Kotlin-specific (e.g. `@property`). [Dokka](https://github.com/Kotlin/dokka) may be used to generate documentation from Kotlin code comments.

This, of course, makes us reliant on everyone reading the documentation for our interface, and if the methods are used incorrectly, they'll still result in exceptions. To fix this, we'll use two functions from the Standard Library to codify our requirements for the `readBytes` method: `check` and `require`.

> What we're doing here falls in line with another item of *Effective Java*: *Item 49: Check parameters for validity*. There's also a corresponding item in the [*Effective Kotlin*](https://leanpub.com/effectivekotlin) book: *Item 5: Specify your expectations on arguments and state*.

[`check`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html) is meant to ensure that our application is in some expected state at the given time. What we want to check in this case is that our `inputStream` is non-null when `readBytes` is called:

```kotlin
override fun readBytes(byteCount: Int): ByteArray {
    val input = inputStream
    check(input != null) { "Reader must be opened first" }

    val arr = ByteArray(byteCount)
    input.read(arr)
    return arr
}
```

This call will throw an `IllegalStateException` with the given message if its parameter doesn't evaluate to `true`. As a bonus, thanks to [a certain advanced language feature](https://kotlinlang.org/docs/whatsnew13.html#contracts), the compiler can infer that the `check` function not throwing an exception means that `input` was not null, and gives us a smart cast from `FileInputStream?` to `FileInputStream`, which lets us get rid of the usage of `!!`.

Similarly, we can use [`require`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html) to state our expectations about the method's parameter, and will throw an `IllegalArgumentException` if the condition fails:

```kotlin
require(byteCount > 0) { "Byte count has to be a positive number (was $byteCount)" }
```

You might have noticed that the second parameter of these functions is not just a regular `String` - it's a lambda that returns a `String`. Why is this useful? This way, if the message has to be constructed (for example, concatenated together from multiple pieces, to include values of variables in it, like above), this computation won't happen on the happy path. If we were passing in a `String` as the parameter, we'd always have to format the error message before performing the check - unnecessarily, most of the time. The indirection that a lambda offers allows us to do this work lazily.

> You might ask: doesn't a lambda allocation's cost outweigh the gains of not assembling these `String`s? Take a look at the implementation of these functions to figure out why that's not an issue (but try to guess first!).

Notice how having these checks and requirements at the very top of our method makes them very easy to read if someone navigates to the source code. They are also clearly separated from the actual implementation of the method.

```kotlin
override fun readBytes(byteCount: Int): ByteArray {
    val input = inputStream
    check(input != null) { "Reader must be opened first" }
    require(byteCount > 0) { "Byte count has to be a positive number (was $byteCount)" }

    val arr = ByteArray(byteCount)
    input.read(arr)
    return arr
}
```

These checks that we've added are very similar to the [runtime null checks](./3.md#runtime-checks) added by the Kotlin compiler for nullable parameters, and they serve the same purpose: they prevent executing the implementation inside the method completely if given preconditions fail, instead of allowing an unexpected crash somewhere down the line.

> Handling exceptions in a way that leaves the application in a healthy state is actually yet another piece of advice from Effective Java: *Item 76: Strive for failure atomicity*.

> The `open` method also has a bug: if called multiple times without `close` being called, we'll lose references to open `FileInputStream` instances, thus leaking resources. Fix this bug using the helpers we've just learned about!

### Null checking

Preconditions are often about the nullness of values, checking whether something is null or not. Therefore, the Standard Library functions specifically for null checking, like [`checkNotNull`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html), which could replace the usage of `check` above:

```kotlin
val input = checkNotNull(inputStream) { "Reader must be opened first" }
```

Like `check`, this function throws an `IllegalStateException` if its condition fails (if its parameter was null). Otherwise, it returns the value as a non-null type, allowing us to merge this check with the declaration of the `input` variable. Neat!

Notice that `checkNotNull` is essentially the same as writing down `inputStream!!`. However, it looks a bit more deliberate in your code, and it allows you to provide a meaningful exception.

> There's also a [`requireNotNull`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html) function, which follows the semantics of `require`.

## Strings

When we're using strings in Kotlin, we're using the [`kotlin.String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/) type - but under the hood, this is nothing but a [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html). This is another example of a [mapped type](https://kotlinlang.org/docs/java-interop.html#mapped-types). We are using the regular Java `String` at the bytecode level and at runtime, but at the source level, we see it through a different interface.

This interface has some slight changes from the Java variant (for example, `length` is a property, while it used to be a function), and is generally very bare-bones. Lots of the functionality that we can find right inside the `java.lang.String` class is missing. There's no `isEmpty`, `indexOf`, `toLowerCase`, and so on. Not even constructors!

```kotlin
package kotlin

public class String : Comparable<String>, CharSequence {
    companion object {}

    public operator fun plus(other: Any?): String
    public override val length: Int
    public override fun get(index: Int): Char
    public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence
    public override fun compareTo(other: String): Int
}
```

Worry not, we're just looking at another example of [extension oriented design](./4.md#extension-oriented-design) here. The class contains only the very essential functionality that it needs (e.g. `get`, `length`, or `plus`), presenting a minimal API, and everything else is implemented on top of this as extensions.

```kotlin
println("".isEmpty()) // true
println("kitten".isEmpty()) // false
println("kitten".indexOf('t')) // 2
println("KitTeN".lowercase()) // "kitten"
```

Not only is the base functionality of `java.util.String` provided as extensions, there's much, much more in terms of useful functions:

```kotlin
println("".isNotEmpty()) // false
println("   \t   \n\t ".isBlank()) // true
println("   word       ".isNotBlank()) // true
println("kitten".lastIndexOf('t')) // 3
println("kitten".replaceFirstChar { it.titlecase() }) // "Kitten"
println("   kitten     ".trim()) // "kitten"
println("kitten".reversed()) // "nettik"
```

> A `String` is considered "blank" by these APIs if it only contains whitespace.

There's one more thing missing from the `kotlin.String` class: constructors. They are replaced by top-level factory functions, which use the widespread Kotlin convention of being named after the class that they're creating, making them look just like real constructors:

```kotlin
public inline fun String(chars: CharArray): String
public inline fun String(bytes: ByteArray): String

String(charArrayOf('a', 'b', 'c'))
String(byteArrayOf(0x68, 0x65, 0x78))
```

### Raw strings

A handy language feature that we didn't cover yet is [*raw strings*](https://kotlinlang.org/docs/basic-types.html#string-literals). A raw string is bounded by `"""` (triple quotation marks) on each end, and it can contain nearly any character. This includes those that usually have special meaning inside a `String`, such as `\`,  and even newlines.

> String templates, using `$`, are still evaluated as normal.

```kotlin
val map = """
    X X
     X 
    X X
"""
```

Printing the value of `map` above will print the following:

```

    X X
     X 
    X X

```

Both the newlines at the start and end of the string are present, as well as the indentation at the start of each line.

The Standard Library makes using multi-line strings even easier, by letting you manage the whitespace at the start of each line, to keep your code neatly formatted. To remove the smallest amount of common whitespace from the start of each line, you can use [`trimIndent`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html):

```kotlin
val map = """
    X X
     X 
    X X
""".trimIndent()
```

This makes our output a lot nicer:

```
X X
 X
X X
```

Another similar function is [`trimMargin`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html), which will remove whitespace and the first occurrence of a given prefix character (`|`, by default) from each line:

```kotlin
val map = """
        |X X
        | X
        |X X
""".trimMargin()
```

In our example, this achieves this output again:

```
X X
 X
X X
```

These two functions might seem like they perform expensive computations - and they do. However, if you're using them on `String` instances that are constant at compile time, the calls to these functions will be optimized away during compilation.

> Check this by decompiling the previous examples!

## Files

Let's move on to dealing with files, through the [`java.io.File`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html) class. Kotlin doesn't replace or map this class to another, but it augments it in many ways.

### Browsing files

The first functions we'll look at help us find the files that we want to work on. The `File` class represents both files and directories in the file system. Given a `File` that points to a directory, we can start a *walk* on the file tree from that node:

```kotlin
val walk: FileTreeWalk = file.walk()
```

A [`FileTreeWalk`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/-file-tree-walk/index.html) is actually a `Sequence<File>` (with some cool extra options), which will recursively enumerate all files (and directories) under the given directory.

This is a powerful API, since we can use any `Sequence` operations on this walk. For example, we can print the names of all files that have `IMG` in their name and have the `jpg` extension, in any subdirectory of the current one:

```kotlin
walk.filter { it.isFile }
        .filter { it.nameWithoutExtension.contains("IMG") }
        .filter { it.extension.equals("jpg", ignoreCase = true) }
        .forEach { file ->
            println(file.name)
        }
```

> [`nameWithoutExtension`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/name-without-extension.html) and [`extension`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/extension.html) are both *extensions* (pardon the pun) on the `File` class. You can also see a handy overload of [`String#equals`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/equals.html) at work here, allowing you to ignore case differences for the comparison.

### Reading and writing files

For read/write operations on a single file, let's start with an example in Java style, which reads lines from a file, and collects them into a `List<String>` (this example omits exception handling):

```kotlin
val file = File("filename")
val lines = mutableListOf<String>()
val reader = BufferedReader(FileReader(file))
var line: String? = reader.readLine()
while (line != null) {
    lines.add(line)
    line = reader.readLine()
}
reader.close()
```

Kotlin makes opening a file for reading or writing very simple with extensions. You can use these to open a stream for a file, or to access even higher level APIs, such as various readers and writers.

```kotlin
file.inputStream() // FileInputStream
file.outputStream() // FileOutputStream

file.reader() // InputStreamReader
file.bufferedReader() // BufferedReader

file.writer() // OutputStreamWriter
file.bufferedWriter() // BufferedWriter
file.printWriter() // PrintWriter
```

If you use these APIs, it's your responsibility to free these resources when you're done using them. Remember that you have the `use` function in the Standard Library that can do this for you safely. This function returns whatever the lambda passed to it returns, and closes the opened resource:

```kotlin
val lines = file.bufferedReader().use { reader ->
    val lines = mutableListOf<String>()
    var line: String? = reader.readLine()
    while (line != null) {
        lines.add(line)
        line = reader.readLine()
    }   
    lines
}
```

To simplify this snippet, you can also use [`forEachLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/for-each-line.html), which runs a given action for each line in a file:

```kotlin
val lines = mutableListOf<String>()
file.forEachLine { lines.add(it) }
```

This function will open a `BufferedReader` on the given file, read its contents - performing your actions for each line - and then safely close the reader.

And then there's also an even simpler way...

```kotlin
val lines: List<String> = file.readLines()
```

Creating a list of `String` instances in memory for an entire file may be a costly operation if your file contains a large amount of data. If you don't need all of its contents to be loaded in memory at once (for example, if you can process them all individually, just on their own), you can use a lazy `Sequence` instead, with the help of [`useLines`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/use-lines.html).

Here's an example of calculating the average length of a line, using the `Sequence` API. This will pull in the lines of the file one by one during the processing, instead of all at once.

```kotlin
val avg: Double = file.useLines { lines: Sequence<String> ->
    lines.map { it.length }.average()
}
```

If you want to operate simply on the entire text content of a file, the Standard Library also has you covered: the [`readText`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/read-text.html) extension will give you the entire contents of the file as a single `String`, and the [`writeText`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/write-text.html) extension can be used to set a file's content to a `String`. Again, these wrap various operations with file streams.

## The crimes of the Windy City

To put our knowledge of file handling, string manipulation, and collection processing to the test, we'll perform some simple analysis on [freely available crime statistics from Chicago](https://data.world/publicsafety/chicago-crime).

The data set consists of three files, containing the stats from the years 2014, 2015, and 2016. The files are [CSVs](https://en.wikipedia.org/wiki/Comma-separated_values), and they contain data like this:

```
id,case_number,date,block,iucr,primary_type,description,location_description,arrest,domestic,beat,district,ward,community_area,fbi_code,latitude,longitude,location
9446824,HX100141,2014-01-01T02:00:00,0000X W ILLINOIS ST,0460,BATTERY,SIMPLE,STREET,false,false,1831,18,42,8,08B,41.890828047,-87.630234746,POINT(-87.630234746 41.890828047)
9446748,HX100020,2014-01-01T00:00:00,006XX N DEARBORN ST,0890,THEFT,FROM BUILDING,BAR OR TAVERN,false,false,1832,18,42,8,06,41.893541578,-87.629701805,POINT(-87.629701805 41.893541578)
9446758,HX100030,2014-01-01T00:30:00,052XX W RACE AVE,1310,CRIMINAL DAMAGE,TO PROPERTY,APARTMENT,false,false,1523,15,28,25,14,41.890046233,-87.756333158,POINT(-87.756333158 41.890046233)
9446760,HX100027,2014-01-01T00:30:00,053XX W WELLINGTON AVE,0460,BATTERY,SIMPLE,APARTMENT,true,false,2514,25,31,19,08B,41.935011125,-87.759739272,POINT(-87.759739272 41.935011125)
```

To get started, we'll need to get references to all of these files. Assuming that they're in a `data` folder, we can get a `List<File>` containing each file like this:

```kotlin
val years = listOf("2014", "2015", "2016")
val filenames = years.map { year -> "data/chicago_crime_$year.csv" }
val files = filenames.map { name -> File(name) }
```

Of course, we can use chained calls instead of declaring a new variable each time:

```kotlin
val files: List<File> = listOf("2014", "2015", "2016")
        .map { year -> "data/chicago_crime_$year.csv" }
        .map { name -> File(name) }
```

We'll perform all of our analysis in-memory for simplicity, however, refactoring this code to use the `Sequence` file APIs instead would greatly improve its performance.

> Consider doing this for practice!

We'll fetch all lines of each file, drop the first line containing the column names, and then collect all these lines into a single `List`. `flatMap` is the perfect operator to use here, as we want to map each file to many lines:

```kotlin
val allLines: List<String> = files.flatMap { file ->
    file.readLines().drop(1)
}
```

Our data is hard to reason about when it's in a single `String` for each record. We'll create instances of a class from each line instead:

```kotlin
val crimes: List<Crime> = allLines.map { Crime(it.split(",")) }
```

> Splitting a line in a CSV file on the `,` character is a very common practice, but it is incorrect. A single field in a CSV file may contain commas if it's surrounded by quotation marks (e.g. `"SCHOOL, PUBLIC, BUILDING"`), and the naive split on the `,` character parses such fields incorrectly. We're going to sweep this under the rug here by simply ignoring it, as correctly parsing a CSV file would be too tedious. As a result, we'll have *some* incorrect data after parsing, but this won't affect our results too much.

Let's create the `Crime` class, which will have fields that each correspond to a given column of the input data:

```kotlin
class Crime(data: List<String>) {
    val id: String = data[0]
    val caseNumber: String = data[1]
    val date: LocalDateTime = data[2].toLocalDateTime()
    val block: String = data[3]
    val type: String = data[5]
    val description: String = data[6]
    val locationDescription: String = data[7]
    val arrest: Boolean = data[8].toBoolean()
    val domestic: Boolean = data[9].toBoolean()
    val latitude: Double? = data[16].toDoubleOrNull()
    val longitude: Double? = data[17].toDoubleOrNull()
}
```

This class takes the `List<String>` produced by splitting the line, and then converts the `String` representing each field to a more concrete data type, using Standard Library functions.

The only conversion not provided to us is the Standard Library is the `toLocalDateTime` function. We'll implement this ourselves. Dates in our data are in the ISO 8601 local date-time format, for example: `2014-01-18T15:52:00`. We can easily obtain each of these number values with the following `String` operations:

```kotlin
private fun String.toLocalDateTime(): LocalDateTime {
    val date = this.substringBefore('T').split('-').map { it.toInt() }
    val time = this.substringAfter('T').split(':').map { it.toInt() }

    return LocalDateTime.of(date[0], date[1], date[1], time[0], time[1], time[2])
}
```

This code works, but the hardcoded indices for the various components of the date and time are hard to read and error-prone. *Did you notice the mistake in the code above?*

We can make our code much more legible by using *destructuring declarations* again. We've seen that we can do this for data classes - the good news is that the `List` type also supports it (more details on this in the very [next chapter](./8.md#destructuring)). When destructuring a `List`, we can grab the first N elements of it, up to five of them. This cleans up our code like this:

```kotlin
private fun String.toLocalDateTime(): LocalDateTime {
    val (year, month, day) = this.substringBefore('T').split('-').map(String::toInt)
    val (hour, minute, second) = this.substringAfter('T').split(':').map(String::toInt)

    return LocalDateTime.of(year, month, day, hour, minute, second)
}
```

While that was fun to perform on our own, `LocalDateTime` actually contains parsing functionality that we can rely on instead of having to write it ourselves:

```kotlin
private inline fun String.toLocalDateTime() = LocalDateTime.parse(this)
```

With that, we have a `List<Crime>` to work with. Let's answer some questions.

#### How many crimes do we have data about in total?

This is simple enough, we just need the size of the list!

```kotlin
println("# of crimes: ${crimes.size}") // # of crimes: 754541
```

#### What percentage of reports resulted in an arrest?

This information is in the `Boolean` property called `arrest`. We simply need to count the number of arrests made, and divide with the total number of crimes. We'll use [`count`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/count.html) for this:

```kotlin
val ratio: Double = crimes.count { it.arrest }.toDouble() / crimes.size
println("Arrest percentage: ${ratio * 100}%") // Arrest percentage: 24.438565962618334%
```

> Notice how we've converted the count to a `Double` value before dividing it. Otherwise, we'd have performed integer division, and most likely ended up with a `0` value.

Another interesting (though quite inefficient) way of calculating this ratio would've been to map each `Boolean` value to either `0` or `1`, and then average those values:

```kotlin
val ratio = crimes.map { if (it.arrest) 1 else 0 }.average()
```

#### How many cannabis-related arrests happened between 1 AM and 6 AM, on the CTA?

> CTA stands for [the Chicago Transit Authority](https://www.transitchicago.com/).

This is a job for the `filter` operation, as each condition we have can be described with an appropriate filter:

```kotlin
val result = crimes
        .filter { it.arrest }
        .filter { it.date.hour in 1..5 }
        .filter { it.locationDescription.contains("cta", ignoreCase = true) }
        .filter { it.description.contains("cannabis", ignoreCase = true) }
        .count()
println("CTA cannabis arrests at night $result")
```

Having this many filters doesn't look very efficient. What can we do to optimize this?

- First, we could consider which ones are likely to exclude a lot of elements, and run those filters first. If the first steps get rid of *most* records, the rest of the steps have to inspect a lot fewer of them. We might also want to pull expensive filters (for example, our `String` search operations) to later down the line, and let the quicker filters run first (notice that we've already done this!).
- Using a single `filter` with all the conditions joined together by `&&` operators would iterate our original `List` just once, and only create a single new `List` that contains the elements that made it through. The original code iterates the current `List` and creates an intermediate `List` in each `filter`.
- If we want to keep the structure of separate filters for each condition, using the `Sequence` API might be a good idea here. All we have to do is add an `asSequence` call at the top of the chain.

Do these actually improve our performance? Here are some *very* unscientific measurements of these approaches, on just one machine:

```
Original code
17.998 ms

Merged filter operations
21.679 ms

Converted to a Sequence
39.575 ms

Filters in the wrong order, String operations first
144.898 ms
```

These results might be surprising, as the proposed improvements probably sounded great in theory. The lesson to learn here: always benchmark code that you want to optimize for performance, with real amounts of data. Don't use measurements such as `System.currentTimeMillis()` either, use real benchmarking tools instead. Here's [an article](https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html) and [a tutorial](https://www.baeldung.com/java-microbenchmark-harness) that can help you get started with benchmarking on the JVM. If you're running code on Android, take a look [at this documentation](https://developer.android.com/studio/profile/benchmark).

> Note that we didn't inspect or compare the memory usage of each approach, which would probably also show significant differences.

#### What are the most common types of crimes?

We have a property called `type`, which contains values such as `NARCOTICS`, `BATTERY`, or `WEAPONS VIOLATION`. One of the frequently used collection functions in Kotlin is [`groupingBy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/grouping-by.html), which lets us group our elements by some key. To group our crimes by their type, we can do the following:

```kotlin
val grouping: Grouping<Crime, String> = crimes.groupingBy { it.type }
```

A grouping is very similar to a `Map`, but like a `Sequence`, creating it doesn't trigger any processing yet. We need to call a further terminating method on it. One of these is [`eachCount`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/each-count.html), which is exactly what we need:

```kotlin
val counts: Map<String, Int> = crimes
        .groupingBy { it.type }
        .eachCount()
println(counts)
```

Printing the `Map` we have here will give us an output formatted like this. Readable, but not pretty:

```
{BATTERY=140287, THEFT=168404, CRIMINAL DAMAGE=82038, WEAPONS VIOLATION=9302, ...}
```

To improve this, here are some operations we can perform on the `Map`:

```kotlin
crimes.groupingBy { it.type }
        .eachCount()
        .mapKeys { it.key.lowercase().replaceFirstChar(Char::uppercase) } // 1
        .toList() // 2
        .sortedByDescending { (type, count) -> count } // 3
        .take(3) // 4
        .forEach { (type, count) -> // 5
            println("$type: $count")
        }
```

1. We modify the `Map`'s keys so that only their first letter capitalized. This "map" operation doesn't change the values in the `Map` entries, it just replaces each of their keys.
2. We convert our `Map<String, Int>` to a `List<Pair<String, Int>>`. Each `Pair` in the `List` will correspond to a key-value pair (an entry) from the `Map`.
3. We sort the `List` so that it starts with the types of crimes that have the largest `count` values. We use another form of destructuring here: we are declaring two variables local to the lambda's scope, which will be initialized by destructuring the `Pair<String, Int>` that it receives as a parameter.
4. We take the first 3 entries of the `List`.
5. Again, we use destructuring to create variables from the `Pair<String, Int>` that we receive as the parameter of this lambda.

> A `List` is easier to follow than a `Sequence`, but a `Sequence` would have probably been a good choice here, due to the many steps and large amount of data. Try replacing `toList` with an `asSequence` call!

This will give us the following, nicely formatted output:

```
Theft: 168404
Battery: 140287
Criminal damage: 82038
```

#### What time of the day are these crimes committed?

This, again, will be a job for `groupingBy`. After creating our grouping, we'll use [`toSortedMap`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/to-sorted-map.html) to make sure that our values are ordered by their keys (the hour), and then iterate over them.

```kotlin
crimes.groupingBy { it.date.hour }
        .eachCount()
        .toSortedMap()
        .forEach { (hour, count) ->
            val hourString = String.format("%2dh", hour)
            val percentage = (count.toDouble() / crimes.size * 100).toInt()
            println("$hourString ${"X".repeat(percentage)}")
        }
```

Inside the `forEach` call, we format the hour value, and calculate what percentage of crimes each hour contained. To visualize this primitively, we draw a barchart of sorts from `X` characters, using the [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/repeat.html) extension:

```
 0h XXXX
 1h XX
 2h XX
 3h XX
 4h X
 5h X
 6h X
 7h XX
 8h XXX
 9h XXXX
 ...
```

## Summary

The Kotlin Standard Library contains hundreds of useful functions that make everyday tasks quicker and easier. Whether it's providing clear requirements, manipulating strings, or accessing files, the Standard Library's got you covered.

> It's worth browsing through the implementations of these functions, as they demonstrate excellent use of Kotlin's language features, as well as great API design.

Combining these quick-to-use extensions, Kotlin can be put to work as a scripting language of sorts - whether or not it's being used with its scripting environment.

## Sources

- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Effective Kotlin - Marcin Moskala](https://leanpub.com/effectivekotlin)
  - A collection of Kotlin best practices.
- Official documentation:
  - [The `kotlin.text` package](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/index.html)
  - [The `kotlin.io` package](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/index.html)

# Chapter 1: Introduction

Programming languages. There's a lot of them, and it could be argued that all of them have their uses, their pros and cons.

There are things however that are generally considered positive attributes for languages, and many modern languages are converging in terms of these attributes. During this course, we'll be studying Kotlin, which is a great example of a modern, well-rounded language, but you'll see many similar features and ideas in other languages such as Swift, C#, or Groovy, just to name a few examples.

Why should you start using Kotlin specifically, out of all these languages? Its creators often say that they don't really want to push Kotlin on anyone, they want it to speak for itself. It's a pragmatic language, which they believe solves real problems. Try it, see if it solves problems that you're facing in other languages, and if that's valuable for you. And there really is no substitute for seeing what it's like to use in practice.

The creators also proudly admit that almost none of the features in Kotlin have been invented from scratch. We all stand on the shoulders of giants, there's nothing new under the sun, and [everything is a remix](https://www.youtube.com/watch?v=nJPERZDfyWc). Great creations always take existing pieces of work, and then copy, transform, and combine them into something new. Creating a language is no different from your everyday coding in this regard.

> The original lead language designer for Kotlin, Andrey Breslav gave an [excellent talk](https://www.youtube.com/watch?v=7z_K-hTTeqI) on this in May 2022. Best watched once you're already familiar with Kotlin.

What does make Kotlin unique is how well its features fit together, and what features were omitted on purpose, because they would have broken the language's consistency, or go against its core tenets.

So what are some of these desired attributes that Kotlin aims to achieve?

- **Conciseness**, i.e. less code for expressing the same ideas. Not for the sake of conciseness itself, but to improve **readability** compared to more verbose languages. Not having to write [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code) makes coding faster, and more importantly, not having that boilerplate in your codebase makes navigating and reading your existing code a lot easier.
- **Safety** means that your program misbehaves as little as possible. There's various ways to achieve such safety at the language level. Kotlin does this by having a *strong, static type system*, which reveals most mistakes at compile time (at edit time, really, in almost all cases), rather than letting your code fail at runtime.
- **Interoperability** is another driving principle of Kotlin. It runs on multiple platforms, and on each of them it cooperates with the native environment and libraries as much as possible. We'll look specifically at how it interops with Java when running it on the JVM.
- **Pragmatism** is a way of saying that Kotlin is not an academic language. It's meant for use in real industrial settings, and to solve real, practical problems.
- **Tooling** is something you might overlook at first when evaluating languages, but it's something that can make a good language a true pleasure to use. While there are still proud Vim warriors out there, most developers are used to using rich IDEs for their coding needs, and Kotlin's tooling is as first-party as it gets.

This brings us to Kotlin's origin story.

## History

[JetBrains](https://www.jetbrains.com/), the company behind the IntelliJ platform (and [all the IDEs that are built on it](https://www.jetbrains.com/products/#type=ide-vs), such as IntelliJ IDEA, Android Studio, CLion, PyCharm, and so on) has been developing their products in Java for a decade by 2010. During this time, they've built up immense experience in creating tooling for programming languages, and they also got very familiar with Java's pros and cons.

It was at this time that they started looking for a new language for their own development needs that was better than Java. They've evaluated the existing languages that ran on the Java Virtual Machine (JVM), but they didn't find one at the time that would've satisfied their needs.

>The closest candidate at the time was Scala, but it was notoriously difficult to make tooling for, and it suffered from lengthy compilation times.
 
So they've done what anyone else would've done at this point - created their own.

This, in general, is not a great idea - it's akin to writing your own date library or rolling your own crypto. But with the tooling and language expertise of JetBrains, as well as their strong market position, they've deemed it a viable project, and got started on it.

Some highlights of the language's development:

- 2010: internal development started under the name "JetLang".
- July 2011: [announced to the public](https://blog.jetbrains.com/kotlin/2011/07/hello-world-2/) as Project Kotlin.
- February 2016: [Kotlin 1.0](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), the first stable release.
- March 2017: [version 1.1](https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/), the first major feature update to Kotlin, with initial JavaScript support.
- May 2017: first-class Android support for Kotlin announced at Google I/O.
- November 2017: [version 1.2](https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/), with the first version of multiplatform projects.
- October 2018: [version 1.3](https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/), containing stable coroutines.
- May 2019: Android development going [Kotlin-first](https://developer.android.com/kotlin/first) announced at Google I/O.
- August 2020: [version 1.4](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/), introducing the foundations for a new compiler, and some neat new language features.
- May 2021: [version 1.5](https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/), stabilizing inline classes, adding improvements to sealed types, and stabilizing the new JVM compiler backend.
- November 2021: [version 1.6](https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/), with a preview of the new Kotlin/Native memory model, exhaustive when statements, type inference improvements, and lots of new stable Standard Library APIs.
- June 2022: [version 1.7](https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/), with the new K2 compiler available in alpha, , and yet again many new stabilized language features.  

> Watch [Ten Years of Kotlin: The Story of The Programming Language](https://www.youtube.com/watch?v=uE-1oF9PyiY), a documentary about the language made for its 10-year anniversary.

> Read the blog post from Google [celebrating 5 years of Kotlin on Android](https://android-developers.googleblog.com/2022/08/celebrating-5-years-of-kotlin-on-android.html).

Let's take a moment to review some of the previously mentioned language attributes, with this history now in mind:

- **Interoperability**: JetBrains had hundreds of thousands of lines of Java code in IntelliJ that they could never just throw away. The new code written in Kotlin and the old code written in Java had to be able to communicate efficiently and effortlessly.
- **Pragmatism**: The language was born to serve a specific need, a real industrial project.
- **Tooling**: Language and tooling could be developed side-by-side, in-house, and complement each other perfectly.

Who's using the language? A very rapidly rising number of developers - millions, by now (see [2018 stats](https://youtu.be/PsaFVLr8t4E?t=366), [2020 stats](https://youtu.be/pD58Dw17CLk?t=200)). [(About 6 million as of August 2020.)](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/#compiler-and-ecosystem) 

What are they using the language for? A lot of the focus is on Android development, but Kotlin has a lot of traction outside of mobile too. You can take a look at the [Kotlin Census (2020)](https://www.jetbrains.com/lp/kotlin-census-2020/) or the [State of Developer Ecosystem survey (2021)](https://www.jetbrains.com/lp/devecosystem-2021/kotlin/) ran by JetBrains for some official statistics.

Kotlin is an open-source language. Everything around it - the compiler, the standard library, docs, and so on - are available [on GitHub](https://github.com/jetbrains/kotlin). JetBrains isn't the sole owner and controller of the language, its development is governed by the [Kotlin Foundation](https://kotlinlang.org/foundation/kotlin-foundation.html), co-founded by JetBrains and Google.

Being an open source project, it's rare that surprise product announcements for Kotlin appear, as everything is developed out in the open in the first place. You can take a look at what's planned to be coming up for Kotlin in the next few months (or years) on the [Kotlin roadmap](https://kotlinlang.org/roadmap.html).

## Compilation

Kotlin now positions itself as a modern, multiplatform [application programming language](https://medium.com/@elizarov/application-programming-language-ff7f0063c16). Its original and primary target is the JVM, but Kotlin code can also be compiled to [JavaScript](https://kotlinlang.org/docs/js-overview.html), and even [native](https://kotlinlang.org/docs/native-overview.html) binaries.

In this course, we'll focus on using Kotlin on the JVM. When compiling `.kt` Kotlin sources, the output here is *bytecode* in the form of `.class` files - the same as when compiling Java code.

![Compiling Java or Kotlin to bytecode.](./images/1_kotlin_and_java_basic_compilation.png)

What makes this compilation interesting is the strong interoperability between Kotlin and Java. Code written in one language can call into the other one completely seamlessly. So how can this work out during compilation, if we need to compile Java and Kotlin with their respective compilers? How would the Java compiler know about declarations in Kotlin sources, and vice versa?

Here's how the compilation actually works ([credits to Jake Wharton](https://youtu.be/CtZL_IjR5Ww?t=378)):

![Compiling Java and Kotlin, interop details](./images/1_kotlin_and_java_interop_compilation.png)

The Kotlin compiler, `kotlinc` runs first, and it parses both Java and Kotlin sources. This allows it to compile Kotlin code that references declarations in the Java sources. Next, the Java compiler `javac` is invoked. This again parses the Java sources, plus it receives the output of the Kotlin compiler as already compiled bytecode, which is what allows Java sources to reference Kotlin declarations. Finally, the merged output of these two compilers is bytecode in `.class` files.

## Tooling and environment

Unsurprisingly, JetBrains works very hard to provide the best possible tooling for Kotlin. After all, this is their business angle with the language: building products with it, and selling the tooling for it.

Therefore, [IntelliJ IDEA](https://www.jetbrains.com/idea/) is the definitive IDE for Kotlin development, although other editors support it as well. You can also download the Kotlin compiler and [compile it from the command line](https://kotlinlang.org/docs/command-line.html), if that's your thing.

> [Android Studio](https://developer.android.com/studio) is based on IntelliJ IDEA and offers the same support for Kotlin (although new features from IDEA take a while to trickle down to Studio releases).

Most non-trivial JVM projects use build tools instead of invoking the compiler directly. Kotlin supports both [Maven](https://kotlinlang.org/docs/maven.html) and [Gradle](https://kotlinlang.org/docs/gradle.html), which are the popular build tools in the JVM world. Gradle, which also happens to be the de-facto build system for Android projects, is generally preferred.

> You can even write your Gradle build scripts [in Kotlin](https://docs.gradle.org/current/userguide/kotlin_dsl.html).

IntelliJ has a suite of convenient tools built-in for working with Kotlin. Let's take a quick look at each of these before we get to the code.

### Scratch files

[Scratch files](https://www.jetbrains.com/help/idea/scratches.html) are temporary files that you can use to quickly write and run Kotlin code. They are not associated with any project, and they reside outside your project directory, so they won't be under version control, but only stored locally.

![A simple Kotlin scratch file](./images/1_scratch_file.png)

Despite this, you can reference code in your current project from a scratch file, if you need to. You can create instances of classes, call existing functions, and so on. This makes it really, really easy to perform quick experiments.

To create a scratch file, go to *File -> New -> Scratch File*.

### REPL

Read-Eval-Print Loops, or REPLs, are usually a tool for scripting languages. They allow you to write and execute code line by line, to quickly iterate and try out various things in the language. 

Kotlin comes with this tool as well, which you can either run from the command line, or right inside IntelliJ IDEA (*Tools -> Kotlin -> Kotlin REPL*). Just like with scratch files, you can call into code in your currently open project from the REPL.

![The Kotlin REPL](./images/1_repl.png)

### Decompiler

Sometimes the easiest way to understand what a certain piece of Kotlin code does is to look at what it compiles to. The bytecode that the compiler will output for a given Kotlin source file can be viewed by going to *Tools -> Kotlin -> Show Kotlin Bytecode*.

![The Kotlin bytecode viewer](./images/1_bytecode_viewer.png)

While this can help you figure out what's happening in some cases, most people can't read bytecode very well (nor should they be required to), so there's an even more important feature here. You can decompile this bytecode to Java by choosing the *Decompile* option on the bytecode viewer panel.

![Decompiled Kotlin bytecode](./images/1_decompiled.png)

This gives you a Java source file, which is an attempt at writing Java code that would result in the same compilation result. Keep in mind that this is a best effort step, and not all the bytecode that the Kotlin compiler produces can be represented by Java code in a straightforward way. Most of the time, this decompiled Java code will contain at least a few errors. Still, the decompiler is a very useful tool for gaining a deeper understanding of Kotlin.

### Java-to-Kotlin converter

The Kotlin plugin IntelliJ IDEA also ships with a feature that lets you go the other way around: take existing Java code, and automatically convert it to Kotlin. This comes in really handy when migrating a project to Kotlin. 

![Example of Java-to-Kotlin conversion](./images/1_java_to_kotlin.png)

> You'll find this action under  *Code -> Convert Java File to Kotlin File* when you have a Java file open.

Keep in mind that just like the decompiler, this isn't a perfect tool either. Occasionally the converted Kotlin code won't compile straight away, or it will have some bugs in it. Often it might be messy, Java-like, and require some cleanup to make it more _idiomatic_ Kotlin. But it's usually a good start.

The best use of this feature is perhaps for learning purposes. If you don't know how to express something in Kotlin, but you can write it down in Java, you can always run it through the converter! Again, this might not give you the best possible Kotlin solution, but it'll at least give you one.

> Bonus: pasting Java code into a `.kt` file will also prompt you about converting that code into Kotlin while the paste operation is happening.

## Basic syntax

### Variables

Let's take the first thing you'd want to do in a language, and declare a variable!

>Note: In the beginning, we'll look at the Java equivalents of the Kotlin code in case you need them for reference. Remember, Kotlin *does not* actually compile to Java!

```kotlin
var x: Int = 0              // int x = 0;
```

Let's take note of a couple things:
- You declare variables with the `var` keyword.
- The variable name *precedes* the type.
- Semicolons are... allowed, but optional (in practice, this means that you won't use them).

You should only use `var` when you explicitly want a *mutable* **var**iable.

If that's not the case, use `val` instead, which declares an *immutable* **val**ue.

```kotlin
val y: Int = 1              // final int y = 1;
```

That's better. When declaring variables, `val` should be your default choice.

We can make another improvement to this declaration, by making use of *type inference*.

```kotlin
val z = 2                   // final int z = 2;
```

Kotlin is statically typed and has a very strong, strict type system. This variable is still has a type of `Int` just like before, but you can omit the type from your code, as the compiler can *infer* it itself from context (in this case, from the value being assigned). You'll see a lot of this happening in Kotlin code.

This mechanism means you'll never type out something as verbose as this again:

```java
final FileInputStream fis = new FileInputStream("filename");
```

Instead, you'll have the Kotlin compiler figure out the type for you in almost all cases:

```kotlin
val fis = FileInputStream("filename")
```

> Note: You may also notice here that there's no `new` keyword in Kotlin for constructor calls.

The simple number literal we had before was inferred to be an `Int`, but you can also use special formats to create other basic numerical types:

```kotlin
val myLong = 1L             // final long myLong = 1;
val myFloat = 1f            // final float myFloat = 1;
val myDouble = 1.0          // final double myDouble = 1;
```

#### Primitives vs boxed types

Java - and the JVM itself - makes a distinction between primitive types and boxed types. Primitives (`int`, `double`, `boolean`, and so on) are much more efficient, as they live on the stack, and only take up the space required to represent them.

The corresponding boxed classes (`Integer`, `Double`, `Boolean`, and more) are reference types, so only references to them are stored on the stack, and their actual instances live on the heap. These instances are also larger than the primitive's size, [sometimes significantly](https://dzone.com/articles/whats-wrong-with-java-boxed-numbers).

Using the primitives is sufficient in most cases, but sometimes the boxed variants are still required. This can happen when you *need* an object for some reason, for example when dealing with generics (there's no `List<int>` in Java!). The boxed instances also have various methods you can call on them, which you can't do with a primitive value.

So where does Kotlin's `Int` (and `Boolean`, and `Double`, and other numeric types) fit in this picture? Well, just like `Int` is sort of between `int` and `Integer` by its looks, its semantics lie somewhere in the middle as well. On the Kotlin language level, we don't make a distinction about primitives and boxed types. The compiler will use a primitive whenever it's possible, and use a boxed type automatically when it needs to.

This doesn't exactly mean that we *never* have to think about this problem, because the performance considerations of what happens under the hood are still important in some cases - but we won't use different types to represent these things in our code.

#### Strings

The last basic type that's worth mentioning here is `String`, which behaves much like a `String` in Java. A literal is declared with quotation marks:

```kotlin
val name = "Sarah"           // final String name = "Sarah";
```

Kotlin also supports *string templates*, which is an easy way to place values inside a `String`, without having to use lots of concatenation:

```kotlin
val sum = "$x + $y + $z = ${x + y + z}"     // outputs "0 + 1 + 2 = 3"
```

Single values can be inserted with just a `$` prefix, and expressions can be computed using additional curly braces `${...}`.

### Functions

#### Our first function

Let's move on to functions, something we'll discuss *a lot* in Kotlin. First, we'll convert this very simple function - which just adds two numbers together, and returns the result - to Kotlin.

```java
int add(int x, int y) {
    return x + y;
}
```

Here's a Kotlin equivalent of this code:

```kotlin
fun add(x: Int, y: Int): Int {
    return x + y
}
```

Some important observations about the syntax:

- We use the `fun` keyword to declare a function. (Yay! 🎉)
- The names precede the types in the parameter list, just like we've seen with variables.
- The return type comes after the rest of the function header as well, following the `name: Type` structure yet again.

For functions as simple as this one, that only evaluate a single expression and return its value, Kotlin offers a shorthand syntax called an *expression body*:

```kotlin
fun add(x: Int, y: Int): Int = x + y
```

Type inference can also be used here, since the type of the `x + y` expression, an addition of two `Int` values is known by the compiler to be an  `Int`:

```kotlin
fun add(x: Int, y: Int) = x + y
```

This function still returns `Int`, but we aren't stating this explicitly.

> Use expression bodies with care, only when the function's implementation is truly a simple one-liner. Otherwise, don't be afraid of using a traditional function body.

#### Functions that don't return anything

There's another case where the return type can be omitted, this is when the function doesn't return anything. This is equivalent to a function having a `void` return type in Java.

```kotlin
fun noReturnValue() {
    /* Empty */
}
```

Technically, functions like this still do return *something* in Kotlin. The language doesn't have the super special case that Java has with `void` functions. Functions where you don't return a meaningful value - like the one above - will implicitly have a return type of `Unit`. You can also write this out explicitly, although the IDE will warn you that it's unnecessary.

```kotlin
fun noReturnValue(): Unit {
    /* Empty */
}
```

`Unit` is an empty class that has a single instance. It's a dummy object with no properties or methods. This makes it perfect for representing "no meaningful value". Returning this from methods like the one above yields some... interesting possibilities. For example, you can assign the return value of this function to a variable, just like you could with any other function that returns any regular type.

```kotlin
val result: Unit = noReturnValue()
println(result) // kotlin.Unit
```

Again, there's no hard distinction between functions that do return something, and functions that don't. If there's nothing to return, we're indicating that by returning `Unit` implicitly (both the declaration of the return type and the actual `return` statement at the end of the function may be implicit).

We'll see that this type also plays well with generics. We won't need the weird distinction that Java makes between `void` and `Void`, we'll just use `Unit` for everything. But we're getting ahead of ourselves. Spoilers!

#### Default and named parameter values

Functions come with some neat new features in Kotlin compared to Java functions. One of these is [*default arguments*](https://kotlinlang.org/docs/functions.html#default-arguments).

> *Arguments* are the concrete values passed in for the *parameters* that a function declares. However, the words "argument" and "parameter" are often used interchangeably.

To demonstrate, let's write a function that mimics the registration of a user.

```kotlin
fun register( 
    username: String, 
    password: String = "12345678", 
    email: String = "",
) {
  // Pretend that there's something useful here.
  println("$username $password $email")
}
```

This function takes three parameters, and it defines default argument values for the last two. Note the formatting of each parameter on a separate line, this is conventional in Kotlin for functions with long signatures.

> Since Kotlin 1.4, Kotlin allows [trailing commas](https://kotlinlang.org/docs/reference/whatsnew14.html#trailing-comma) in places like parameter lists. You might have noticed this in the previous snippet. This makes it easier to rearrange lines (even in simple text editors), and also makes version control history neater.

Having these default arguments in place means that we can call this method with three, two, or just one argument. For any parameters that are not provided, the default value will be used instead.

```kotlin
register("piglet", "0h_d34r", "piglet@hundred-acre-wood.co.uk")
register("owl", "tea_party")
register("eeyore")
```

Another feature that works nicely in conjunction with default values is [*named arguments*](https://kotlinlang.org/docs/functions.html#named-arguments). For any function defined in Kotlin, you can optionally specify the names of the arguments when you call the function. Our previous calls could be made like this (note the formatting of the lengthy call, on multiple lines):

```kotlin
register(
    username = "piglet",
    password = "0h_d34r",
    email = "piglet@hundred-acre-wood.co.uk"
)
register(username = "owl", password = "tea_party")
register(username = "eeyore")
```

Naming arguments - especially in cases like this where several of the same type are being passed in - can help us avoid mixing up their order, making the code safer. It also improves readability, as which argument fulfills which parameter is immediately clear at the call site.

Combined with default values, we can also use this to omit arguments that have default values, but are not at the end of the parameter list:

```kotlin
register("tigger", email = "tigger@hundred-acre-wood-co.uk")
```

Here, we're passing in a value for `email`, but opting to use the default value for the `password` parameter.

> By default, Java clients of a Kotlin function with default arguments must provide all arguments, and can't make use of the default arguments. However, you can add the [`@JvmOverloads`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/) annotation to improve interoperability:
>
> ```kotlin
> @JvmOverloads
> fun register( 
>     username: String, 
>     password: String = "12345678", 
>     email: String = "",
> )
> ```
>
> This will generate overloaded methods that are callable by Java clients. For each parameter with a default value (starting from the end of the parameter list), a new method will be generated, which omits that parameter, and uses the default value for it instead.
>
> ```java
> register("kanga");
> register("kanga", "roo");
> register("kanga", "roo", "kanga.and.roo@hundred-acre-wood.co.uk");
> ```
>
> Note how this makes parameter ordering quite important, as parameters can only be omitted from the end of the list. For example, you could not omit just the second `password` parameter when calling from Java. Make sure you're placing your most-defaulted parameters as far back in the parameter list as possible!
>
> We'll take note of similar interop features along the course. There's also a dedicated [documentation page](https://kotlinlang.org/docs/java-to-kotlin-interop.html) covering these.

### Control structures

Let's continue with the basics and get to know our control structures. Most of these will be familiar already, so you'll have no problem getting started with them, but Kotlin does offer some extra capabilities here that are worth knowing about.

#### Conditionals

The classic `if` statement is available in Kotlin just like you'd expect:

```kotlin
if (age < drinkingAge) {
    println("We can't serve you")
} else {
    println("Have a beer")
}
```

It comes with the exciting twist of being not only a statement, but also an *expression*, i.e. it has a return value. This return value is whatever the last expression is in the branch that was executed.

```kotlin
val discount = if (age < adultAge) {
    println("Calculating discount")
    val diff = adultAge - age
    100 - diff * 5
} else {
    println("No discount available")
    0
}
```

If you omit the braces, you get a very concise syntax for these expressions:

```kotlin
val max = if (a > b) a else b
```

For this reason, the so-called ternary operator (`a > b ? a : b`) is not present in the language (see [detailed discussion](https://youtrack.jetbrains.com/issue/KT-5823) and [conclusion with explanation](https://www.youtube.com/watch?v=0FF19HJDqMo&t=1357s)).

#### Switches get ~~stitches~~ improvements

The well-known `switch` statement is an interesting control structure. Many languages (Scala, Swift, or C#, just to mention a few) have taken it beyond its original capabilities by adding *pattern matching* of various kinds to it. Even Java [got some upgrades](https://openjdk.java.net/jeps/361) to its `switch` in Java 14.
  
How does Kotlin measure up? Like in most times when it's compared on a scale from Java to Scala, it's somewhere in the comfortable middle.

Kotlin's replacement for the `switch` is the `when` expression. First of all, it does the things that you expect a regular `switch` to do, with slightly different syntax:

```kotlin
val grade: Int = getGrade()
when (grade) {
    1 -> {
        println("Failed")
    }
    2 -> { println("Adequate") }
    3 -> { println("Average") }
    4 -> { println("Good") }
    5 -> { println("Excellent") }
    else -> {
        /* "This shouldn't happen" */
        throw RuntimeException("Invalid grade!")
    }
}
```

Instead of cases, `when` features branches, which follow whatever value it matched. There is no fall-through between these branches, so there's no need to `break` at their end. Instead of a `default` case, you can use `else` to indicate the branch that should be executed if none of the others have matched.

It also has some more advanced features:

```kotlin
when (val rating = calculateRating()) {
    0 -> {
        println("Terrible")
    }
    1, 2, 3 -> println("Bad")
    in 4..6 -> println("Average")
    in 7 until 10 -> println("Good")
    10 -> println("Perfect")
}
```

In this example, you can see that:

- You can declare the variable that you're performing the check against in the argument of `when` ([since Kotlin 1.3](https://kotlinlang.org/docs/reference/whatsnew13.html#capturing-when-subject-in-a-variable)). This variable will only be accessible within `when`'s body, neatly limiting its scope.
- You can list multiple values that will execute the same branch when one of them matches.
- If your branch is a single expression, you can omit the curly braces.
- You can perform containment-in-`Range` checks.

---

Of course, `when` is an expression too, which means that it can be used to return a value - the last expression of whatever branch was executed. This can reduce code duplication when all branches perform the same action with, for example, a different argument:

```kotlin
val description = when (grade) {
    1 -> "Failed"
    2 -> "Adequate"
    3 -> "Average"
    4 -> "Good"
    5 -> "Excellent"
    else -> {
        // "This shouldn't happen"
        throw RuntimeException("Invalid grade!")
    }
}
println(description)
```

In this case, the `else` block is mandatory, because without it we could run into a scenario where none of the branches were executed, and we have nothing to assign to the variable that the result of `when` is to be stored in.

Exhaustive branches (either all cases covered, or an `else` branch present) are also required in some other cases, such as when the argument to `when` is a `Boolean` value. For example, take the following code:

```kotlin
val enabled = false
when (enabled) {
    true -> println("Enabled!")
}
```

This produces an error:

```
'when' expression must be exhaustive, add necessary 'false' branch or 'else' branch instead
```

The same requirement applies when the argument is an enum value or a sealed class - we'll cover both those features in the [next chapter](2.md).

---

Finally, it's worth noting that `when` can also be used without an argument, as a replacement for a long `if-else if` chain. In this case, each branch has a condition that evaluates to a `Boolean`, and the first one to evaluate to `true` will execute its branch.

```kotlin
when {
    x < 40 -> println("x is too small")
    y in 0..50 -> println("y is in invalid range")
    x % y == 0 -> println("y should divide x")
    !check1(x, y) || !check2(x, y) -> {
        println("x and y didn't pass advanced validation")
    }
}
```

We'll see even more of `when`'s powers later when we get to enums, classes and typechecks.

#### Exceptions

Exceptions in Kotlin are handled using a `try-catch` block (with an optional `finally` clause):

```kotlin
db.open()
db.beginTransaction()
try {
    db.insert(Customer(name = "Ann", balance = 1_000_000))
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
} finally {
    db.close()
}
```

> Note how underscores can be used to break up long number constants and improve readability.

As you might expect at this point, `try-catch` is also an expression, and it returns the last expression in the `try` branch if nothing is thrown from that branch, and the last expression of the `catch` branch otherwise:

```kotlin
val input: String = readUserInput()
val value: Double = try {
    input.toDouble()
} catch(e: NumberFormatException) {
    0.0
}
```

> Note that instead of using [`Double.parseDouble`](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#parseDouble-java.lang.String-) and similar methods, Kotlin offers methods on the `String` type that let you easily convert them to other types, such as [`toDouble`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double.html) or [`toInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html).

One last notable design choice here is that there are *no checked exceptions* in Kotlin. This means that there's no requirement of declaring what exceptions a given function may throw, and you're not forced to handle non-`RuntimeExeptions` by the compiler either.

This choice was made based on the experience that Java's checked exceptions did a lot more to inconvenience developers than to actually improve the safety of code, and often resulted in just empty `try-catch` wrappers around functions that declared exceptions being thrown from them.

> For Java interoperability, you can annotate functions with [`@Throws`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/) to specify what exceptions they can throw, and force Java callers to handle those exceptions.
> 
> ```kotlin
> @Throws(IOException::class)
> fun readScoresFromDisk() { /* Disk reading things */  }
> ```
> 

#### Loops

Last but not least, let's talk about loops. `while` and `do-while` loops have nothing special about them. They check a condition at the beginning or end of the loop respectively, and run until their condition evaluates to `true`.

```kotlin
val entries = ...
while (entries.hasNext()) {
    println("Entry: ${entries.next()}")
}
```

`for` loops, on the other hand, are more interesting. The C-style `for` loop with three parts in its header separated by semicolons is not present in the language. Instead, anything that can provide an `Iterator` can be iterated with `for` loops.

> We'll explore what makes an object compatible with usage in a `for` loop in [later](./8.md#iteration).

For example, here's how you can iterate over a list of numbers, created with the [`listOf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html) factory function:

```kotlin
val myNumbers = listOf(1, 2, 5, 14, 42, 132, 429)
for (number in myNumbers) {
    println(number)
}
```

But what if we just want to iterate on numbers, for example from 0 to 10? It would be very wasteful to create a `List` and fill it up with elements just to get a simple loop. (We'd also be inclined to write the same `for` loop to populate the list with these numbers...)

Here's where the concept of a `Range` comes in. We'll explore these in detail [later](./8.md#custom-ranges), but the basic idea is that the syntax `0..10` creates a `Range` from 0 to 10. This creates a closed range, which includes both its lower and upper bound.

This range can provide an iterator that can be used with a `for` loop:

```kotlin
for (i in 0..10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 10 
```

> It might seem wasteful to create this `Range` object and then an `Iterator` of some kind just to loop through numbers like this. Worry not, this is optimized by the compiler, and we'll inspect what happens under the hood [in a later chapter](./8.md#performance-of-built-in-ranges).

What if we wanted to iterate slightly differently, excluding the upper bound of the range? This is common when we want to iterate valid indexes of a collection, for example. We can create a half-open interval using the `0 until 10` syntax:

```kotlin
for (i in 0 until 10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 
```

Other ways to create ranges include `downTo` which lets you create a descending range, and `step`, which lets you progress in larger increments at a time (this option can be added on to any range):

```kotlin
for (i in 10 downTo 1 step 2) {
    print("$i ")
} // 10 8 6 4 2
```

## Summary

Kotlin is a modern language with a strong, static type system. It aims to achieve readability, safety, and interoperability with all the platforms that it targets. The creators of the language are JetBrains, who also ship all the tooling for the language in IntelliJ IDEA.

Variables are declared with `val` or `var`, functions with `fun`. Types are declared *after* identifiers. Functions come with many conveniences: expression bodies, named and default parameters are a few of the basic ones. Kotlin features most common control structures, and most of them can be used as expressions. `when` is an advanced replacement for a `switch`. `try-catch-finally` works as expected, and there are no checked exceptions. `for` loops work on anything that's iterable, for example on `List` and `Range` objects.

## Sources

- [KotlinConf 2018 - Conference Opening Keynote by Andrey Breslav](https://youtu.be/PsaFVLr8t4E?t=120)
  - Goals of Kotlin, often misunderstood
- [It's a Kotlin, Kotlin, Kotlin World - Jake Wharton - Londroid 2017 @Telegraph Engineering](https://youtu.be/CtZL_IjR5Ww?t=378)
  - Explanation of the interaction between the Java and Kotlin compilers.
- Official documentation
  - [Getting Started with IntelliJ IDEA](https://www.jetbrains.com/help/idea/get-started-with-kotlin.html)
  - [Running Code Snippets](https://kotlinlang.org/docs/run-code-snippets.html)
  - [Using Gradle](https://kotlinlang.org/docs/gradle.html)
  - [Basic Syntax](https://kotlinlang.org/docs/basic-syntax.html)
  - [Basic Types](https://kotlinlang.org/docs/basic-types.html)
  - [Control Flow](https://kotlinlang.org/docs/control-flow.html)
  - [Functions](https://kotlinlang.org/docs/functions.html)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/java-to-kotlin-interop.html)

# Chapter 2: Object-Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object-oriented code. While [Java is clearly and strictly an object-oriented language](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html), the same can not be said for Kotlin. We'll see later on that it supports more than just this one paradigm. For now though, let's see how Kotlin does OOP.

### Classes 101

It only makes sense to start with the simplest possible class:

```kotlin
class Person
```

This is what an empty class looks like in Kotlin. Classes usually have bodies bounded by curly braces `{}`, but these can be omitted if the body of the class is empty - which will happen in Kotlin more than you might think.

Classes have two kinds of constructors - we'll deal with *primary constructors* first. These are declared right in the header of the class, and simply list the parameters you need to construct a class:

```kotlin
class Person(name: String, age: Int)
```

Just adding these parameters doesn't make much sense, we'd at the very least want to store them somewhere, so that we can work with them later. In Java, we'd use fields for this. In Kotlin, we'll use *properties* instead, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable. Similarly to local variables, a `val` is a read-only property, while a `var` is a read-write property.

```kotlin
class Person(name: String, age: Int) {
    val name: String
    var age: Int
}
```

This code won't compile yet, as our properties are not initialized. Therefore, constructing an instance of `Person` wouldn't be safe: what would happen when someone reads the value of `name` or `age`?

There are two ways of initializing this property within the body of the class. It can either be done at its declaration, or inside an *initializer block*, which is executed when the class is constructed:

```kotlin
class Person(name: String, age: Int) {
    val name: String = name
    var age: Int

    init {
        this.age = age
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand syntax for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Person(val name: String, var age: Int)
```

This is used extensively in Kotlin classes.

### Properties

We've seen that properties can be declared either in the primary constructor, or in the body of the class.

Let's take the following example of using the class that we've created:

```kotlin
fun main() {
    val person = Person("Mandy", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - from this syntax, it seems like we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here.

Properties are a higher level concept, which encompass a field, a getter, and a setter (in the case of `var`s) into a single entity. This becomes very apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Mandy", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

The properties that we use in Kotlin are exposed to Java clients as getters and setters, which is the usual way of accessing values stored in a class there. Kotlin tries to blend in to the platform it's targeting and interoperate with it as seamlessly as possible. If you pay attention to some details, client code written in Java will never have to know that it's calling into your Kotlin code.

We can even jump into the Kotlin decompiler and view a decompiled version of the class, which shows us an approximation of what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

While the getters and setters we use here are public, the fields that actually hold the data still remain private. Encapsulation checks out!

> This comparison of one-liner model classes vs the lengthy syntax of Java is often shown off when showcasing the strengths of Kotlin.

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*, the field created behind-the-scenes by the compiler to store a value for the property.

We can change this behaviour by adding a custom getter or setter implementation to the property. To do this, we'll have to move our property from the primary constructor to the body of the class - the primary constructor is only for simple, straightforward properties.

```kotlin
class Person(val name: String, age: Int) {
    var age: Int = age
        get() {
          return field
        }
        set(value) {
          field = value
        }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter. The getter can take no parameter, and the setter takes a single parameter, usually named `value` by convention.

> The compiler marks these implementations as redundant, as we get the same getter/setter by default.

> Be careful not to write down something like `age = value` inside the setter. This would set the value of the *property* instead of the *field*, which would invoke its setter again, resulting in an infinite loop.

We can customize these functions to our liking now. For example, we might want to lie about our age when asked, or make sure that a person never gets any younger than their current age:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
```

> Note the usage of an expression body with the getter, just like with any other function.

Notice how Kotlin's type inference is at work here. The type of the property is not specified anywhere in its now lengthy declaration, instead, it's inferred from the type of the constructor parameter that it's initialized with.

The full syntax of the property with very explicit typing would look like this:

```kotlin
var age: Int = age
    get(): Int = field - 5
    set(value: Int) {
        if (value > field) {
            field = value
        }
    }
```

This contains a lot of unnecessary typing, but specifying the type of at least the property itself on the first line may be a good idea - doing so prevents it from accidentally changing its type if the constructor parameter's type changes.

It's also important to note that even though we're now writing a getter and setter in the implementation of our class, the external usage remains the same as before. We can read and write our property by just referencing its name directly:

```kotlin
val person = Person("Dave", 38)
println(person.age) // 33
person.age = 20
println(person.age) // 33
```

However we implement a property - whether we rely on the default implementation or do it ourselves - they're always encapsulated, and use accessor functions under the hood. This helps us with [maintaining the APIs](https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/) of classes, while allowing them to change their internals in a broad variety of ways.

> Some Java libraries work by reading and writing the values of Java *fields*. These fields often have to be publicly accessible as well. As Kotlin's properties always use private backing fields, these libraries can have trouble operating on Kotlin classes. The solution is using the [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) annotation in these cases, which turns a Kotlin property into a plain Java field.
>
> ```kotlin
> class Person {
>     @JvmField
>     val name: String = "Anonymous"
> }
> ```
>
> Instead of calling a getter for this property, we can now directly access it in Java code:
>
> ```java
> System.out.println(new Person().name);
> ```

##### Property delegation

Custom getters and setters tend to follow the same patterns over and over again. One the most common patterns is *lazy initialization*, computing a value only when it's first needed (saving resources until then), and then storing it for later use (saving resources on subsequent accesses).

Here's an example of a `pi` property which is computed only if it hasn't been accessed yet, and otherwise it returns an already stored when the getter is invoked:

```kotlin
private var _pi: Double? = null
val pi: Double
    get() {
        if (_pi == null) {
            // Some expensive computation
            val sum = (1..50_000).sumOf { 1.0 / it / it }
            _pi = sqrt(sum * 6.0)
        }
        return _pi!!
    }
```

> This property uses another property to store its data instead of its own backing field - a [*backing property*](https://kotlinlang.org/docs/reference/properties.html#backing-properties) - because the types of the property and the data it needs to store are different. This is due to nullability concerns, which will be covered in the next chapter.

> The computation itself also uses some advanced features that we didn't cover yet, but you can attempt to figure out how it works!

If we were to now write code that lazily computes *`e`* ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant))), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, and a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var _e: Double? = null
val e: Double
    get() {
        if (_e == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumOf { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            _e = sum
        }
        return _e!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how this works exactly and how to do it ourselves later down the line, but let's see what delegates the Standard Library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword, and create a lazy property with `lazy {}`:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumOf { 1.0 / it / it }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now gone from our own code, and all we have to focus on is the initialization logic itself! This is placed within the braces `{}` - the last expression in here will be assigned as the value of the property.

It's worth mentioning that `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code whenever the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to ["log"](https://stackoverflow.com/questions/31869391/what-is-the-difference-between-java-logger-and-system-out-println) changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you define for it. Here you have to return a `Boolean` value, which when `false` will prevent the new value from being set. Let's perform the previously used aging validation again, this time using `vetoable`:

```kotlin
var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

> This section has been adapted from a blog post that originally appeared on [zsmb.co](https://zsmb.co/primaries-matter-a-discussion-of-constructors/).

Primary constructors play a fundamental role in Kotlin classes. Let's take a closer look at them, understand what exactly is part of a primary constructor, what makes this constructor special, and what the alternatives are.

##### Back to Java for a moment

In Java, class creation isn't exactly strict. The language lets you leave variables uninitialized without any complaints. Take this class for example:

```java
public class Car {
    String model;
    int year;
    double miles;
}
```

It has three fields, and an implicit constructor with no parameters. When you call its constructor with `new Car()`, all of these fields will be initialized to implicit default values: `null`, `0`, and `0.0`, respectively. In general, primitive types are initialized to some resemblance of `0`, while reference types are initialized to `null`.

##### Kotlin's safety guarantees

In contrast, Kotlin is very strict about creating instances. We've seen that a class like this does not compile in Kotlin, because initializing each property when an instance is created is mandatory.

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double
}
```

> *e: Property must be initialized or be abstract*

*This forces you to explicitly initialize every value in one way or another, and guarantees that your properties won't have implicit values stored in them.* Whenever you read a property, you'll get a value out of it that *you* have put there, intentionally.

##### The primary constructor

We've also seen already that there are two ways to initialize these properties. You can initialize them inline at their declarations, or in one or more initializer (`init`) blocks.

```kotlin
class Car(model: String, year: Int) {
    val model: String = model
    val year: Int
    var miles: Double = 0.0

    init {
        this.year = year
    }
}
```

These two kinds of initializations are performed from top to bottom, in order. In the example, `model` and `miles` would be initialized first, and then finally `year` would get its value. *Any parameters that the primary constructor takes may be used for these initializations*.

Let's simplify by moving both `model` and `year` into the primary constructor. Properties in the primary constructor will be initialized before anything in the body of the class, and again, they'll be initialized in the order that they're declared in.

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0
}
```

Previously initialized variables within the class body will also be in scope during initialization if you want to rely on their values:

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0

    val age: Int

    init {
        age = getCurrentYear() - year
    }

    val description: String = "$model ($age years, $miles miles)"
}
```

We can only initialize `description` this way after `age` has been initialized. If we placed it before the `init` block, we'd again see an error:
  
> *e: Variable 'age' must be initialized*

##### A look under the hood

If we decompile the bytecode produced for this class using the decompiler of the Kotlin IDEA plugin, we'll see this corresponding Java source (comments added):

```java
public final class Car {
    private double miles;
    private final int age;
    private final String description;
    private final String model;
    private final int year;

    // Getters & setters ...

    public Car(String model, int year) {
        // Properties in the primary constructor
        this.model = model;
        this.year = year;

        // Initialization at the declaration
        // (This is actually optimized away if we init to 0)
        this.miles = 0.0D;

        // init block
        this.age = Utils.getCurrentYear() - this.year;

        // Initialization at the declaration
        this.description = this.model + " (" + this.age + " years, " + this.miles + " miles)";
    }
}
```

This shows us how all the different kinds of initializations end up in the body of a single constructor together, in order.

##### Initialization rules, recap

To review, the initialization order:

- Properties in the primary constructor, in declaration order.
- Initializations at property declarations and in initializer blocks, interleaved, in the order that they appear in the class body.

Essentially, you can read the initialization statements in the class top to bottom, and that's what you'll get in the "body" of the primary constructor.

In each of these initializations, you can use the values of:

- Constructor parameters, even if they're not stored in properties.
- Previously initialized *(not just declared!)* properties.

*Due to these restrictions and safety guarantees, classes created via the primary constructor will always be in a valid state.*

![A representation of our single, primary constructor, which is in a valid state.](./images/2_primary.png)

##### Secondary constructors

Of course, there are cases when you want to create class instances with different sets of parameters, which normally requires multiple constructors. Kotlin's [default arguments](./1.md#default-and-named-parameter-values) make this possible to some extent while still keeping just a primary constructor. However, if you need a constructor that has entirely new parameters or parameters with different types, you'll need a *secondary constructor*.

For our example, let's say we need to be able to create cars with a model, year, and mileage, all provided as strings. Our primary constructor can't accommodate these parameters, so it's time to write a new one. This could be our first attempt:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
}
```

This code would fail at constructing a valid `Car` instance, and so it doesn't compile (though it certainly would in Java). For example, it doesn't set the `age` and `description` properties of the instance, which we expect to be initialized by every constructor.

> We also get an error for trying to set `year` and `miles` here: *Val cannot be reassigned*. As a `val` can only be initialized once, that one initialization will always have to happen in the primary constructor (if there is one).

![A secondary constructor that doesn't call the primary constructor is invalid.](./images/2_primary_and_invalid_secondary.png)

The fix, and the rule for secondary constructors is simple: it has to first call the primary constructor, and only after that can it perform further initialization on the instance that was created. *After the primary constructor is called by the secondary constructor, the instance is already in a well-constructed, known valid state*, so it's safe to operate on it in the body of the secondary constructor.

Let's change our secondary constructor to invoke the primary constructor first:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
): this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor that calls the primary constructor directly.](./images/2_primary_and_valid_secondary.png)

The call to the primary constructor doesn't have to be direct, it can also happen indirectly through calling another secondary constructor, but this chain eventually has to end in a call to a primary constructor.

Here's an example of yet another new constructor, which calls the previous secondary constructor:

```kotlin
constructor(data: Array<String>) : this(
        model = data[1],
        year = data[3],
        mileage = data[7],
)
```

![A secondary constructor that calls the primary constructor indirectly.](./images/2_primary_and_valid_secondaries.png)

What we really have here is a graph of the various constructors in our class calling each other.

- A primary constructor is valid if it initializes all properties. 
- A secondary constructor is valid if it eventually calls the primary constructor, i.e. if there's a directed path to the node representing the primary constructor from the node of the secondary constructor.
  - This also means that there can be no cycles within secondary constructor nodes, and no disconnected nodes.

![A graph of constructors.](./images/2_graph.png)

##### Without primaries [Extra content]

Another option when designing classes is to have no primary constructor at all, and use just secondary constructors. See [the extras for this chapter](./2-extras.md#without-primaries) to learn more.

### Data classes

One of the very frequently advertised features of Kotlin is *data classes*. To create a data class, simply add the `data` keyword to a class. Getting back to our favourite `Person` example:

```kotlin
data class Person(val name: String, var age: Int)
```

Adding this keyword adds some new functionality to this class, in the form of automatically generated methods. The first three of these are the `equals`, `hashCode`, and `toString` methods, which you already know from Java.

> In Java, these methods are present on the [`java.lang.Object`] type, which every class implicitly has as a supertype. In Kotlin, the type in the same role is called [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/), and maps exactly to `Object` when you're running Kotlin on the JVM.

The generated `equals` and `hashCode` methods will always consider all properties that are in the primary constructor, and only those. If you need different behaviour, you can still override these implementations yourself. (Though in this case, you might be better off without a data class.)

The generated `toString` method will give you a nicely formatted string that contains the name of the class, as well as the names and values of its primary constructor properties:

```kotlin
val emma = Person("Emma", 19)
println(emma) // Person(name=Emma, age=19)
```

> You might argue that you're not writing these methods anyway, even in Java, but generating them with IDE shortcuts. However, those generated methods are part of the codebase, and have to be maintained. With data classes, these are generated every time the class is compiled, so they're guaranteed to follow any changes to the class, for example, a new property being added.

There are also some methods generated that are only useful for Kotlin users. One of these kinds of methods are the `component1`, `component2`, etc. methods, which can be used with [destructuring declarations](https://kotlinlang.org/docs/destructuring-declarations.html), a feature that allows you to declare and initialize multiple variables at the same time, with an assignment like this:

```kotlin
val (name, age) = emma
println(name) // Emma
```

Note that destructuring works in a positional way, and that these variables can have arbitrary names. For example, swapping the names of these two variables will lead to very unexpected results:

```kotlin
val (age, name) = emma
println(name) // 19
```

Finally, the last generated method for data classes is `copy`, which allows you to... make a copy of your current instance.

```kotlin
val clone = emma.copy()
println(clone) // Person(name=Emma, age=19)
```

Its real power lies in the fact that it actually has as many parameters as the class does in its primary constructor - they just all default to taking the value of the original instance. This means that you can choose to change them one by one, using named parameters, for example:

```kotlin
val olderEmma = emma.copy(age = 26)
println(olderEmma) // Person(name=Emma, age=26)
```

We've provided only the `age` parameter, so the other properties of the class will take their values from the original instance.

The `copy` method comes in especially handy when using it on completely read-only data classes, which only have `val` properties. Since you can't change these, you have to create new instances whenever you need to represent slightly changed data, and this can get very tedious when you have to copy the old values for several properties. The `copy` method does this for you, allowing you to only change what you want to change for the new instance, easily.

> Notice how this is part of Kotlin's general push to prefer immutability. The less mutable state a class holds, the easier it is to reason about how it will behave at any given point in time. Immutability also has huge advantages in multi-threaded environments. You don't have to synchronize accesses to immutable objects, as they never change! So whether it's a local variable or a property, remember to always go with a `val` first.

> The `copy` method performs a shallow copy. Any references to other objects will therefore be the same in the original and the copy created.

Data classes do have some requirements:
- Their primary constructor can't be empty, it needs to contain at least one property.
- All primary constructor parameters need to be properties, either `val` or `var`.
- Inheritance is also restricted: data classes can not be inherited from.

The last point here is especially important, and can be quite restrictive in some cases. Remember that regular Kotlin classes are already very concise and powerful if you just need them to hold a couple values as properties. [Not everything has to be a data class.](https://zsmb.co/data-classes-arent-that-magical/)

> Hint: The generated code for data classes is a very interesting thing to look at with a decompiler!

> Java 16 introduced [records](https://docs.oracle.com/en/java/javase/18/language/records.html), which achieve something similar to data classes, automatically generating lots of boilerplate for simple data holders. [Kotlin has support for records](https://kotlinlang.org/docs/jvm-records.html) as well, allowing you to use Java-declared records, as well as to declare records in Kotlin code.

### Objects

An `object` is a construct similar to a class in Kotlin, with one difference: while you create instances of classes, an object is an instance on its own. What's more, it's the *only* instance of its type! This is essentially a very concise way to declare a [singleton](https://en.wikipedia.org/wiki/Singleton_pattern):

```kotlin
object Logger {
    var isEnabled = true
    
    fun log(message: String) {
        if (isEnabled) {
            println(message)
        }
    }
}
```

An `object` can not have a constructor, and its single instance can be accessed simply by its name:

```kotlin
Logger.log("Hello world") // Hello world
Logger.isEnabled = false
Logger.log("Oh no, where's my log") //
```

Objects may be declared inside classes. In this case, they can access the internals of the class that they're nested in, and they can be used with the following syntax:

```kotlin
class Document {
    object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

fun main() {
    repeat(5) {
        Document()
    }
    println(Document.Counter.count) // 5
}
```

> [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) is a simple way to execute a piece of code a given number of times.

How would you add a counter like this in Java? You would simply use a static variable inside the class. Kotlin doesn't have static members, neither properties nor functions. However, if you mark a nested `object` inside the class as the *companion object* of the class, you'll get the following familiar syntax for accessing anything inside that `object`:

```kotlin
class Document {
    companion object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

println(Document.count)
```

What makes this work is that writing down the name of the class -`Document` in this example - will actually give you the reference to the companion object. You can confirm this easily, with this slightly odd line of code:

```kotlin
val counter: Document.Counter = Document
```

Naturally, classes can only have one companion object. This object is special, as it doesn't have to have an explicit name. If you don't name it, it will be named `Companion` implicitly:

```kotlin
class Document {
    companion object {
        var count: Int = 0
    }

    val id = count++
}

val counter: Document.Companion = Document
println(Document.count) // 5
```

As far as Kotlin syntax is concerned, this is as good as having static variables and functions - you simply place these inside a companion object. However, these things are still members in an inner class of `Document`, which we're then using just a single instance of. They're not *really* static members of the `Document` class.

> This can cause issues with certain Java-based frameworks that work with static fields and methods, and the syntax for Java clients isn't completely smooth either:
>
> ```java
> Document.Companion.getCount();
> ```
> 
> If you need real static declarations for Java compatibility, you can use the [`@JvmStatic`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-static/) annotation on methods or properties inside a companion object:
> 
> ```kotlin
> class Document {
>     companion object {
>         @JvmStatic
>         var count: Int = 0
>     }
> }
> ```
> 
> This will expose them as real static declarations:
> 
> ```java
> Document.getCount();
> ```
> 
> You can also use [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) to turn properties in the companion into static fields. To read more about the various possibilities for static interop, see [the table in this blog post](https://zsmb.co/top-10-kotlin-stack-overflow-questions-2/#5-replacing-static-things). 


### Nested classes

A quick word about nested classes. They work similarly to the ones in Java, with one significant difference: *they don't hold a reference to the outer class by default*. This helps avoid accidentally capturing references to outer classes, which can lead to memory leaks. In Java, this behaviour would be achieved by adding the `static` keyword in front of the nested class.

```kotlin
class Outer {
    var outerValue = 0
    
    class Inner {
        init {
            println(outerValue)
                 // ^ Unresolved reference: outerValue
        }
    }
}
```

If you do want an implicit reference to the outer class stored in the nested class, use the `inner` keyword - this gives you the behaviour that would be the default in Java:

```kotlin
class Outer {
    var outerValue = 0

    inner class Inner {
        init {
            println(outerValue) // 0
        }
    }
}
```

### Inheritance

Let's create a simple game to learn about how Kotlin deals with inheritance. For a start, we'll create an `Entity` base class, which will store the current position of an entity on screen, as two coordinates:

```kotlin
class Entity(var x: Double, var y: Double)
```

We can extend this `Entity` class with a concrete implementation using the following syntax:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y)
```

This `UFO` class has a primary constructor that takes two parameters, and this primary constructor calls into the superclass' constructor, passing on both parameters.

> Note that even if `Entity` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Entity()` syntax.

The code above, somewhat surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be inherited from unless that's explicitly allowed, by making them `open`:

```kotlin
open class Entity(var x: Double, var y: Double)
```

This design choice falls in line with one of the often cited items of the [Effective Java](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/) book - *Item 19: Design and document for inheritance or else prohibit it*. Extending a class that was not designed with inheritance in mind can lead to a wide variety of problems, and *final by default* serves as a safeguard against this.

> Items of this book will be referenced by these materials every now and again, as Kotlin promotes many Java best practices naturally, through its language design. If you haven't read it yet, you should really consider it.

In our specific case, it also doesn't make sense to let clients create `Entity` instances directly, which we can prevent by making this base class `abstract`. This works the same way as Java's abstract classes: it prevents creating instances of this class, while still allowing inheritance from it. Abstract classes, of course, are always `open`.

```kotlin
abstract class Entity(var x: Double, var y: Double)
```

Next up, we'll add a `progress` method to the base class, which will be invoked by our "game engine" to indicate that time has passed.

Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no default implementation provided for it - this will force concrete subclasses to override it.

For our `progress` method, we'll choose an `open` method, which will have an empty body:

```kotlin
abstract class Entity(var x: Double, var y: Double) {
    open fun progress() {
        /* Empty */
    }
}
```

In Java, [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) is an optional annotation. In Kotlin, it's a required keyword. Let's add some random movement to our UFO class in its `progress` method:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y) {
    override fun progress() {
        x += Random.nextDouble(from = -5.0, until = 5.0)
        y += Random.nextDouble(from = -10.0, until = 10.0)
    }
}
```

> [`java.util.Random`](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) is still available to use in Kotlin when you're on the JVM, but the [`kotlin.random.Random`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/) class from the Standard Library provides a simple, platform independent random API, which you should use in most cases. This is what's used in the previous code snippet.

We'll keep track of our entities in a list in a `Game` class:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun tick() {
        for (entity in entities) {
            entity.progress()
        }
    }
}
```

### Interfaces and type checks

Next up, let's draw our game on the screen, and learn about interfaces.

Kotlin's interfaces are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods (much like Java 8 interfaces).

Let's introduce a `Renderable` interface, which will be implemented by entities that can be displayed on the screen:

```kotlin
interface Renderable {
    val isVisible: Boolean
    fun render(canvas: Canvas)
}
```

This interface requires implementations to be able to tell whether they're currently visible, and to `render` themselves onto a `Canvas` when asked to do so.

Our `UFO` class will implement this interface:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y), Renderable {
    companion object {
        const val WIDTH = 40.0
        const val HEIGHT = 40.0
    }

    override var isVisible: Boolean = true

    override fun render(canvas: Canvas) {
        // Drawing logic using JavaFX
        val context = canvas.graphicsContext2D
        context.fill = Color.DIMGRAY
        context.fillOval(x, y, WIDTH, HEIGHT)
        context.fill = Color.DODGERBLUE
        context.fillOval(x + WIDTH / 4, y + HEIGHT / 4, WIDTH / 2, HEIGHT / 2)
    }

    /* ... */
}
```

A couple of things to note here:

- Implementing interfaces uses nearly the same syntax as extending classes, except there are no parentheses indicating a constructor call.
- [Constants](https://kotlinlang.org/docs/properties.html#compile-time-constants) which would be static in Java can't reside directly in classes - in that case, they would just be properties, being present as a value in each instance. However, they may be placed inside an `object`, which can then be nested in the class. This is often - but not necessarily - the companion object. By marking these with the `const` keyword, we get to use them in annotations, and their values will be inlined to any use sites.

The implementation of `isVisible` is especially interesting. The `Renderable` interface declares it as a `val` of `Boolean` type. This lets implementations of the interface choose from a wide variety of implementations, as long as a getter exists for this property.

In the `UFO` class, we've implemented this as a `var`, which will create a field, a getter, and a setter inside the class. We can also implement this property with a custom getter, as a delegate, or as a *computed property*:

```kotlin
override val isVisible: Boolean
    get() {
        return x > y
    }
```

Computed properties are properties where the getter (and setter, if it's a `var`) doesn't reference its backing field. In this case, a backing field won't be generated inside the class for the property at all. The accessors of these properties can rely on other methods or properties that are in scope.

This means that computed properties can even be present in interfaces, as they store no state - they're just getters/setters with default implementations.

Let's update our `Game` class, to add support for rendering `Renderable` entities:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun renderScene(canvas: Canvas) {
        canvas.graphicsContext2D.fill = Color.BLACK
        canvas.graphicsContext2D.fillRect(0.0, 0.0, canvas.width, canvas.height)

        for (entity in entities) {
            if (entity is Renderable && entity.isVisible) {
                entity.render(canvas)
            }
        }
    }
    
    /* ... */
}
```

The `renderScene` method fills the background of the game, and then renders each `Renderable` entity in a loop. Within the loop, we check whether each entity implements this interface with the `is Renderable` syntax (essentially an `instanceof` check).

The surprising part of this code is that there's no casting to a `Renderable` after this check passes. We just use the `isVisible` property and the `render` method of the entity that passed the type check directly.

This is thanks to a feature called [*smart casts*](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts). Whenever the compiler can reason about the type of a variable based on type checks and control flow, it will automatically make the variable available as the known type, performing the cast for us.

This would even work if we checked for non-conformance to the `Renderable` interface, with the `!is` operator:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) {
        continue
    }
    if (entity.isVisible) {
        entity.render(canvas)
    }
}
```

> `continue` is a somewhat rarely used keyword in C-style languages, which terminates the current iteration of a loop, and skips to the next one.

Smart casts replace most manual casting in Kotlin, but casting explicitly is still possible with the `as` keyword. `entity as Renderable` will throw an exception if `entity` is not a `Renderable`, and return it with the `Renderable` type if it is.

This completes the interesting bits of implementation for our UFO game - find the full code of the game [in this project](../projects/chapters/chapter-2-inheritance-demo).

### Class delegation (implementation by delegation) [Extra content]

Classes can also implement interfaces _by delegation_. Instead of implementing the members declared in the interface in the class itself, the class may delegate to another instance that already implements that interface.

This looks something like this:

```kotlin
class RocketShip(delegate: Renderable) : Renderable by delegate
```

Whenever a member of `Renderable` is invoked on the `RocketShip` instance, it will forward that call to the same member of `delegate`.

Learn more about why this is useful in the [extras for this chapter](./2-extras.md#class-delegation-implementation-by-delegation).

### Sealed classes

> Nothing to do with C# sealed classes!

At times, it's handy to be able to restrict inheritance from a class. *Sealed classes* prevent unknown subclasses of a base class by allowing it to be extended only by classes that are in the same package ([before Kotlin 1.5: in the same file](https://kotlinlang.org/docs/whatsnew15.html#package-wide-sealed-class-hierarchies)).

> [Before Kotlin 1.1](https://kotlinlang.org/docs/reference/whatsnew11.html#sealed-and-data-classes), subclasses had to be *nested* in the sealed class. You can still see this pattern of nesting in many usages of sealed classes today.

For example, we may represent the response from a network call with a sealed class:

```kotlin
sealed class Response
class Success(val data: String) : Response()
class Error(val exception: IOException) : Response()
```

Then, instead of the unfriendly APIs that throw exceptions at us when something goes wrong, we can provide an API that will always return a `Response` instance as the result of a network call.

```kotlin
fun getDataFromAPI(): Response {
    return try {
        val data = URL("https://www.kotlinlang.org/").readText()
        Success(data)
    } catch (e: IOException) {
        Error(e)
    }
}
```

> Remember, `try-catch` is an expression!

We know that this `Response` will either be an instance of `Success` or `Error`. This small set of possible values can only change if someone has access to this source file, and can recompile it.

This brings us to a frequently used capability of `when`, its ability to perform type checks:

```kotlin
when (val response = getDataFromAPI()) {
    is Success -> {
        println("Network success")
        println(response.data)
    }
    is Error -> {
        System.err.println("Network error")
        response.exception.printStackTrace()
    }
}
```

> Notice that in each branch, the value of `response` is smart cast to its concrete type, making properties like `data` and `exception` accessible on them!

If we use `when` as an expression (we return a value from it), we can do so with sealed classes without having to provide an `else` branch. The compiler can guarantee that the statement is already exhaustive with just these two branches, since we know all existing implementations of `Response`:

```kotlin
val message = when (getDataFromAPI()) {
    is Success -> "Network success"
    is Error -> "Network error"
}
println(message)
```

> Using sealed classes for error handling is a neat way of avoiding having to deal with exceptions in Kotlin. For more error handling strategies, watch [this KotlinConf 2019 talk by Nat Pryce and Duncan McGregor](https://www.youtube.com/watch?v=pvYAQNT4o0I). Spoiler alert: contains quite a few advanced Kotlin features that we haven't covered yet.

Since Kotlin 1.5, [sealed interfaces are also available](https://kotlinlang.org/docs/whatsnew15.html#sealed-interfaces). The rules for implementing these interfaces are the same as subclassing sealed classes. A prominent use case for sealed interfaces is using them in libraries to ensure that users of the library can never implement a given interface.

> Java 17 also introduced [sealed classes](https://openjdk.org/jeps/409) with slightly different syntax.

### Enums

Enums are classes in Kotlin, and a basic enum declaration looks like this:

```kotlin
enum class Sizes {
    S, M, L
} 
```

It's useful to think of enums as a class with a very specific number of instances. In the example above, `S`, `M`, and `L` are the only three instances of `Sizes` that will ever exist.

> You could also think of enums as sealed classes, with all of their subclasses being `object`s. If that makes sense to you, you're getting a good grasp of OOP in Kotlin! (Please note though that this is not actually the case - enums are their own thing.)

Enums may also have properties and methods, just like any regular class. These can be implemented once for each of them, in the "base class", or be "abstract" and implemented by each value separately:

```kotlin
enum class MenuItem(val price: Double) {
    Hamburger(4.65),
    Fries(3.50),
    Coke(2.50) {
        override fun purchase() {
            super.purchase()
            println("It's a coke!")
        }
    }; // !
    
    open fun purchase() {
        println("Spending $price")
    }
}
```

> The semicolon separating the list of instances from the enum's methods is one of the very very few required semicolons in the Kotlin language.

### Visibility

Kotlin has similar [visibility modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html) to Java on first sight, but they come with a few significant changes. These modifiers can be applied to declarations of various types: classes, objects, properties, and so on.

- `public` declarations are accessible from anywhere. *This is the default visibility in Kotlin*, and it's implicit. The "package" visibility that was the default in Java is not available in Kotlin.
- `private` declarations in classes are only accessible within the same class, while top-level* `private` declarations are only accessible in the same file.
- `protected` declarations are only accessible in the containing class or its subclasses. They are *not* also accessible from code in the same package, like they are in Java.
- `internal` declarations are accessible within the same compilation unit, for example, the same Gradle module. This is a visibility unique to Kotlin, and it's especially useful for keeping library internals private from clients.

**top-level: Declarations that are declared directly in a file, and not nested in classes. Really, these are package level declarations, it's their package that contains them lexically.*

Some non-obvious use cases of visibility modifiers would be applying them to constructors, or auto-generated getters/setters:

```kotlin
class SecretValue internal constructor(initialValue: Int) {
    var state: Int = initialValue
        private set
}
```

This class cannot be instantiated from another module due to the limited visibility of its constructor. Note that in this case, the `constructor` keyword must be added to the primary constructor.
 
 Additionally, while its `state` property is a `var`, its setter will not be visible externally, essentially making it a `val` to the outside world.

## Summary

The elements of object-oriented programming in Kotlin are very similar to mainstream OO languages such as Java, with a few notable exceptions.

Instead of fields, getters, and setters, Kotlin operates on the abstraction level of properties. These properties can have auto-implemented accessors or custom ones. They may also be delegated, or be computed (have no backing field).

The primary constructor is the main way of initializing instances, and it comes with special safety guarantees. Secondary constructors have to rely on the primary constructor to perform the basic initialization of the class in most cases.

Data classes come with auto-generated utility methods in exchange for suffering a few restrictions. `object` declarations are a brief way to create singletons in Kotlin. Nested objects and companion objects can act as the "static" parts of classes. Inner classes are "static" by default, and have to be marked with `inner` to get a reference to the outer class.

Classes are final by default, and have to be marked with `open` (or `abstract`) to be inherited from. Interfaces can contain property and function declarations, as well as default implementations for functions. Casting in Kotlin is mostly done via smart casts which happen automatically after a successful type check. Sealed classes are a way to restrict an inheritance hierarchy, which can guarantee exhaustive checks on what the type of a given instance is.

Visibility modifiers are slightly different than in Java. Declarations are `public` by default, and Kotlin offers an `internal` modifier.

## Sources

- [Execution in the Kingdom of Nouns - Steve Yegge](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)
  - A tale of how functions are treated in Java.
- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Data classes aren't (that) magical](https://zsmb.co/data-classes-arent-that-magical/)
- Official documentation
  - [Classes and Inheritance](https://kotlinlang.org/docs/reference/classes.html)
  - [Interfaces](https://kotlinlang.org/docs/reference/interfaces.html)
  - [Properties and Fields](https://kotlinlang.org/docs/reference/properties.html)
  - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)
  - [Data Classes](https://kotlinlang.org/docs/reference/data-classes.html)
  - [Sealed Classes](https://kotlinlang.org/docs/reference/sealed-classes.html)
  - [Nested and Inner Classes](https://kotlinlang.org/docs/reference/nested-classes.html)
  - [Enum Classes](https://kotlinlang.org/docs/reference/enum-classes.html)
  - [Visibility Modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html)

# Chapter 3: Nullability

Safety, as we've discussed in the [introduction](1.md#chapter-1-introduction), is a defining property of the Kotlin language. So why do we need safety guarantees from languages?

The worst kind of errors are runtime errors: they happen while users are interacting with the application, likely resulting in an unpleasant experience. Compile time errors are better than runtime errors, as developers face these instead. Even better than compile time errors are edit time errors (or design time errors, if you will): not having to build the project, but seeing the error immediately when making it while writing the code. For Kotlin, the latter two categories of errors are essentially the same, as IntelliJ will show you nearly all compilation errors in real time (as it runs the exact same code to analyze Kotlin code as the compiler).

To move as many errors as possible to compile/edit time, Kotlin is...

- A statically typed language, meaning that each variable has a fixed type which is known at compile time, and doesn't change later. This allows verification such as making sure that whatever methods are called on a variable do, in fact, exist.
- A strongly typed language, which means that values are almost never converted to other types implicitly.

> JavaScript is an excellent counter-example for both of these traits.

Another safety feature, which is perhaps the most often touted one in Kotlin, is *null safety*. This is often advertised as *"Kotlin doesn't have NullPointerExceptions!"*. While this statement is categorically false, we'll see that Kotlin really does do a lot to minimize nullability problems.

### The issue on the table

What's the problem with nulls in the first place? For example, that even this trivial Java method isn't "safe":

```java
public static boolean isEmpty(String str) {
    return str.length() == 0;
}
```

For example, if you pass in `null` as its parameter, it will throw an exception. Would you ever expect a method like this to do that?

The core problem is that you have to keep `null` in mind constantly as you write Java code. These are everyday questions with Java:

- Will a given method accept `null` as its parameter? Will it throw a validation exception for the parameter, or will it crash unexpectedly somewhere halfway?
- Will a given method ever return a `null` value? Do you need to check for that before you operate on it? 
- Does this field in this class ever hold `null`, or can you trust that it's always initialized?

Null checks themselves aren't the problem. It's not knowing when they're needed for certain that's the issue. You can't feasibly null check every value you ever call a function on, which means that sooner or later you'll try to do it on a `null` value. And of course, you'll only find this out at runtime, with the infamous `NullPointerException` (NPE).

Null - the absence of value - is something we need to be able to express, and it can actually [be your friend](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5) if the language allows you to [deal with it safely](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903).

### Nullability

Null safety means that each type in the Kotlin language is either nullable or non-nullable. The former allows a `null` value, while the latter forbids it. This is known at compile time, and the compiler enforces null safety as part of type checking.

The types we've seen so far have all been non-nullable: `Int`, `Person`, and `FileInputStream` are examples of this. You can't assign `null` to a variable of any of these types:

```kotlin
val person: Person = null
```

> e: Null can not be a value of a non-null type Person

The nullable counterparts of these types are denoted by a `?` at the end of the typename: `Int?`, `Person?`, and `FileInputStream?` are all nullable. A variable with one of these types is able to hold `null`, in addition to being able to hold a reference to an object of the given type. This code will compile:

```kotlin
var person: Person? = null
person = Person("Ann", 37)
person = null
```

> The `?` syntax implies uncertainty, or even a question: does a variable of type `Person?` hold an actual `Person`? Maybe. It's a person (?). It's a `Person?`.

If you choose a nullable type, the compiler will know that you have a possibly `null` value, and prevent you from accidentally calling something on this reference - whether that's a method invocation, or reading a property:

```kotlin
println(person.name)
```

> e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Person?

The error message tells us that this call is not allowed, and even suggests some ways to fix the issue of trying to work on a nullable value.

Thankfully, Kotlin provides several convenient features to perform a null check. Let's start with the simplest one, an actual, explicit null check using `if`:

```kotlin
if (person != null) {
    println(person.name)
}
```

This code works, because inside the `if` statement, we receive a *smart cast*. The `person` variable's type changes from `Person?` to `Person` within that scope, and we can operate on it as usual.

Note how this gets us from a broader type to a more specific type, just like a smart cast from an `Animal` type to a `Dog` type would in this scenario:

```kotlin
abstract class Animal
class Dog(val name: String) : Animal()

fun dogCheck(animal: Animal) {
    if (animal is Dog) {
        println("${animal.name} is a good boy")
    }
}
```

Null handling in the type system isn't as special as it seems. We'll take a deeper look at how it works in [chapter 9](./9.md#the-parallel-nullable-and-non-nullable-type-hierarchies).

### Safe calls

One of the basic ways to handle a `null` value is the safe call operator `?.`. It simply replaces the regular accessor `.` of a property access or method call:

```kotlin
println(person?.name)
```

If the operand of `?.` is `null`, it will skip the operation on it, and the entire expression (`person?.name` in the example) will just evaluate to `null`.

This operator can be chained if you have nested data models, where any of them might be `null` along the way. If this happens, the entire chain will short circuit and return `null`.

```kotlin
val street: String? = person?.company?.address?.building
```

While the safe call operator lets you make method calls safely, without the possibility of an NPE, it's not perfect:

- It will never get you a non-nullable value. Whatever values you get from a safe call will always be nullable, as the call might have been skipped.
- It can hide certain issues in your code if you use it carelessly. A call such as `service?.sendEmail()` silently skips sending the email if `service` happens to be `null`, and you don't get to handle the error case. The safe call is shorthand for an `if-else` statement with an implicitly empty `else` branch:

    ```kotlin
    if (service != null) {
        service.sendEmail()
    } else {
        /* Do nothing */
    }
    ```

    Only use this operator if your calls are *truly* optional, and you don't mind if they don't happen.

### Elvis operator

The Elvis operator `?:` (tilt your head to the left) is a path from the nullable world to the non-nullable one. Here's how it's used:

```kotlin
val message: String? = getMessage()
val length: Int = message?.length ?: 0
```

If the value on the left side of the operator is not `null`, it will return that value. Otherwise, the Elvis expression returns the right hand side value. That's it!

This operator is often used to provide a default value of sorts if something happens to be `null`, like in the example above. It also comes in handy to throw an exception or return from a method due to a `null` value:

```kotlin
fun processInput() {
    while (true) {
        val input: String = readLine() ?: return
        println("Input was: $input")
    }
}
```

> The [`readLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/read-line.html) function from the Standard Library reads a line from the standard input stream, and returns `null` if the end of the input has been reached.

We'll look at how the evaluation and inference of types works exactly when using the Elvis operator [later on](./9.md#elvis-revisited), when we dive deeper into the Kotlin type system.

> Fun fact: this operator is also referred to as the [null coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator), and is present in many languages.

### `!!` operator

If you really want to shoot yourself in the foot, Kotlin provides you the tool to do so. The *not-null assertion operator* is a favourite of NPE lovers. It's very simple: it either returns whatever you've applied it to with a non-null type, or it throws an exception ~~(a `KotlinNullPointerException`, to be precise)~~ (a regular [`NullPointerException`](https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html), [since Kotlin 1.3.50](https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/)).

```kotlin
println(person!!.name)
```

This code is equivalent to the following:

```kotlin
val person: Person? = null
if (person == null) {
    throw NullPointerException()
}
println(person.name)
```

Note that unlike the safe call operator `?.`, this operator doesn't include the `.` accessor. It can be used just on its own in an expression to force a null check / smart cast, as it will be evaluated, and throw an exception if it fails the check:

```kotlin
person!!
println(person.name) // person is smart cast to `Person` here
```

For the same reason, you'll never be able to construct an instance of a class like this one, as it will always throw an exception while it's being constructed:

```kotlin
class Episode {
    var airdate: Date = null!!
}
```

### Safe casts

We see that handling nullable values is convenient in Kotlin, since the language provides many tools for this purpose. *Safe casts* let us make use of these tools when we need to perform type checks, by transforming a question of type conformance to a question of nullability:

```kotlin
val renderable: Renderable? = entity as? Renderable
```

A safe cast performed with `as?` will either succeed and return the original value as the given type, or fail and return `null` instead. Handling this `null` value is often more convenient than performing a type check, or attempting a regular cast and catching a possible exception.

Take this slightly modified example from our game in the previous chapter, which uses a type check:

```kotlin
for (entity in entities) {
    if (entity is Renderable) {
        entity.render(canvas)
    }
}
```

We can easily rewrite this using a safe cast, and then a safe call:

```kotlin
for (entity in entities) {
    (entity as? Renderable)?.render(canvas)
}
```

Similarly, if you take this loop, with an inverted condition:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) continue
    entity.render(canvas)
}
```

... you can rewrite it using a safe cast and an Elvis operator:

```kotlin
for (entity in entities) {
    val renderable = entity as? Renderable ?: continue
    renderable.render(canvas)
}
```

These may or may not be more legible than the original code for you at this point. As you get used to Kotlin and read more Kotlin code, such patterns will surely become familiar.

### lateinit

The language's strict class initialization rules require every property to be initialized when an instance is constructed. This applies to nullable properties as well, even if you're just initializing them to `null`.

However, there are several frameworks that rely on lifecycle callbacks for initialization rather than the constructor. When working with these, you may end up having to make properties nullable just because you're initializing them later than "constructor-time":

```kotlin
class MyApplication : Application() {
    private var timer: AnimationTimer? = null

    override fun start(primaryStage: Stage) {
        // Setup things
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }
    }
}
```

> Here's a new use of the `object` keyword, an [*object expression*](https://kotlinlang.org/docs/object-declarations.html#object-expressions)! This is the way to create anonymous implementations of interfaces or anonymous subclasses in Kotlin. It's equivalent to using `new AnimationTimer() {}` in Java. Note the parentheses indicating the call to the superclass constructor in the Kotlin syntax, which is the same as with regular subclassing.

The compiler will guarantee null safety by continuously forcing us to perform null checks of one kind or another when we interact with this `timer` property. This is inconvenient, since we know that `timer` will be initialized in time, and never be `null` when we're trying to use it. Both of these calls will work, but they are both unnecessarily verbose, and introduce complexity in the code:

```kotlin
timer?.start()
timer!!.stop()
```

What's even worse is that regular null checks will not work on `timer`, as it's a class-level, mutable property:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer = object : AnimationTimer() { ... }

    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

> e: Smart cast to 'AnimationTimer' is impossible, because 'timer' is a mutable property that could have been changed by this time

The compiler's worry here is that the class might be used in a multithreaded environment, where a thread executing in parallel to the current one may change the value of `timer` between the `if` statement's condition being evaluated and its body executing, which could lead to an NPE.

> We'll see a neat way to perform a null check for such a `var` later on.

The solution for this is the `lateinit` keyword, which signals to the compiler that a property will be initialized late - later than constructor time. (In the case of a `lateinit` local variable, later than declaration time.)

By using it, you, the developer, will bear the responsibility of initializing the property before you start using it. In turn, the compiler will stop worrying about it, and let you use it freely. Using this keyword is the equivalent of turning `null` safety off, but it's appropriate and useful in situations like these.

Adding it to `timer` lets us make it non-nullable (in fact, `lateinit` declarations can not be nullable), and use it freely:

```kotlin
class MyApplication : Application() {
    private lateinit var timer: AnimationTimer

    override fun start(primaryStage: Stage) {
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }

        timer.start()
        timer.stop()
    }
}
```

What happens if you fail to initialize such a property in time? You'll get a nicely formatted `UninitializedPropertyAccessException`, with a message like this:

> lateinit property timer has not been initialized

If you ever forget to set a `lateinit` variable in time, this is still more useful for tracking down the issue than getting a generic NPE.

### Java interop, platform types

Kotlin prides itself on interoperability with the native languages and tools of whatever platform you're running it on. Since Java doesn't have a language level concept of nullability, how can Kotlin's strict null handling be reconciled with going back and forth between the two languages?

##### Kotlin to Java interop

By default, declarations coming from Java have _platform types_. This means that their nullability is just... Unknown. ¯\\\_(ツ)\_/¯

For example, consider this class, which - like most Java code - contains no nullability information.

```java
public class JavaTest {
    String platform;

    public JavaTest(String platform) {
        this.platform = platform;
    }
}
```

This is true about the data it's storing, as well as its constructor parameter. Both of these will have the platform type of `String!` when looking at them from Kotlin. Platform types are *non-denotable*, meaning that while they're a part of the language, they can not be used directly in source code. They will only show up in IDE hints and compiler messages.

Whenever we use this class from Kotlin, we are free to pass in either a nullable or non-nullable value as the constructor parameter:

```kotlin
val test1 = JavaTest(null)
val test2 = JavaTest("string")
```

We're also allowed to either perform null handling when we read the value of `platform`, or not:

```kotlin
val test = JavaTest(null)
println(test.platform.length)
println(test.platform?.length)
```

When we work with platform types, our null safety drops to the level of safety that Java provides - *none*. We either perform null checks when something may be null, or we don't, and then we might crash with an NPE.

This seems like a major blow for Kotlin's null safety - and, well, it is. This is the cost of interoperating with a language that inherently doesn't care about nullability, and you'll have to keep this in mind whenever you call a Java-based API. You can hope for the best and just use values that have platform types directly, you can treat all of them as if they were nullable (though the Kotlin compiler won't enforce this), or you can try to balance the two somehow.

> Fun fact: in early stages of the interop design, _everything_ coming from Java was considered nullable, and had to be checked or handled accordingly. While super safe, this turned out to be unfeasible in practice, and was replaced by platform types.

It's a good idea to make your choices about how you treat something with a platform type explicit, by not letting the compiler infer platform types for variables. Instead of this declaration, which implicitly creates a variable with the type `String!`:

```kotlin
val str = test.platform
```

You should choose one of these explicitly typed declarations, which essentially documents whether you thought this value was nullable or not:

```kotlin
val str1: String = test.platform
val str2: String? = test.platform
```

If you choose the former, and `platform` does happen to be `null`, you'll get an exception immediately here, at the assignment. This is *much* easier to track down if it happens than giving the variable a platform type here, and crashing later in your code, when you try to actually use it.

> The bytecode performing the check is interesting to take a look at!

##### Nullability support from Java

So what's the solution for existing code that's written in Java, and all the existing libraries in the JVM ecosystem? How can they aid Kotlin's null safety?

The ultimate solution is to _"just"_ migrate that code to Kotlin, and while [this has been done](https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin), it's certainly not feasible for all of the code in every project. You can still be a good citizen even if you're maintaining Java APIs though, thanks to the Kotlin compiler's support for [nullability annotations](https://kotlinlang.org/docs/java-interop.html#nullability-annotations).

These have been slowly gaining adoption in Java over the years, and several sets of them exist. There's a JSR implementation, and Lombok, Android, and of course JetBrains have their own too, just to mention a few. Each slightly different, each in different packages. The Kotlin compiler supports all of the ones mentioned and more, see [the compiler's source](https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt) for the up-to-date list.

We'll use the JetBrains flavour of these annotations for the examples here. Using these, you can annotate your types in Java like this:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;
}
```

If you're using an IDE that supports these annotations, you'll see a warning on `notNull` here immediately, as it's not initialized by the implicit, empty constructor, and is therefore `null` when an instance of this class is created. 

> This code will still compile, however. These annotations are not enforced by the Java compiler!

This can be fixed by adding a proper constructor:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;

    public JavaTest(@Nullable String nullable, @NotNull String notNull) {
        this.nullable = nullable;
        this.notNull = notNull;
    }
}
```

These annotations will be picked up when using this class from Kotlin, which means that the constructor will have a `String?` and a `String` parameter. You'll be forced to perform a `null` check when you try using `nullable`, and the compiler will warn you that a `null` check is unnecessary if you add one for `notNull`.

```kotlin
val test = JavaTest(null, "string")

println(test.nullable.length) // e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
println(test.nullable?.length) // ok

println(test.notNull.length) // ok
println(test.notNull?.length) // w: Unnecessary safe call on a non-null receiver of type String
```

These annotations are trusted by the compiler, but unlike Kotlin's nullability, they aren't actually verified at compile time. You can easily write and compile code like this, as it only shows an IDE warning:

```java
@NotNull
String getData() {
    return null;
}
```

This method would be visible with a non-nullable return type in Kotlin, and probably cause crashes on the Kotlin side at some point.

It's your responsibility that you annotate your APIs correctly with these annotations. Providing these annotations makes the lives of both your Java and Kotlin clients easier, and if you are maintaining a Java API, you should definitely make use of them.

> In the Android community, the adoption of these annotations escalated quickly as Kotlin gained more and more popularity.

##### Java to Kotlin interop

What about the other direction, calling Kotlin code from Java? If you are using an IDE that understands nullability annotations in pure Java code, it will likely also pick up Kotlin nullability information, as the compiler injects these annotations into the bytecode produced from Kotlin sources.

Yet again, this won't be enforced when compiling Java code against a Kotlin API, but it will be present for you as extra information when you're writing your Java code, letting you code safer.

### Nullable basic types

Basic types (such as `Int`) are represented as a primitive at the bytecode level whenever possible. For example, the parameter of this function will be a primitive:

```kotlin
fun calculate(x: Int) { ... }
```

Decompiled, we'd be looking at code like this:

```java
void calculate(int x) { ... }
```

However, if we use a nullable type, the boxed variants of basic types will have to be used instead. Since primitives are not reference types, they can't hold `null` as their value.

```kotlin
fun configure(x: Int?) { ... }
```

Decompiled, we'll see the boxed type, which allows us to potentially pass `null` into this function:

```java
void configure(@Nullable Integer x) { ... }
```

### Runtime checks

Until now, we've talked about the compile time checks that are performed to grant null safety. These, however, aren't quite enough on their own. When you're calling into Kotlin from Java, you can easily pass in `null` for a parameter that's declared as non-nullable, and the implementation of the method won't be prepared for this.

As an example, let's take this method that takes a `String` as a parameter, and prints its characters line by line. It also modifies some state at the start and end of the method, which prevents multiple invocations printing two strings at the same time (let's ignore the threading issues with setting a regular `Boolean` flag here).

```kotlin
var printing = false

fun printCharacters(str: String) {
    if (printing) return
    printing = true

    for (c in str) {
        println(c)
    }

    printing = false
}
```

You can easily pass in `null` as the parameter if you call this method from Java:

```java
public static void main(String[] args) {
    Printer().printCharacters(null);
}
```

This would cause an exception when the `for` loop attempts to iterate it. As the `printing` flag has already been set at that point, this would leave your application in a broken state, never being able to print anything again. (Assuming that you've handled the exception, and the method has a chance to be called again.)

To prevent this kind of unexpected failure, caused by the presumed safety that you had when you implemented the Kotlin method, the compiler performs additional null checks at runtime, by injecting code during compilation. These pieces of code, again, can be found by decompiling the bytecode:

```java
public final void printCharacters(@NotNull String str) {
    Intrinsics.checkParameterIsNotNull(str, "str");
    if (!printing) {
        printing = true;
        /* ... For loop ... */
        printing = false;
    }
}
```

Since these checks are performed immediately at the beginning of the function before any of your code is executed, a failing check throwing an exception means that it's as if the incorrect call never even happened. This prevents your application from ending up in an unexpected, invalid state by aborting execution somewhere halfway through your method.

These kinds of null checks, and many other utility methods are contained by the [`Intrinsics`](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Intrinsics.java) class. You'll see static calls to it all over decompiled bytecode: for values of parameters and fields, return values, when using the `!!` operator or `lateinit` variables, and more.

It's also worth noting that these checks will generate nicely formatted, specific exception messages, which is why you'll see identifiers, and sometimes even longer pieces of code being passed into them as strings (such as the name of the parameter in the example above).

## Summary

Nullability is a core part of Kotlin's type system. Types are all nullable or non-nullable. When operating on nullable values, the compiler enforces performing null checks.

Safe calls `?.` skip calls to methods if the reference they were (would have been) invoked on is `null`. The Elvis operator `?:` yields its left-hand value if that's not `null`, and the right-hand value otherwise. The `!!` operator is a quick way to throw an NPE.

`lateinit` takes the responsibility of checking nullability out of the compiler's hand, and is useful when working with frameworks.

Safe casts `as?` allow rewriting type checks to nullability problems.

By default, Java declarations show up with platform types in Kotlin, which are unsafe to use. This can be improved upon by using nullability annotations.

## Sources

- [Null is your friend, not a mistake - Roman Elizarov](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5)
- [Dealing with absence of value - Roman Elizarov](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903)
- Official documentation:
  - [Nullability](https://kotlinlang.org/docs/reference/null-safety.html)
  - [Calling Java from Kotlin](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#null-safety)

# Chapter 4: Functional Programming

In [chapter 2](2.md), we've looked at Kotlin's support for object-oriented programming. The other major paradigm that Kotlin supports is [*functional programming*](https://en.wikipedia.org/wiki/Functional_programming).

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside a class, they are just parts of classes - the larger, *more important* concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. This is how a mathematical function tends to work. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify that state.
  - Pure functions have many advantages, the most important one of these is perhaps *referential transparency*, which means that they always produce the same results for the same inputs. This makes it very easy to reason about them, and also facilitates testing.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code, as you have to keep thinking about the current state of the application as you're performing actions. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - Shared mutable state being accessed from multiple threads in an application is also a frequent source of bugs.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy` method generated for data classes. We'll find more of the same when we get to collection types in the next chapter.
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's [collection handling](./5.md#collection-processing), which we'll learn about later.

So when can a language declare that it's functional? Does it have to meet some, or all of the requirements above? Maybe even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

JetBrains' stance on the matter is that they consider the support for top-level functions the determining factor. This makes Kotlin a functional language, in addition to being object-oriented.

## Code organization

We've seen that Kotlin has top-level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

> Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin allows for top-level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of each file. Just like classes, other top-level declarations can be used in other packages by importing them.

> Unlike with Java, the packages that files reside in don't *have to* match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the source folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str == null || str.length == 0
}
```

Compiling this, we end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null || str.length() == 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix, leaking the implementation detail of these utilities being written in Kotlin:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/) annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

> In the previous code snippet, `@file` is an [annotation use-site target](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets). These are used to specify what exactly you want to apply an annotation to, when it would otherwise be ambiguous. For example, on a property declared in a primary constructor, you might want to annotate the parameter `@param:`, the property `@property:`, the backing field `@field:`, or the getter `@get:` of the property. This is useful sometimes when using Java-based tools with Kotlin code.

> In combination with `@JvmName`, you can also add the [`@JvmMultifileClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-multifile-class/) annotation to files. This lets you use the same `@JvmName` for multiple files, and all top-level declarations from those files will be combined into a single class in the bytecode!

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (types, really) that you don't own!

For example, if you need a quick and easy-to-read way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is specified before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* of the extension function.
- Invoking an extension has the same syntax as calling a real method of the class. If it's in a different package, it does have to be imported, like any other top-level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, these extensions are implemented as simple static functions on the bytecode level (top-level extensions, that is - member extensions are discussed [below](#member-extensions)).

If we decompile the bytecode from the code above, we'll see just that:

```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation. You can't implement anything with an extension that you couldn't implement in a function that takes the receiver as a parameter - you just get much nicer syntax.

> The [`CharSequence.last()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/last.html) function is actually part of the Standard Library.

---

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method defined in the `Cat` class is invoked. This feature - [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch) - is the basis of polymorphism, a core concept of object-oriented programming. It allows choosing the concrete implementation that is invoked at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the decision about which one to call has to be made at compile time (statically). At that time, all we know for certain is that we have an `Animal` instance. Any concrete `Animal` could (in theory) end up in that reference by the time we have to call `identify` at runtime. Therefore, the definitely-fitting overload is chosen out of our two static functions.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing many, many extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen can be done with the following API, which requires you to pass in a [`Context`](https://developer.android.com/reference/android/content/Context) object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context` itself (like an often-used Android [`Activity`](https://developer.android.com/reference/android/app/Activity)):

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide fewer parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension-oriented design

A significant amount of the functions in the Standard Library are defined as extensions. Many of them extend commonly used types, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on Standard Library types (which could be easily added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, allowing it to more easily change later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

It can be argued that the `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself could be just a data holder, which doesn't have any behaviour.

> This member function also prevents anyone from adding their own function named `traverse` as an extension, which might not be desirable. Members always take precedence over extensions in case of signature clashes.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order), or different actions during the traversal (e.g. draw the tree instead of printing its values to the console).

> What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This syntax is also useful if you want to conveniently use multiple classes with the same name, without having to fully qualify one of them everywhere in a file.

This pattern is referred to as [*extension-oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the Standard Library's collection processing functions, sequences, and coroutines.

> The `@JvmName` annotation mentioned earlier can also be used on individual declarations, like functions. For example, we could rename the `traverse` function above just for Java users by adding an annotation to it.
> 
> ```kotlin
> @file:JvmName("Utils")
>
> @JvmName("traverseNode")
> fun Node.traverse() { ... }
> ```
> 
> Usage from Java would now look something like this (while Kotlin usage remains unchanged):
> 
> ```java
> Utils.traverseNode(node);
> ```
> 
> This comes in handy when something makes sense in the context of Kotlin (for example, as the name of an extension function or an [operator](./8.md#operators)), but results in an odd-to-read call site from Java code, where it's the name of a static method. 

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be "computed" properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is available as `this`, as you might expect.

### Member extensions

Extensions may also be declared *inside a class* (or interface, or object) as a member. In these cases, the extensions behave differently from top-level extensions.

First of all, they will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence (in other words, the closer `this` scope):

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These member extensions are *not* static, instead, they are regular member functions under the hood. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

You can make these extensions `open` or `abstract`, and have subtypes implement them:

```kotlin
abstract class Validator {
    protected abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

While this is technically possible, it's often simpler to use regular functions that take the receiver as an explicit parameter.

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local (covered later, [in chapter 6](./6.md#local-functions)) extensions instead, if applicable.

### Context receivers

Context receivers are an [upcoming feature in Kotlin](https://kotlinlang.org/docs/whatsnew1620.html#prototype-of-context-receivers-for-kotlin-jvm), and they're essentially a variant of extension functions. 

They are currently available only as a prototype, and only on the JVM target, therefore we won't cover them here, other than to note their existence.

You can learn more about them in [this official Kotlin video](https://www.youtube.com/watch?v=GISPalIVdQY).

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun createGreeting(person: Person): String {
    return "Hello, ${person.name}"
}
```

This function takes a `Person` parameter, and returns a `String`. The type of this function is `(Person) -> String`. The function type that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val greetingCreator: (Person) -> String = ::createGreeting
```

Or declare the entire function in-line, and assign it to a variable with a function type immediately (this is very, very rarely used):

```kotlin
val greetingCreator: (Person) -> String = fun(person: Person): String {
    return "Hello, ${person.name}"
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `greetingCreator` function could be implemented in a lambda like this:

```kotlin
val greetingCreator = { person: Person -> "Hello, ${person.name}" }
```

This variable still has the same type as before (`(Person) -> String`), but we are now letting the compiler infer it based on the expression on the right-hand side.

To explain the syntax briefly: the braces `{}` create a new function literal. The input parameters of the function are listed at the very start, inside the braces. As usual, types come after names, and multiple parameters are separated by commas. Then, the `->` separates the parameter list from the body of the lambda.

Lambdas may contain multiple expressions, and they implicitly return their last expression, without a `return` keyword:

```kotlin
val greetingCreator = { person: Person ->
    println("Creating greeting for ${person.name}...")
    "Hello, ${person.name}"
}
```

This function, now defined as a lambda, can still be invoked the same way as before, as the type of the variable hasn't changed:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

If we provide the type of the variable that holds a lambda on the left-hand side, we can omit the type of the lambda's parameter, and let type inference work the other way:

```kotlin
val greetingCreator: (Person) -> String = { person -> "Hello, ${person.name}" }
```

For lambdas that have *only a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether (given that its type can be inferred from context). In this case, it will be available via the implicit name `it`:

```kotlin
val greetingCreator: (Person) -> String = { "Hello, ${it.name}" }
```

> It's common to see long, complex lambdas use this implicit `it` name for their parameter. Be wary of doing this - naming the parameter can go a long way towards increasing readability and avoiding mistakes of operating on the wrong object. A good rule of thumb is to use an explicit name when your lambda doesn't fit on a single line.

### Method references and bound references

We've seen references to top-level functions. You can also reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
val rebecca = Person("Rebecca")
speak(grace) // "Hi, I'm Grace!"
speak(rebecca) // "Hi, I'm Rebecca!"
```

References may also be bound to a specific instance, for example:

```kotlin
val claudia = Person("Claudia")
val speak: () -> Unit = claudia::speak
speak() // "Hi, I'm Claudia!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

> To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher-order functions

### Introduction

A *higher-order function* is a function that takes another function as a parameter or returns a function.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher-order functions, one that executes the function (i.e. a given piece of code) passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it at any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and the corresponding argument is a lambda, we can move that lambda outside the parentheses:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct, such as a `for` loop...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin lambdas on the JVM are implemented as anonymous classes, which implement certain interfaces. For example, the `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on. Here's the declaration of these two interfaces, *simplified* (you can always check out their [full source](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt)):

```kotlin
interface Function0<R> {
    fun invoke(): R
}

interface Function1<P1, R> {
    fun invoke(p1: P1): R
}
```

> These numbered function types only go up to `Function22`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with function types that have more than 22 parameters!

These functional interfaces - such as `Function1` - all define just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of interfaces like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand.

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

> `Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return `Unit.INSTANCE`, unlike with `void` methods, where you can simply omit the return statement.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java, however...

```java
repeat(3, (Function0)null.INSTANCE);
```

It turns out the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with for the time being. If we use a better decompiler (such as [jadx](https://github.com/skylot/jadx)), we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE = new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever created and used over the lifetime of our program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see there is this:

```java
repeat(3, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), which means they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(times, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to... But the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this might feel unsolvable at first, and needs some kind of workaround. In Kotlin, the code above compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This reference to the `ObjectRef` instance is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new `String` instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type for performance reasons - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

These aren't types you need to use yourself - the Kotlin compiler will deploy them as necessary when you capture values from outer scopes that you want to mutate. However, it's good to know that this happens, as it might cause memory leaks if you're not careful.

> If you're writing Java code, you can make use of this pattern manually to solve similar problems.

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions "for free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the following `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you'll see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant, as function calls are not too expensive in general. It's up to you to decide in each case whether inlining a certain function is worth it.

> If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be copied to the call site, bloating your compilation output.

Where inlining is definitely useful and often recommended is with higher-order functions, as it can get rid of allocations! Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the inline function. That sounds complex, but let's take a look at it in practice.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` present anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher-order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult-to-use APIs with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

> The [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) function is actually part of the Standard Library, so you shouldn't implement it yourself.

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside this `repeat` function (changed to be non-inline again!) on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function.

Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the lambda containing a `return` from `test` wouldn't make any sense!

> The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return from:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda?

Yes! The solution for this is to inline the `repeat` function. This way, we know that the lambda we pass to it will only be executed in place, within the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties for later use.

> TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context.

For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created will have no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val runnable = object: Runnable {
        override fun run() { 
            body()
        }
    }
    runnable.run()
}

fun test() {
    funky {
        // Return could not work here
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

Instead of this, we can use `crossinline`, which will still inline the lambda's contents (*inside* the `run` method of the `Runnable` being created), but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable runnable = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    runnable.run();
}
```

> TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

In general, you don't need to worry about remembering the exact mechanics of `noinline` and `crossinline`, as they are rarely used. But it's useful to know they exist so that you can look them up as needed. When you get into the special situations that require them while writing your own code, your IDE will most likely suggest adding them automatically.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

### Inline classes

You might find it odd that we're discussing a type of class here instead of in the earlier chapter about object-oriented programming. However, inline classes relate to two topics we've just covered: inline functions and typealiases. 

An inline class is a wrapper around a single value: it must have exactly one property in its primary constructor. At runtime, usages of the inline class will be replaced by just its contained value ([wherever possible](https://typealias.com/guides/inline-classes-and-autoboxing/) - same as usages of primitives). The idea for these classes is very similar to that of inline functions: allowing you to create extra constructs in your source code, but then eliminating runtime overhead by rewriting the code during compilation.

If your inline class wraps a primitive type, you'll even get all the [performance benefits of using a primitive](./1.md#primitives-vs-boxed-types) at runtime.

Let's take the example of a class that represents an RGB color value. To declare an inline class, we have to use both the `value` keyword and the `@JvmInline` annotation.

```kotlin
@JvmInline
value class Color(private val value: Int)
```

> The `@JvmInline` annotation might seem excessive - why not just `inline class` instead? Inline classes are just one small usages of a more general concept, *value classes*, which will get more support in Kotlin in the future. You can read about this in great detail in the [value classes KEEP document](https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md). 

Since this is a class, we can add properties and methods to it - with the limitation that it can't have properties that would require backing fields. Since the usage of this class is replaced at runtime with just a primitive `Int`, there would be nowhere to store such values.

We can still add properties without backing fields, for example, convenient accessors for each component of the color:

```kotlin
@JvmInline
value class Color(private val value: Int) {
    val red: Int
        get() = (value shr 16) and 0xFF
    val green: Int
        get() = (value shr 8) and 0xFF
    val blue: Int
        get() = (value shr 0) and 0xFF
}
```

The class is used the same way as any other: we can create instances via the constructor, and access members:

```kotlin
val myColor = Color(0x005FFF)
println(myColor.red)    // 0   (00)
println(myColor.green)  // 95  (05)
println(myColor.blue)   // 255 (FF)
```

However, if we decompile the bytecode that this usage of our inline class outputs, we'll see something like this (simplified here!):

```java
int myColor = Color.constructor-impl(24575);
System.out.println(Color.getRed-impl(myColor));
System.out.println(Color.getGreen-impl(myColor););
System.out.println(Color.getBlue-impl(myColor));
```

`myColor` is just a simple primitive `int` value, giving us great runtime performance. The methods and properties of the `Color` class are turned into static functions, which receive the `$this` value to operate on as a parameter (this "trick" should be familiar by now!):

```java
public static int getRed_impl(int $this) { return $this >> 16 & 255; }
public static int constructor_impl(int value) { return value; }
```

> This `Color` class could be improved by adding some range checks to its constructor (into an `init` block). Thanks to how inline classes work, that code would actually be invoked at runtime and could perform its task - even though no class instance is actually constructed.

While typealiases for the same type (and the original type itself) are cross-compatible, inline classes *create new types*, which means that this code won't compile:

```kotlin
val color: Color = 0 // e: The integer literal does not conform to the expected type Color 
```

Kotlin supports [unsigned numerical values](https://kotlinlang.org/docs/basic-types.html#unsigned-integers) such as `UInt` and `ULong`. Under the hood, these are implemented as inline classes as well, simply wrapping their signed counterparts! This way these unsigned types can also be represented as primitives when used on the JVM.

### SAM conversion, SAM constructor

Getting back to the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lack truly standard function types, so libraries usually introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner, often instantiated with lambda syntax.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

The compiler will perform the heavy lifting here, creating an object instance under the hood that implements `View.OnclickListener` and contains the code of the lambda inside the `onClick` method.

When the conversion would be ambiguous due to overloads, or you want to be more explicit about creating an instance, the slightly more verbose *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

> One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

### Functional interfaces in Kotlin

You can declare functional interfaces in Kotlin as well. These are marked not by an annotation (as the Java convention), but with a keyword instead: the `fun` keyword!

```kotlin
fun interface OnClickListener {
    fun onClick(view: View)
}
```

A functional interface can only have a single abstract method (but may have other, non-abstract methods as well). When you need to pass in an instance of such an interface somewhere, you can use the full object expression syntax, but you can also make use of SAM conversions or SAM constructors, exactly as seen in the previous section.

> Fun interfaces are a relatively new feature, available [since Kotlin 1.4](https://kotlinlang.org/docs/whatsnew14.html#sam-conversions-for-kotlin-interfaces). Previously, SAM conversions only worked for interfaces declared in Java, as it was specifically an interop feature for convenience. SAM conversion for Kotlin-declared interfaces was not supported, the reasoning being that you could just use function types in Kotlin instead of interfaces. However, there are times when using a dedicated interface type is more practical than using those function types.

## Summary

One of Kotlin's most advertised features is extensions, which allow you add new functionality onto existing types, even ones that you don't own yourself.

Functions are first-class citizens, just like classes or objects. They can be declared as top-level constructs in a file, and imported individually. Function types are a core part of the language, and they allow functions to be stored in variables, or passed around as parameters. Lambda expressions (function literals) are a concise way to define functions, especially if you're immediately passing them in as parameters.

Functions that take functions as parameters or return functions are called higher-order functions. The cost of passing function parameters to them (implemented as instances of classes under the hood) can be mitigated by making them inline. In certain situations, `noinline` and `crossinline` can come in handy.

Finally, Kotlin provides SAM conversion and SAM constructors as a way to interop with functional interfaces that are declared in Java code, and it also supports declaring functional interfaces.

## Sources

- Official documentation:
  - [Extensions](https://kotlinlang.org/docs/reference/extensions.html)
  - [Higher-Order Functions and Lambdas](https://kotlinlang.org/docs/reference/lambdas.html)
  - [Inline functions](https://kotlinlang.org/docs/reference/inline-functions.html)
  - [Type aliases](https://kotlinlang.org/docs/reference/type-aliases.html)
  - [SAM Conversions](https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions)
  - [Functional (SAM) interfaces](https://kotlinlang.org/docs/reference/fun-interfaces.html)
- [jadx - Dex to Java decompiler](https://github.com/skylot/jadx)

# Chapter 1: Introduction

Programming languages. There's a lot of them, and it could be argued that all of them have their uses, their pros and cons.

There are things however that are generally considered positive attributes for languages, and many modern languages are converging in terms of these attributes. During this course, we'll be studying Kotlin, which is a great example of a modern, well-rounded language, but you'll see many similar features and ideas in other languages such as Swift, C#, or Groovy, just to name a few examples.

Why should you start using Kotlin specifically, out of all these languages? Its creators often say that they don't really want to push Kotlin on anyone, they want it to speak for itself. It's a pragmatic language, which they believe solves real problems. Try it, see if it solves problems that you're facing in other languages, and if that's valuable for you. And there really is no substitute for seeing what it's like to use in practice.

The creators also proudly admit that almost none of the features in Kotlin have been invented from scratch. We all stand on the shoulders of giants, there's nothing new under the sun, and [everything is a remix](https://www.youtube.com/watch?v=nJPERZDfyWc). Great creations always take existing pieces of work, and then copy, transform, and combine them into something new. Creating a language is no different from your everyday coding in this regard.

> The original lead language designer for Kotlin, Andrey Breslav gave an [excellent talk](https://www.youtube.com/watch?v=7z_K-hTTeqI) on this in May 2022. Best watched once you're already familiar with Kotlin.

What does make Kotlin unique is how well its features fit together, and what features were omitted on purpose, because they would have broken the language's consistency, or go against its core tenets.

So what are some of these desired attributes that Kotlin aims to achieve?

- **Conciseness**, i.e. less code for expressing the same ideas. Not for the sake of conciseness itself, but to improve **readability** compared to more verbose languages. Not having to write [boilerplate code](https://en.wikipedia.org/wiki/Boilerplate_code) makes coding faster, and more importantly, not having that boilerplate in your codebase makes navigating and reading your existing code a lot easier.
- **Safety** means that your program misbehaves as little as possible. There's various ways to achieve such safety at the language level. Kotlin does this by having a *strong, static type system*, which reveals most mistakes at compile time (at edit time, really, in almost all cases), rather than letting your code fail at runtime.
- **Interoperability** is another driving principle of Kotlin. It runs on multiple platforms, and on each of them it cooperates with the native environment and libraries as much as possible. We'll look specifically at how it interops with Java when running it on the JVM.
- **Pragmatism** is a way of saying that Kotlin is not an academic language. It's meant for use in real industrial settings, and to solve real, practical problems.
- **Tooling** is something you might overlook at first when evaluating languages, but it's something that can make a good language a true pleasure to use. While there are still proud Vim warriors out there, most developers are used to using rich IDEs for their coding needs, and Kotlin's tooling is as first-party as it gets.

This brings us to Kotlin's origin story.

## History

[JetBrains](https://www.jetbrains.com/), the company behind the IntelliJ platform (and [all the IDEs that are built on it](https://www.jetbrains.com/products/#type=ide-vs), such as IntelliJ IDEA, Android Studio, CLion, PyCharm, and so on) has been developing their products in Java for a decade by 2010. During this time, they've built up immense experience in creating tooling for programming languages, and they also got very familiar with Java's pros and cons.

It was at this time that they started looking for a new language for their own development needs that was better than Java. They've evaluated the existing languages that ran on the Java Virtual Machine (JVM), but they didn't find one at the time that would've satisfied their needs.

>The closest candidate at the time was Scala, but it was notoriously difficult to make tooling for, and it suffered from lengthy compilation times.
 
So they've done what anyone else would've done at this point - created their own.

This, in general, is not a great idea - it's akin to writing your own date library or rolling your own crypto. But with the tooling and language expertise of JetBrains, as well as their strong market position, they've deemed it a viable project, and got started on it.

Some highlights of the language's development:

- 2010: internal development started under the name "JetLang".
- July 2011: [announced to the public](https://blog.jetbrains.com/kotlin/2011/07/hello-world-2/) as Project Kotlin.
- February 2016: [Kotlin 1.0](https://blog.jetbrains.com/kotlin/2016/02/kotlin-1-0-released-pragmatic-language-for-jvm-and-android/), the first stable release.
- March 2017: [version 1.1](https://blog.jetbrains.com/kotlin/2017/03/kotlin-1-1/), the first major feature update to Kotlin, with initial JavaScript support.
- May 2017: first-class Android support for Kotlin announced at Google I/O.
- November 2017: [version 1.2](https://blog.jetbrains.com/kotlin/2017/11/kotlin-1-2-released/), with the first version of multiplatform projects.
- October 2018: [version 1.3](https://blog.jetbrains.com/kotlin/2018/10/kotlin-1-3/), containing stable coroutines.
- May 2019: Android development going [Kotlin-first](https://developer.android.com/kotlin/first) announced at Google I/O.
- August 2020: [version 1.4](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/), introducing the foundations for a new compiler, and some neat new language features.
- May 2021: [version 1.5](https://blog.jetbrains.com/kotlin/2021/05/kotlin-1-5-0-released/), stabilizing inline classes, adding improvements to sealed types, and stabilizing the new JVM compiler backend.
- November 2021: [version 1.6](https://blog.jetbrains.com/kotlin/2021/11/kotlin-1-6-0-is-released/), with a preview of the new Kotlin/Native memory model, exhaustive when statements, type inference improvements, and lots of new stable Standard Library APIs.
- June 2022: [version 1.7](https://blog.jetbrains.com/kotlin/2022/06/kotlin-1-7-0-released/), with the new K2 compiler available in alpha, , and yet again many new stabilized language features.  

> Watch [Ten Years of Kotlin: The Story of The Programming Language](https://www.youtube.com/watch?v=uE-1oF9PyiY), a documentary about the language made for its 10-year anniversary.

> Read the blog post from Google [celebrating 5 years of Kotlin on Android](https://android-developers.googleblog.com/2022/08/celebrating-5-years-of-kotlin-on-android.html).

Let's take a moment to review some of the previously mentioned language attributes, with this history now in mind:

- **Interoperability**: JetBrains had hundreds of thousands of lines of Java code in IntelliJ that they could never just throw away. The new code written in Kotlin and the old code written in Java had to be able to communicate efficiently and effortlessly.
- **Pragmatism**: The language was born to serve a specific need, a real industrial project.
- **Tooling**: Language and tooling could be developed side-by-side, in-house, and complement each other perfectly.

Who's using the language? A very rapidly rising number of developers - millions, by now (see [2018 stats](https://youtu.be/PsaFVLr8t4E?t=366), [2020 stats](https://youtu.be/pD58Dw17CLk?t=200)). [(About 6 million as of August 2020.)](https://blog.jetbrains.com/kotlin/2020/08/kotlin-1-4-released-with-a-focus-on-quality-and-performance/#compiler-and-ecosystem) 

What are they using the language for? A lot of the focus is on Android development, but Kotlin has a lot of traction outside of mobile too. You can take a look at the [Kotlin Census (2020)](https://www.jetbrains.com/lp/kotlin-census-2020/) or the [State of Developer Ecosystem survey (2021)](https://www.jetbrains.com/lp/devecosystem-2021/kotlin/) ran by JetBrains for some official statistics.

Kotlin is an open-source language. Everything around it - the compiler, the standard library, docs, and so on - are available [on GitHub](https://github.com/jetbrains/kotlin). JetBrains isn't the sole owner and controller of the language, its development is governed by the [Kotlin Foundation](https://kotlinlang.org/foundation/kotlin-foundation.html), co-founded by JetBrains and Google.

Being an open source project, it's rare that surprise product announcements for Kotlin appear, as everything is developed out in the open in the first place. You can take a look at what's planned to be coming up for Kotlin in the next few months (or years) on the [Kotlin roadmap](https://kotlinlang.org/roadmap.html).

## Compilation

Kotlin now positions itself as a modern, multiplatform [application programming language](https://medium.com/@elizarov/application-programming-language-ff7f0063c16). Its original and primary target is the JVM, but Kotlin code can also be compiled to [JavaScript](https://kotlinlang.org/docs/js-overview.html), and even [native](https://kotlinlang.org/docs/native-overview.html) binaries.

In this course, we'll focus on using Kotlin on the JVM. When compiling `.kt` Kotlin sources, the output here is *bytecode* in the form of `.class` files - the same as when compiling Java code.

![Compiling Java or Kotlin to bytecode.](./images/1_kotlin_and_java_basic_compilation.png)

What makes this compilation interesting is the strong interoperability between Kotlin and Java. Code written in one language can call into the other one completely seamlessly. So how can this work out during compilation, if we need to compile Java and Kotlin with their respective compilers? How would the Java compiler know about declarations in Kotlin sources, and vice versa?

Here's how the compilation actually works ([credits to Jake Wharton](https://youtu.be/CtZL_IjR5Ww?t=378)):

![Compiling Java and Kotlin, interop details](./images/1_kotlin_and_java_interop_compilation.png)

The Kotlin compiler, `kotlinc` runs first, and it parses both Java and Kotlin sources. This allows it to compile Kotlin code that references declarations in the Java sources. Next, the Java compiler `javac` is invoked. This again parses the Java sources, plus it receives the output of the Kotlin compiler as already compiled bytecode, which is what allows Java sources to reference Kotlin declarations. Finally, the merged output of these two compilers is bytecode in `.class` files.

## Tooling and environment

Unsurprisingly, JetBrains works very hard to provide the best possible tooling for Kotlin. After all, this is their business angle with the language: building products with it, and selling the tooling for it.

Therefore, [IntelliJ IDEA](https://www.jetbrains.com/idea/) is the definitive IDE for Kotlin development, although other editors support it as well. You can also download the Kotlin compiler and [compile it from the command line](https://kotlinlang.org/docs/command-line.html), if that's your thing.

> [Android Studio](https://developer.android.com/studio) is based on IntelliJ IDEA and offers the same support for Kotlin (although new features from IDEA take a while to trickle down to Studio releases).

Most non-trivial JVM projects use build tools instead of invoking the compiler directly. Kotlin supports both [Maven](https://kotlinlang.org/docs/maven.html) and [Gradle](https://kotlinlang.org/docs/gradle.html), which are the popular build tools in the JVM world. Gradle, which also happens to be the de-facto build system for Android projects, is generally preferred.

> You can even write your Gradle build scripts [in Kotlin](https://docs.gradle.org/current/userguide/kotlin_dsl.html).

IntelliJ has a suite of convenient tools built-in for working with Kotlin. Let's take a quick look at each of these before we get to the code.

### Scratch files

[Scratch files](https://www.jetbrains.com/help/idea/scratches.html) are temporary files that you can use to quickly write and run Kotlin code. They are not associated with any project, and they reside outside your project directory, so they won't be under version control, but only stored locally.

![A simple Kotlin scratch file](./images/1_scratch_file.png)

Despite this, you can reference code in your current project from a scratch file, if you need to. You can create instances of classes, call existing functions, and so on. This makes it really, really easy to perform quick experiments.

To create a scratch file, go to *File -> New -> Scratch File*.

### REPL

Read-Eval-Print Loops, or REPLs, are usually a tool for scripting languages. They allow you to write and execute code line by line, to quickly iterate and try out various things in the language. 

Kotlin comes with this tool as well, which you can either run from the command line, or right inside IntelliJ IDEA (*Tools -> Kotlin -> Kotlin REPL*). Just like with scratch files, you can call into code in your currently open project from the REPL.

![The Kotlin REPL](./images/1_repl.png)

### Decompiler

Sometimes the easiest way to understand what a certain piece of Kotlin code does is to look at what it compiles to. The bytecode that the compiler will output for a given Kotlin source file can be viewed by going to *Tools -> Kotlin -> Show Kotlin Bytecode*.

![The Kotlin bytecode viewer](./images/1_bytecode_viewer.png)

While this can help you figure out what's happening in some cases, most people can't read bytecode very well (nor should they be required to), so there's an even more important feature here. You can decompile this bytecode to Java by choosing the *Decompile* option on the bytecode viewer panel.

![Decompiled Kotlin bytecode](./images/1_decompiled.png)

This gives you a Java source file, which is an attempt at writing Java code that would result in the same compilation result. Keep in mind that this is a best effort step, and not all the bytecode that the Kotlin compiler produces can be represented by Java code in a straightforward way. Most of the time, this decompiled Java code will contain at least a few errors. Still, the decompiler is a very useful tool for gaining a deeper understanding of Kotlin.

### Java-to-Kotlin converter

The Kotlin plugin IntelliJ IDEA also ships with a feature that lets you go the other way around: take existing Java code, and automatically convert it to Kotlin. This comes in really handy when migrating a project to Kotlin. 

![Example of Java-to-Kotlin conversion](./images/1_java_to_kotlin.png)

> You'll find this action under  *Code -> Convert Java File to Kotlin File* when you have a Java file open.

Keep in mind that just like the decompiler, this isn't a perfect tool either. Occasionally the converted Kotlin code won't compile straight away, or it will have some bugs in it. Often it might be messy, Java-like, and require some cleanup to make it more _idiomatic_ Kotlin. But it's usually a good start.

The best use of this feature is perhaps for learning purposes. If you don't know how to express something in Kotlin, but you can write it down in Java, you can always run it through the converter! Again, this might not give you the best possible Kotlin solution, but it'll at least give you one.

> Bonus: pasting Java code into a `.kt` file will also prompt you about converting that code into Kotlin while the paste operation is happening.

## Basic syntax

### Variables

Let's take the first thing you'd want to do in a language, and declare a variable!

>Note: In the beginning, we'll look at the Java equivalents of the Kotlin code in case you need them for reference. Remember, Kotlin *does not* actually compile to Java!

```kotlin
var x: Int = 0              // int x = 0;
```

Let's take note of a couple things:
- You declare variables with the `var` keyword.
- The variable name *precedes* the type.
- Semicolons are... allowed, but optional (in practice, this means that you won't use them).

You should only use `var` when you explicitly want a *mutable* **var**iable.

If that's not the case, use `val` instead, which declares an *immutable* **val**ue.

```kotlin
val y: Int = 1              // final int y = 1;
```

That's better. When declaring variables, `val` should be your default choice.

We can make another improvement to this declaration, by making use of *type inference*.

```kotlin
val z = 2                   // final int z = 2;
```

Kotlin is statically typed and has a very strong, strict type system. This variable is still has a type of `Int` just like before, but you can omit the type from your code, as the compiler can *infer* it itself from context (in this case, from the value being assigned). You'll see a lot of this happening in Kotlin code.

This mechanism means you'll never type out something as verbose as this again:

```java
final FileInputStream fis = new FileInputStream("filename");
```

Instead, you'll have the Kotlin compiler figure out the type for you in almost all cases:

```kotlin
val fis = FileInputStream("filename")
```

> Note: You may also notice here that there's no `new` keyword in Kotlin for constructor calls.

The simple number literal we had before was inferred to be an `Int`, but you can also use special formats to create other basic numerical types:

```kotlin
val myLong = 1L             // final long myLong = 1;
val myFloat = 1f            // final float myFloat = 1;
val myDouble = 1.0          // final double myDouble = 1;
```

#### Primitives vs boxed types

Java - and the JVM itself - makes a distinction between primitive types and boxed types. Primitives (`int`, `double`, `boolean`, and so on) are much more efficient, as they live on the stack, and only take up the space required to represent them.

The corresponding boxed classes (`Integer`, `Double`, `Boolean`, and more) are reference types, so only references to them are stored on the stack, and their actual instances live on the heap. These instances are also larger than the primitive's size, [sometimes significantly](https://dzone.com/articles/whats-wrong-with-java-boxed-numbers).

Using the primitives is sufficient in most cases, but sometimes the boxed variants are still required. This can happen when you *need* an object for some reason, for example when dealing with generics (there's no `List<int>` in Java!). The boxed instances also have various methods you can call on them, which you can't do with a primitive value.

So where does Kotlin's `Int` (and `Boolean`, and `Double`, and other numeric types) fit in this picture? Well, just like `Int` is sort of between `int` and `Integer` by its looks, its semantics lie somewhere in the middle as well. On the Kotlin language level, we don't make a distinction about primitives and boxed types. The compiler will use a primitive whenever it's possible, and use a boxed type automatically when it needs to.

This doesn't exactly mean that we *never* have to think about this problem, because the performance considerations of what happens under the hood are still important in some cases - but we won't use different types to represent these things in our code.

#### Strings

The last basic type that's worth mentioning here is `String`, which behaves much like a `String` in Java. A literal is declared with quotation marks:

```kotlin
val name = "Sarah"           // final String name = "Sarah";
```

Kotlin also supports *string templates*, which is an easy way to place values inside a `String`, without having to use lots of concatenation:

```kotlin
val sum = "$x + $y + $z = ${x + y + z}"     // outputs "0 + 1 + 2 = 3"
```

Single values can be inserted with just a `$` prefix, and expressions can be computed using additional curly braces `${...}`.

### Functions

#### Our first function

Let's move on to functions, something we'll discuss *a lot* in Kotlin. First, we'll convert this very simple function - which just adds two numbers together, and returns the result - to Kotlin.

```java
int add(int x, int y) {
    return x + y;
}
```

Here's a Kotlin equivalent of this code:

```kotlin
fun add(x: Int, y: Int): Int {
    return x + y
}
```

Some important observations about the syntax:

- We use the `fun` keyword to declare a function. (Yay! 🎉)
- The names precede the types in the parameter list, just like we've seen with variables.
- The return type comes after the rest of the function header as well, following the `name: Type` structure yet again.

For functions as simple as this one, that only evaluate a single expression and return its value, Kotlin offers a shorthand syntax called an *expression body*:

```kotlin
fun add(x: Int, y: Int): Int = x + y
```

Type inference can also be used here, since the type of the `x + y` expression, an addition of two `Int` values is known by the compiler to be an  `Int`:

```kotlin
fun add(x: Int, y: Int) = x + y
```

This function still returns `Int`, but we aren't stating this explicitly.

> Use expression bodies with care, only when the function's implementation is truly a simple one-liner. Otherwise, don't be afraid of using a traditional function body.

#### Functions that don't return anything

There's another case where the return type can be omitted, this is when the function doesn't return anything. This is equivalent to a function having a `void` return type in Java.

```kotlin
fun noReturnValue() {
    /* Empty */
}
```

Technically, functions like this still do return *something* in Kotlin. The language doesn't have the super special case that Java has with `void` functions. Functions where you don't return a meaningful value - like the one above - will implicitly have a return type of `Unit`. You can also write this out explicitly, although the IDE will warn you that it's unnecessary.

```kotlin
fun noReturnValue(): Unit {
    /* Empty */
}
```

`Unit` is an empty class that has a single instance. It's a dummy object with no properties or methods. This makes it perfect for representing "no meaningful value". Returning this from methods like the one above yields some... interesting possibilities. For example, you can assign the return value of this function to a variable, just like you could with any other function that returns any regular type.

```kotlin
val result: Unit = noReturnValue()
println(result) // kotlin.Unit
```

Again, there's no hard distinction between functions that do return something, and functions that don't. If there's nothing to return, we're indicating that by returning `Unit` implicitly (both the declaration of the return type and the actual `return` statement at the end of the function may be implicit).

We'll see that this type also plays well with generics. We won't need the weird distinction that Java makes between `void` and `Void`, we'll just use `Unit` for everything. But we're getting ahead of ourselves. Spoilers!

#### Default and named parameter values

Functions come with some neat new features in Kotlin compared to Java functions. One of these is [*default arguments*](https://kotlinlang.org/docs/functions.html#default-arguments).

> *Arguments* are the concrete values passed in for the *parameters* that a function declares. However, the words "argument" and "parameter" are often used interchangeably.

To demonstrate, let's write a function that mimics the registration of a user.

```kotlin
fun register( 
    username: String, 
    password: String = "12345678", 
    email: String = "",
) {
  // Pretend that there's something useful here.
  println("$username $password $email")
}
```

This function takes three parameters, and it defines default argument values for the last two. Note the formatting of each parameter on a separate line, this is conventional in Kotlin for functions with long signatures.

> Since Kotlin 1.4, Kotlin allows [trailing commas](https://kotlinlang.org/docs/reference/whatsnew14.html#trailing-comma) in places like parameter lists. You might have noticed this in the previous snippet. This makes it easier to rearrange lines (even in simple text editors), and also makes version control history neater.

Having these default arguments in place means that we can call this method with three, two, or just one argument. For any parameters that are not provided, the default value will be used instead.

```kotlin
register("piglet", "0h_d34r", "piglet@hundred-acre-wood.co.uk")
register("owl", "tea_party")
register("eeyore")
```

Another feature that works nicely in conjunction with default values is [*named arguments*](https://kotlinlang.org/docs/functions.html#named-arguments). For any function defined in Kotlin, you can optionally specify the names of the arguments when you call the function. Our previous calls could be made like this (note the formatting of the lengthy call, on multiple lines):

```kotlin
register(
    username = "piglet",
    password = "0h_d34r",
    email = "piglet@hundred-acre-wood.co.uk"
)
register(username = "owl", password = "tea_party")
register(username = "eeyore")
```

Naming arguments - especially in cases like this where several of the same type are being passed in - can help us avoid mixing up their order, making the code safer. It also improves readability, as which argument fulfills which parameter is immediately clear at the call site.

Combined with default values, we can also use this to omit arguments that have default values, but are not at the end of the parameter list:

```kotlin
register("tigger", email = "tigger@hundred-acre-wood-co.uk")
```

Here, we're passing in a value for `email`, but opting to use the default value for the `password` parameter.

> By default, Java clients of a Kotlin function with default arguments must provide all arguments, and can't make use of the default arguments. However, you can add the [`@JvmOverloads`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-overloads/) annotation to improve interoperability:
>
> ```kotlin
> @JvmOverloads
> fun register( 
>     username: String, 
>     password: String = "12345678", 
>     email: String = "",
> )
> ```
>
> This will generate overloaded methods that are callable by Java clients. For each parameter with a default value (starting from the end of the parameter list), a new method will be generated, which omits that parameter, and uses the default value for it instead.
>
> ```java
> register("kanga");
> register("kanga", "roo");
> register("kanga", "roo", "kanga.and.roo@hundred-acre-wood.co.uk");
> ```
>
> Note how this makes parameter ordering quite important, as parameters can only be omitted from the end of the list. For example, you could not omit just the second `password` parameter when calling from Java. Make sure you're placing your most-defaulted parameters as far back in the parameter list as possible!
>
> We'll take note of similar interop features along the course. There's also a dedicated [documentation page](https://kotlinlang.org/docs/java-to-kotlin-interop.html) covering these.

### Control structures

Let's continue with the basics and get to know our control structures. Most of these will be familiar already, so you'll have no problem getting started with them, but Kotlin does offer some extra capabilities here that are worth knowing about.

#### Conditionals

The classic `if` statement is available in Kotlin just like you'd expect:

```kotlin
if (age < drinkingAge) {
    println("We can't serve you")
} else {
    println("Have a beer")
}
```

It comes with the exciting twist of being not only a statement, but also an *expression*, i.e. it has a return value. This return value is whatever the last expression is in the branch that was executed.

```kotlin
val discount = if (age < adultAge) {
    println("Calculating discount")
    val diff = adultAge - age
    100 - diff * 5
} else {
    println("No discount available")
    0
}
```

If you omit the braces, you get a very concise syntax for these expressions:

```kotlin
val max = if (a > b) a else b
```

For this reason, the so-called ternary operator (`a > b ? a : b`) is not present in the language (see [detailed discussion](https://youtrack.jetbrains.com/issue/KT-5823) and [conclusion with explanation](https://www.youtube.com/watch?v=0FF19HJDqMo&t=1357s)).

#### Switches get ~~stitches~~ improvements

The well-known `switch` statement is an interesting control structure. Many languages (Scala, Swift, or C#, just to mention a few) have taken it beyond its original capabilities by adding *pattern matching* of various kinds to it. Even Java [got some upgrades](https://openjdk.java.net/jeps/361) to its `switch` in Java 14.
  
How does Kotlin measure up? Like in most times when it's compared on a scale from Java to Scala, it's somewhere in the comfortable middle.

Kotlin's replacement for the `switch` is the `when` expression. First of all, it does the things that you expect a regular `switch` to do, with slightly different syntax:

```kotlin
val grade: Int = getGrade()
when (grade) {
    1 -> {
        println("Failed")
    }
    2 -> { println("Adequate") }
    3 -> { println("Average") }
    4 -> { println("Good") }
    5 -> { println("Excellent") }
    else -> {
        /* "This shouldn't happen" */
        throw RuntimeException("Invalid grade!")
    }
}
```

Instead of cases, `when` features branches, which follow whatever value it matched. There is no fall-through between these branches, so there's no need to `break` at their end. Instead of a `default` case, you can use `else` to indicate the branch that should be executed if none of the others have matched.

It also has some more advanced features:

```kotlin
when (val rating = calculateRating()) {
    0 -> {
        println("Terrible")
    }
    1, 2, 3 -> println("Bad")
    in 4..6 -> println("Average")
    in 7 until 10 -> println("Good")
    10 -> println("Perfect")
}
```

In this example, you can see that:

- You can declare the variable that you're performing the check against in the argument of `when` ([since Kotlin 1.3](https://kotlinlang.org/docs/reference/whatsnew13.html#capturing-when-subject-in-a-variable)). This variable will only be accessible within `when`'s body, neatly limiting its scope.
- You can list multiple values that will execute the same branch when one of them matches.
- If your branch is a single expression, you can omit the curly braces.
- You can perform containment-in-`Range` checks.

---

Of course, `when` is an expression too, which means that it can be used to return a value - the last expression of whatever branch was executed. This can reduce code duplication when all branches perform the same action with, for example, a different argument:

```kotlin
val description = when (grade) {
    1 -> "Failed"
    2 -> "Adequate"
    3 -> "Average"
    4 -> "Good"
    5 -> "Excellent"
    else -> {
        // "This shouldn't happen"
        throw RuntimeException("Invalid grade!")
    }
}
println(description)
```

In this case, the `else` block is mandatory, because without it we could run into a scenario where none of the branches were executed, and we have nothing to assign to the variable that the result of `when` is to be stored in.

Exhaustive branches (either all cases covered, or an `else` branch present) are also required in some other cases, such as when the argument to `when` is a `Boolean` value. For example, take the following code:

```kotlin
val enabled = false
when (enabled) {
    true -> println("Enabled!")
}
```

This produces an error:

```
'when' expression must be exhaustive, add necessary 'false' branch or 'else' branch instead
```

The same requirement applies when the argument is an enum value or a sealed class - we'll cover both those features in the [next chapter](2.md).

---

Finally, it's worth noting that `when` can also be used without an argument, as a replacement for a long `if-else if` chain. In this case, each branch has a condition that evaluates to a `Boolean`, and the first one to evaluate to `true` will execute its branch.

```kotlin
when {
    x < 40 -> println("x is too small")
    y in 0..50 -> println("y is in invalid range")
    x % y == 0 -> println("y should divide x")
    !check1(x, y) || !check2(x, y) -> {
        println("x and y didn't pass advanced validation")
    }
}
```

We'll see even more of `when`'s powers later when we get to enums, classes and typechecks.

#### Exceptions

Exceptions in Kotlin are handled using a `try-catch` block (with an optional `finally` clause):

```kotlin
db.open()
db.beginTransaction()
try {
    db.insert(Customer(name = "Ann", balance = 1_000_000))
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
} finally {
    db.close()
}
```

> Note how underscores can be used to break up long number constants and improve readability.

As you might expect at this point, `try-catch` is also an expression, and it returns the last expression in the `try` branch if nothing is thrown from that branch, and the last expression of the `catch` branch otherwise:

```kotlin
val input: String = readUserInput()
val value: Double = try {
    input.toDouble()
} catch(e: NumberFormatException) {
    0.0
}
```

> Note that instead of using [`Double.parseDouble`](https://docs.oracle.com/javase/8/docs/api/java/lang/Double.html#parseDouble-java.lang.String-) and similar methods, Kotlin offers methods on the `String` type that let you easily convert them to other types, such as [`toDouble`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-double.html) or [`toInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/to-int.html).

One last notable design choice here is that there are *no checked exceptions* in Kotlin. This means that there's no requirement of declaring what exceptions a given function may throw, and you're not forced to handle non-`RuntimeExeptions` by the compiler either.

This choice was made based on the experience that Java's checked exceptions did a lot more to inconvenience developers than to actually improve the safety of code, and often resulted in just empty `try-catch` wrappers around functions that declared exceptions being thrown from them.

> For Java interoperability, you can annotate functions with [`@Throws`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-throws/) to specify what exceptions they can throw, and force Java callers to handle those exceptions.
> 
> ```kotlin
> @Throws(IOException::class)
> fun readScoresFromDisk() { /* Disk reading things */  }
> ```
> 

#### Loops

Last but not least, let's talk about loops. `while` and `do-while` loops have nothing special about them. They check a condition at the beginning or end of the loop respectively, and run until their condition evaluates to `true`.

```kotlin
val entries = ...
while (entries.hasNext()) {
    println("Entry: ${entries.next()}")
}
```

`for` loops, on the other hand, are more interesting. The C-style `for` loop with three parts in its header separated by semicolons is not present in the language. Instead, anything that can provide an `Iterator` can be iterated with `for` loops.

> We'll explore what makes an object compatible with usage in a `for` loop in [later](./8.md#iteration).

For example, here's how you can iterate over a list of numbers, created with the [`listOf`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/list-of.html) factory function:

```kotlin
val myNumbers = listOf(1, 2, 5, 14, 42, 132, 429)
for (number in myNumbers) {
    println(number)
}
```

But what if we just want to iterate on numbers, for example from 0 to 10? It would be very wasteful to create a `List` and fill it up with elements just to get a simple loop. (We'd also be inclined to write the same `for` loop to populate the list with these numbers...)

Here's where the concept of a `Range` comes in. We'll explore these in detail [later](./8.md#custom-ranges), but the basic idea is that the syntax `0..10` creates a `Range` from 0 to 10. This creates a closed range, which includes both its lower and upper bound.

This range can provide an iterator that can be used with a `for` loop:

```kotlin
for (i in 0..10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 10 
```

> It might seem wasteful to create this `Range` object and then an `Iterator` of some kind just to loop through numbers like this. Worry not, this is optimized by the compiler, and we'll inspect what happens under the hood [in a later chapter](./8.md#performance-of-built-in-ranges).

What if we wanted to iterate slightly differently, excluding the upper bound of the range? This is common when we want to iterate valid indexes of a collection, for example. We can create a half-open interval using the `0 until 10` syntax:

```kotlin
for (i in 0 until 10) {
    print("$i ")
} // 0 1 2 3 4 5 6 7 8 9 
```

Other ways to create ranges include `downTo` which lets you create a descending range, and `step`, which lets you progress in larger increments at a time (this option can be added on to any range):

```kotlin
for (i in 10 downTo 1 step 2) {
    print("$i ")
} // 10 8 6 4 2
```

## Summary

Kotlin is a modern language with a strong, static type system. It aims to achieve readability, safety, and interoperability with all the platforms that it targets. The creators of the language are JetBrains, who also ship all the tooling for the language in IntelliJ IDEA.

Variables are declared with `val` or `var`, functions with `fun`. Types are declared *after* identifiers. Functions come with many conveniences: expression bodies, named and default parameters are a few of the basic ones. Kotlin features most common control structures, and most of them can be used as expressions. `when` is an advanced replacement for a `switch`. `try-catch-finally` works as expected, and there are no checked exceptions. `for` loops work on anything that's iterable, for example on `List` and `Range` objects.

## Sources

- [KotlinConf 2018 - Conference Opening Keynote by Andrey Breslav](https://youtu.be/PsaFVLr8t4E?t=120)
  - Goals of Kotlin, often misunderstood
- [It's a Kotlin, Kotlin, Kotlin World - Jake Wharton - Londroid 2017 @Telegraph Engineering](https://youtu.be/CtZL_IjR5Ww?t=378)
  - Explanation of the interaction between the Java and Kotlin compilers.
- Official documentation
  - [Getting Started with IntelliJ IDEA](https://www.jetbrains.com/help/idea/get-started-with-kotlin.html)
  - [Running Code Snippets](https://kotlinlang.org/docs/run-code-snippets.html)
  - [Using Gradle](https://kotlinlang.org/docs/gradle.html)
  - [Basic Syntax](https://kotlinlang.org/docs/basic-syntax.html)
  - [Basic Types](https://kotlinlang.org/docs/basic-types.html)
  - [Control Flow](https://kotlinlang.org/docs/control-flow.html)
  - [Functions](https://kotlinlang.org/docs/functions.html)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/java-to-kotlin-interop.html)

# Chapter 2: Object-Oriented Programming

Continuing with the "just like Java but better" angle, we'll now take a look at how Kotlin approaches object-oriented code. While [Java is clearly and strictly an object-oriented language](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html), the same can not be said for Kotlin. We'll see later on that it supports more than just this one paradigm. For now though, let's see how Kotlin does OOP.

### Classes 101

It only makes sense to start with the simplest possible class:

```kotlin
class Person
```

This is what an empty class looks like in Kotlin. Classes usually have bodies bounded by curly braces `{}`, but these can be omitted if the body of the class is empty - which will happen in Kotlin more than you might think.

Classes have two kinds of constructors - we'll deal with *primary constructors* first. These are declared right in the header of the class, and simply list the parameters you need to construct a class:

```kotlin
class Person(name: String, age: Int)
```

Just adding these parameters doesn't make much sense, we'd at the very least want to store them somewhere, so that we can work with them later. In Java, we'd use fields for this. In Kotlin, we'll use *properties* instead, which is a higher level concept. We can create a property with either the `val` or `var` keyword, just like a local variable. Similarly to local variables, a `val` is a read-only property, while a `var` is a read-write property.

```kotlin
class Person(name: String, age: Int) {
    val name: String
    var age: Int
}
```

This code won't compile yet, as our properties are not initialized. Therefore, constructing an instance of `Person` wouldn't be safe: what would happen when someone reads the value of `name` or `age`?

There are two ways of initializing this property within the body of the class. It can either be done at its declaration, or inside an *initializer block*, which is executed when the class is constructed:

```kotlin
class Person(name: String, age: Int) {
    val name: String = name
    var age: Int

    init {
        this.age = age
    }
}
```

Since taking a parameter in the constructor and saving its value to a property with the same name is such a common pattern, there's shorthand syntax for this. You can merge the declarations of the property and the constructor parameter, as well as the property's initialization by adding `val` or `var` directly in the primary constructor:

```kotlin
class Person(val name: String, var age: Int)
```

This is used extensively in Kotlin classes.

### Properties

We've seen that properties can be declared either in the primary constructor, or in the body of the class.

Let's take the following example of using the class that we've created:

```kotlin
fun main() {
    val person = Person("Mandy", 41)
    println(person.name)
    person.age = 42
}
```

It would seem like this class doesn't follow the encapsulation rules of OOP - from this syntax, it seems like we're accessing the data stored in the class directly. That would be the case if this was a Java class and these were fields, however, we have *properties* here.

Properties are a higher level concept, which encompass a field, a getter, and a setter (in the case of `var`s) into a single entity. This becomes very apparent if we start using the same class from Java:

```java
public class Main {
    public static void main(String[] args) {
        Person person = new Person("Mandy", 41);
        System.out.println(person.getName());
        person.setAge(42);
    }
}
```

The properties that we use in Kotlin are exposed to Java clients as getters and setters, which is the usual way of accessing values stored in a class there. Kotlin tries to blend in to the platform it's targeting and interoperate with it as seamlessly as possible. If you pay attention to some details, client code written in Java will never have to know that it's calling into your Kotlin code.

We can even jump into the Kotlin decompiler and view a decompiled version of the class, which shows us an approximation of what the one-liner `Person` class above would look like in Java:

```java
public final class Person {
   private final String name;
   private int age;

   public final String getName() {
      return this.name;
   }

   public final int getAge() {
      return this.age;
   }

   public final void setAge(int age) {
      this.age = age;
   }

   public Person(String name, int age) {
      this.name = name;
      this.age = age;
   }
}
```

While the getters and setters we use here are public, the fields that actually hold the data still remain private. Encapsulation checks out!

> This comparison of one-liner model classes vs the lengthy syntax of Java is often shown off when showcasing the strengths of Kotlin.

##### Custom getters and setters

As you can see, by default, the getters and setters generated for a property simply read or write the property's *backing field*, the field created behind-the-scenes by the compiler to store a value for the property.

We can change this behaviour by adding a custom getter or setter implementation to the property. To do this, we'll have to move our property from the primary constructor to the body of the class - the primary constructor is only for simple, straightforward properties.

```kotlin
class Person(val name: String, age: Int) {
    var age: Int = age
        get() {
          return field
        }
        set(value) {
          field = value
        }
}
```

To start, we've reimplemented the default functionality of reading and writing the backing field, which can be accessed by the `field` keyword in both the getter and the setter. The getter can take no parameter, and the setter takes a single parameter, usually named `value` by convention.

> The compiler marks these implementations as redundant, as we get the same getter/setter by default.

> Be careful not to write down something like `age = value` inside the setter. This would set the value of the *property* instead of the *field*, which would invoke its setter again, resulting in an infinite loop.

We can customize these functions to our liking now. For example, we might want to lie about our age when asked, or make sure that a person never gets any younger than their current age:

```kotlin
var age = age
    get() = field - 5
    set(value) {
        if (value > field) {
            field = value
        }
    }
```

> Note the usage of an expression body with the getter, just like with any other function.

Notice how Kotlin's type inference is at work here. The type of the property is not specified anywhere in its now lengthy declaration, instead, it's inferred from the type of the constructor parameter that it's initialized with.

The full syntax of the property with very explicit typing would look like this:

```kotlin
var age: Int = age
    get(): Int = field - 5
    set(value: Int) {
        if (value > field) {
            field = value
        }
    }
```

This contains a lot of unnecessary typing, but specifying the type of at least the property itself on the first line may be a good idea - doing so prevents it from accidentally changing its type if the constructor parameter's type changes.

It's also important to note that even though we're now writing a getter and setter in the implementation of our class, the external usage remains the same as before. We can read and write our property by just referencing its name directly:

```kotlin
val person = Person("Dave", 38)
println(person.age) // 33
person.age = 20
println(person.age) // 33
```

However we implement a property - whether we rely on the default implementation or do it ourselves - they're always encapsulated, and use accessor functions under the hood. This helps us with [maintaining the APIs](https://zsmb.co/maintaining-compatibility-in-kotlin-libraries/) of classes, while allowing them to change their internals in a broad variety of ways.

> Some Java libraries work by reading and writing the values of Java *fields*. These fields often have to be publicly accessible as well. As Kotlin's properties always use private backing fields, these libraries can have trouble operating on Kotlin classes. The solution is using the [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) annotation in these cases, which turns a Kotlin property into a plain Java field.
>
> ```kotlin
> class Person {
>     @JvmField
>     val name: String = "Anonymous"
> }
> ```
>
> Instead of calling a getter for this property, we can now directly access it in Java code:
>
> ```java
> System.out.println(new Person().name);
> ```

##### Property delegation

Custom getters and setters tend to follow the same patterns over and over again. One the most common patterns is *lazy initialization*, computing a value only when it's first needed (saving resources until then), and then storing it for later use (saving resources on subsequent accesses).

Here's an example of a `pi` property which is computed only if it hasn't been accessed yet, and otherwise it returns an already stored when the getter is invoked:

```kotlin
private var _pi: Double? = null
val pi: Double
    get() {
        if (_pi == null) {
            // Some expensive computation
            val sum = (1..50_000).sumOf { 1.0 / it / it }
            _pi = sqrt(sum * 6.0)
        }
        return _pi!!
    }
```

> This property uses another property to store its data instead of its own backing field - a [*backing property*](https://kotlinlang.org/docs/reference/properties.html#backing-properties) - because the types of the property and the data it needs to store are different. This is due to nullability concerns, which will be covered in the next chapter.

> The computation itself also uses some advanced features that we didn't cover yet, but you can attempt to figure out how it works!

If we were to now write code that lazily computes *`e`* ([Euler's number](https://en.wikipedia.org/wiki/E_(mathematical_constant))), we'd end up writing a lot of the same code as before. Two properties, one of them `null` initially, and a custom getter that performs a `null` check and executes the initialization code if needed, and finally, a `return` statement.

```kotlin
private var _e: Double? = null
val e: Double
    get() {
        if (_e == null) {
            // Again, complex, expensive computation
            val sum = (0..20).sumOf { 1.0 / (1..it).fold(1, { a, x -> a * x }) }
            _e = sum
        }
        return _e!!
  }
```

A feature called *property delegation* comes to the rescue here, which allows us to extract our getter (and setter) logic into a class, and make it reusable. We'll look at how this works exactly and how to do it ourselves later down the line, but let's see what delegates the Standard Library provides for us, starting with [`lazy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html). You can delegate a property using the `by` keyword, and create a lazy property with `lazy {}`:

```kotlin
val pi: Double by lazy {
    val sum = (1..50_000).sumOf { 1.0 / it / it }
    sqrt(sum * 6.0)
}
```

The logic performing the lazy initialization is now gone from our own code, and all we have to focus on is the initialization logic itself! This is placed within the braces `{}` - the last expression in here will be assigned as the value of the property.

It's worth mentioning that `lazy` is also thread-safe by default, which you can disable with an additional parameter, if you don't need the safety and want better performance:

```kotlin
lazy(mode = LazyThreadSafetyMode.NONE) { ... }
```

Another common pattern is running code whenever the value of a property changes. [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) serves this purpose. Let's use it to ["log"](https://stackoverflow.com/questions/31869391/what-is-the-difference-between-java-logger-and-system-out-println) changes to a property's value:

```kotlin
var name: String by Delegates.observable("Megan") { property, oldValue, newValue ->
    println("Name changed from $oldValue to $newValue")
}
```

Finally, there's [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html), which lets you veto a new value, if it doesn't pass whatever criteria you define for it. Here you have to return a `Boolean` value, which when `false` will prevent the new value from being set. Let's perform the previously used aging validation again, this time using `vetoable`:

```kotlin
var age: Int by Delegates.vetoable(0) { property, oldValue, newValue ->
    newValue > oldValue
}
```

### Constructors

> This section has been adapted from a blog post that originally appeared on [zsmb.co](https://zsmb.co/primaries-matter-a-discussion-of-constructors/).

Primary constructors play a fundamental role in Kotlin classes. Let's take a closer look at them, understand what exactly is part of a primary constructor, what makes this constructor special, and what the alternatives are.

##### Back to Java for a moment

In Java, class creation isn't exactly strict. The language lets you leave variables uninitialized without any complaints. Take this class for example:

```java
public class Car {
    String model;
    int year;
    double miles;
}
```

It has three fields, and an implicit constructor with no parameters. When you call its constructor with `new Car()`, all of these fields will be initialized to implicit default values: `null`, `0`, and `0.0`, respectively. In general, primitive types are initialized to some resemblance of `0`, while reference types are initialized to `null`.

##### Kotlin's safety guarantees

In contrast, Kotlin is very strict about creating instances. We've seen that a class like this does not compile in Kotlin, because initializing each property when an instance is created is mandatory.

```kotlin
class Car {
    val model: String
    val year: Int
    var miles: Double
}
```

> *e: Property must be initialized or be abstract*

*This forces you to explicitly initialize every value in one way or another, and guarantees that your properties won't have implicit values stored in them.* Whenever you read a property, you'll get a value out of it that *you* have put there, intentionally.

##### The primary constructor

We've also seen already that there are two ways to initialize these properties. You can initialize them inline at their declarations, or in one or more initializer (`init`) blocks.

```kotlin
class Car(model: String, year: Int) {
    val model: String = model
    val year: Int
    var miles: Double = 0.0

    init {
        this.year = year
    }
}
```

These two kinds of initializations are performed from top to bottom, in order. In the example, `model` and `miles` would be initialized first, and then finally `year` would get its value. *Any parameters that the primary constructor takes may be used for these initializations*.

Let's simplify by moving both `model` and `year` into the primary constructor. Properties in the primary constructor will be initialized before anything in the body of the class, and again, they'll be initialized in the order that they're declared in.

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0
}
```

Previously initialized variables within the class body will also be in scope during initialization if you want to rely on their values:

```kotlin
class Car(val model: String, val year: Int) {
    var miles: Double = 0.0

    val age: Int

    init {
        age = getCurrentYear() - year
    }

    val description: String = "$model ($age years, $miles miles)"
}
```

We can only initialize `description` this way after `age` has been initialized. If we placed it before the `init` block, we'd again see an error:
  
> *e: Variable 'age' must be initialized*

##### A look under the hood

If we decompile the bytecode produced for this class using the decompiler of the Kotlin IDEA plugin, we'll see this corresponding Java source (comments added):

```java
public final class Car {
    private double miles;
    private final int age;
    private final String description;
    private final String model;
    private final int year;

    // Getters & setters ...

    public Car(String model, int year) {
        // Properties in the primary constructor
        this.model = model;
        this.year = year;

        // Initialization at the declaration
        // (This is actually optimized away if we init to 0)
        this.miles = 0.0D;

        // init block
        this.age = Utils.getCurrentYear() - this.year;

        // Initialization at the declaration
        this.description = this.model + " (" + this.age + " years, " + this.miles + " miles)";
    }
}
```

This shows us how all the different kinds of initializations end up in the body of a single constructor together, in order.

##### Initialization rules, recap

To review, the initialization order:

- Properties in the primary constructor, in declaration order.
- Initializations at property declarations and in initializer blocks, interleaved, in the order that they appear in the class body.

Essentially, you can read the initialization statements in the class top to bottom, and that's what you'll get in the "body" of the primary constructor.

In each of these initializations, you can use the values of:

- Constructor parameters, even if they're not stored in properties.
- Previously initialized *(not just declared!)* properties.

*Due to these restrictions and safety guarantees, classes created via the primary constructor will always be in a valid state.*

![A representation of our single, primary constructor, which is in a valid state.](./images/2_primary.png)

##### Secondary constructors

Of course, there are cases when you want to create class instances with different sets of parameters, which normally requires multiple constructors. Kotlin's [default arguments](./1.md#default-and-named-parameter-values) make this possible to some extent while still keeping just a primary constructor. However, if you need a constructor that has entirely new parameters or parameters with different types, you'll need a *secondary constructor*.

For our example, let's say we need to be able to create cars with a model, year, and mileage, all provided as strings. Our primary constructor can't accommodate these parameters, so it's time to write a new one. This could be our first attempt:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
) {
    this.model = model
    this.year = year.toInt()
    this.miles = mileage.toDouble()
}
```

This code would fail at constructing a valid `Car` instance, and so it doesn't compile (though it certainly would in Java). For example, it doesn't set the `age` and `description` properties of the instance, which we expect to be initialized by every constructor.

> We also get an error for trying to set `year` and `miles` here: *Val cannot be reassigned*. As a `val` can only be initialized once, that one initialization will always have to happen in the primary constructor (if there is one).

![A secondary constructor that doesn't call the primary constructor is invalid.](./images/2_primary_and_invalid_secondary.png)

The fix, and the rule for secondary constructors is simple: it has to first call the primary constructor, and only after that can it perform further initialization on the instance that was created. *After the primary constructor is called by the secondary constructor, the instance is already in a well-constructed, known valid state*, so it's safe to operate on it in the body of the secondary constructor.

Let's change our secondary constructor to invoke the primary constructor first:

```kotlin
constructor(
        model: String,
        year: String,
        mileage: String,
): this(model, year.toInt()) {
    miles = mileage.toDouble()
}
```

![A secondary constructor that calls the primary constructor directly.](./images/2_primary_and_valid_secondary.png)

The call to the primary constructor doesn't have to be direct, it can also happen indirectly through calling another secondary constructor, but this chain eventually has to end in a call to a primary constructor.

Here's an example of yet another new constructor, which calls the previous secondary constructor:

```kotlin
constructor(data: Array<String>) : this(
        model = data[1],
        year = data[3],
        mileage = data[7],
)
```

![A secondary constructor that calls the primary constructor indirectly.](./images/2_primary_and_valid_secondaries.png)

What we really have here is a graph of the various constructors in our class calling each other.

- A primary constructor is valid if it initializes all properties. 
- A secondary constructor is valid if it eventually calls the primary constructor, i.e. if there's a directed path to the node representing the primary constructor from the node of the secondary constructor.
  - This also means that there can be no cycles within secondary constructor nodes, and no disconnected nodes.

![A graph of constructors.](./images/2_graph.png)

##### Without primaries [Extra content]

Another option when designing classes is to have no primary constructor at all, and use just secondary constructors. See [the extras for this chapter](./2-extras.md#without-primaries) to learn more.

### Data classes

One of the very frequently advertised features of Kotlin is *data classes*. To create a data class, simply add the `data` keyword to a class. Getting back to our favourite `Person` example:

```kotlin
data class Person(val name: String, var age: Int)
```

Adding this keyword adds some new functionality to this class, in the form of automatically generated methods. The first three of these are the `equals`, `hashCode`, and `toString` methods, which you already know from Java.

> In Java, these methods are present on the [`java.lang.Object`] type, which every class implicitly has as a supertype. In Kotlin, the type in the same role is called [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/), and maps exactly to `Object` when you're running Kotlin on the JVM.

The generated `equals` and `hashCode` methods will always consider all properties that are in the primary constructor, and only those. If you need different behaviour, you can still override these implementations yourself. (Though in this case, you might be better off without a data class.)

The generated `toString` method will give you a nicely formatted string that contains the name of the class, as well as the names and values of its primary constructor properties:

```kotlin
val emma = Person("Emma", 19)
println(emma) // Person(name=Emma, age=19)
```

> You might argue that you're not writing these methods anyway, even in Java, but generating them with IDE shortcuts. However, those generated methods are part of the codebase, and have to be maintained. With data classes, these are generated every time the class is compiled, so they're guaranteed to follow any changes to the class, for example, a new property being added.

There are also some methods generated that are only useful for Kotlin users. One of these kinds of methods are the `component1`, `component2`, etc. methods, which can be used with [destructuring declarations](https://kotlinlang.org/docs/destructuring-declarations.html), a feature that allows you to declare and initialize multiple variables at the same time, with an assignment like this:

```kotlin
val (name, age) = emma
println(name) // Emma
```

Note that destructuring works in a positional way, and that these variables can have arbitrary names. For example, swapping the names of these two variables will lead to very unexpected results:

```kotlin
val (age, name) = emma
println(name) // 19
```

Finally, the last generated method for data classes is `copy`, which allows you to... make a copy of your current instance.

```kotlin
val clone = emma.copy()
println(clone) // Person(name=Emma, age=19)
```

Its real power lies in the fact that it actually has as many parameters as the class does in its primary constructor - they just all default to taking the value of the original instance. This means that you can choose to change them one by one, using named parameters, for example:

```kotlin
val olderEmma = emma.copy(age = 26)
println(olderEmma) // Person(name=Emma, age=26)
```

We've provided only the `age` parameter, so the other properties of the class will take their values from the original instance.

The `copy` method comes in especially handy when using it on completely read-only data classes, which only have `val` properties. Since you can't change these, you have to create new instances whenever you need to represent slightly changed data, and this can get very tedious when you have to copy the old values for several properties. The `copy` method does this for you, allowing you to only change what you want to change for the new instance, easily.

> Notice how this is part of Kotlin's general push to prefer immutability. The less mutable state a class holds, the easier it is to reason about how it will behave at any given point in time. Immutability also has huge advantages in multi-threaded environments. You don't have to synchronize accesses to immutable objects, as they never change! So whether it's a local variable or a property, remember to always go with a `val` first.

> The `copy` method performs a shallow copy. Any references to other objects will therefore be the same in the original and the copy created.

Data classes do have some requirements:
- Their primary constructor can't be empty, it needs to contain at least one property.
- All primary constructor parameters need to be properties, either `val` or `var`.
- Inheritance is also restricted: data classes can not be inherited from.

The last point here is especially important, and can be quite restrictive in some cases. Remember that regular Kotlin classes are already very concise and powerful if you just need them to hold a couple values as properties. [Not everything has to be a data class.](https://zsmb.co/data-classes-arent-that-magical/)

> Hint: The generated code for data classes is a very interesting thing to look at with a decompiler!

> Java 16 introduced [records](https://docs.oracle.com/en/java/javase/18/language/records.html), which achieve something similar to data classes, automatically generating lots of boilerplate for simple data holders. [Kotlin has support for records](https://kotlinlang.org/docs/jvm-records.html) as well, allowing you to use Java-declared records, as well as to declare records in Kotlin code.

### Objects

An `object` is a construct similar to a class in Kotlin, with one difference: while you create instances of classes, an object is an instance on its own. What's more, it's the *only* instance of its type! This is essentially a very concise way to declare a [singleton](https://en.wikipedia.org/wiki/Singleton_pattern):

```kotlin
object Logger {
    var isEnabled = true
    
    fun log(message: String) {
        if (isEnabled) {
            println(message)
        }
    }
}
```

An `object` can not have a constructor, and its single instance can be accessed simply by its name:

```kotlin
Logger.log("Hello world") // Hello world
Logger.isEnabled = false
Logger.log("Oh no, where's my log") //
```

Objects may be declared inside classes. In this case, they can access the internals of the class that they're nested in, and they can be used with the following syntax:

```kotlin
class Document {
    object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

fun main() {
    repeat(5) {
        Document()
    }
    println(Document.Counter.count) // 5
}
```

> [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) is a simple way to execute a piece of code a given number of times.

How would you add a counter like this in Java? You would simply use a static variable inside the class. Kotlin doesn't have static members, neither properties nor functions. However, if you mark a nested `object` inside the class as the *companion object* of the class, you'll get the following familiar syntax for accessing anything inside that `object`:

```kotlin
class Document {
    companion object Counter {
        var count: Int = 0
    }

    val id = Counter.count++
}

println(Document.count)
```

What makes this work is that writing down the name of the class -`Document` in this example - will actually give you the reference to the companion object. You can confirm this easily, with this slightly odd line of code:

```kotlin
val counter: Document.Counter = Document
```

Naturally, classes can only have one companion object. This object is special, as it doesn't have to have an explicit name. If you don't name it, it will be named `Companion` implicitly:

```kotlin
class Document {
    companion object {
        var count: Int = 0
    }

    val id = count++
}

val counter: Document.Companion = Document
println(Document.count) // 5
```

As far as Kotlin syntax is concerned, this is as good as having static variables and functions - you simply place these inside a companion object. However, these things are still members in an inner class of `Document`, which we're then using just a single instance of. They're not *really* static members of the `Document` class.

> This can cause issues with certain Java-based frameworks that work with static fields and methods, and the syntax for Java clients isn't completely smooth either:
>
> ```java
> Document.Companion.getCount();
> ```
> 
> If you need real static declarations for Java compatibility, you can use the [`@JvmStatic`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-static/) annotation on methods or properties inside a companion object:
> 
> ```kotlin
> class Document {
>     companion object {
>         @JvmStatic
>         var count: Int = 0
>     }
> }
> ```
> 
> This will expose them as real static declarations:
> 
> ```java
> Document.getCount();
> ```
> 
> You can also use [`@JvmField`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-field/) to turn properties in the companion into static fields. To read more about the various possibilities for static interop, see [the table in this blog post](https://zsmb.co/top-10-kotlin-stack-overflow-questions-2/#5-replacing-static-things). 


### Nested classes

A quick word about nested classes. They work similarly to the ones in Java, with one significant difference: *they don't hold a reference to the outer class by default*. This helps avoid accidentally capturing references to outer classes, which can lead to memory leaks. In Java, this behaviour would be achieved by adding the `static` keyword in front of the nested class.

```kotlin
class Outer {
    var outerValue = 0
    
    class Inner {
        init {
            println(outerValue)
                 // ^ Unresolved reference: outerValue
        }
    }
}
```

If you do want an implicit reference to the outer class stored in the nested class, use the `inner` keyword - this gives you the behaviour that would be the default in Java:

```kotlin
class Outer {
    var outerValue = 0

    inner class Inner {
        init {
            println(outerValue) // 0
        }
    }
}
```

### Inheritance

Let's create a simple game to learn about how Kotlin deals with inheritance. For a start, we'll create an `Entity` base class, which will store the current position of an entity on screen, as two coordinates:

```kotlin
class Entity(var x: Double, var y: Double)
```

We can extend this `Entity` class with a concrete implementation using the following syntax:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y)
```

This `UFO` class has a primary constructor that takes two parameters, and this primary constructor calls into the superclass' constructor, passing on both parameters.

> Note that even if `Entity` didn't take any parameters, you'd have to inherit from it by calling its constructor with the `: Entity()` syntax.

The code above, somewhat surprisingly, doesn't compile. This is because classes in Kotlin are **final by default**, meaning that they can't be inherited from unless that's explicitly allowed, by making them `open`:

```kotlin
open class Entity(var x: Double, var y: Double)
```

This design choice falls in line with one of the often cited items of the [Effective Java](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/) book - *Item 19: Design and document for inheritance or else prohibit it*. Extending a class that was not designed with inheritance in mind can lead to a wide variety of problems, and *final by default* serves as a safeguard against this.

> Items of this book will be referenced by these materials every now and again, as Kotlin promotes many Java best practices naturally, through its language design. If you haven't read it yet, you should really consider it.

In our specific case, it also doesn't make sense to let clients create `Entity` instances directly, which we can prevent by making this base class `abstract`. This works the same way as Java's abstract classes: it prevents creating instances of this class, while still allowing inheritance from it. Abstract classes, of course, are always `open`.

```kotlin
abstract class Entity(var x: Double, var y: Double)
```

Next up, we'll add a `progress` method to the base class, which will be invoked by our "game engine" to indicate that time has passed.

Methods are also final by default, meaning they can't be overridden. Any method that we want to allow overrides for must be marked `open`. In the case of an `abstract` class, a method may also be marked `abstract`, if there's no default implementation provided for it - this will force concrete subclasses to override it.

For our `progress` method, we'll choose an `open` method, which will have an empty body:

```kotlin
abstract class Entity(var x: Double, var y: Double) {
    open fun progress() {
        /* Empty */
    }
}
```

In Java, [`@Override`](https://docs.oracle.com/javase/8/docs/api/java/lang/Override.html) is an optional annotation. In Kotlin, it's a required keyword. Let's add some random movement to our UFO class in its `progress` method:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y) {
    override fun progress() {
        x += Random.nextDouble(from = -5.0, until = 5.0)
        y += Random.nextDouble(from = -10.0, until = 10.0)
    }
}
```

> [`java.util.Random`](https://docs.oracle.com/javase/8/docs/api/java/util/Random.html) is still available to use in Kotlin when you're on the JVM, but the [`kotlin.random.Random`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.random/-random/) class from the Standard Library provides a simple, platform independent random API, which you should use in most cases. This is what's used in the previous code snippet.

We'll keep track of our entities in a list in a `Game` class:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun tick() {
        for (entity in entities) {
            entity.progress()
        }
    }
}
```

### Interfaces and type checks

Next up, let's draw our game on the screen, and learn about interfaces.

Kotlin's interfaces are fairly straightforward. They can not hold state, i.e. they can't declare concrete properties, but they can declare properties and methods that any classes that implement the interface will have to override. They can also contain default implementations for methods (much like Java 8 interfaces).

Let's introduce a `Renderable` interface, which will be implemented by entities that can be displayed on the screen:

```kotlin
interface Renderable {
    val isVisible: Boolean
    fun render(canvas: Canvas)
}
```

This interface requires implementations to be able to tell whether they're currently visible, and to `render` themselves onto a `Canvas` when asked to do so.

Our `UFO` class will implement this interface:

```kotlin
class UFO(x: Double, y: Double) : Entity(x, y), Renderable {
    companion object {
        const val WIDTH = 40.0
        const val HEIGHT = 40.0
    }

    override var isVisible: Boolean = true

    override fun render(canvas: Canvas) {
        // Drawing logic using JavaFX
        val context = canvas.graphicsContext2D
        context.fill = Color.DIMGRAY
        context.fillOval(x, y, WIDTH, HEIGHT)
        context.fill = Color.DODGERBLUE
        context.fillOval(x + WIDTH / 4, y + HEIGHT / 4, WIDTH / 2, HEIGHT / 2)
    }

    /* ... */
}
```

A couple of things to note here:

- Implementing interfaces uses nearly the same syntax as extending classes, except there are no parentheses indicating a constructor call.
- [Constants](https://kotlinlang.org/docs/properties.html#compile-time-constants) which would be static in Java can't reside directly in classes - in that case, they would just be properties, being present as a value in each instance. However, they may be placed inside an `object`, which can then be nested in the class. This is often - but not necessarily - the companion object. By marking these with the `const` keyword, we get to use them in annotations, and their values will be inlined to any use sites.

The implementation of `isVisible` is especially interesting. The `Renderable` interface declares it as a `val` of `Boolean` type. This lets implementations of the interface choose from a wide variety of implementations, as long as a getter exists for this property.

In the `UFO` class, we've implemented this as a `var`, which will create a field, a getter, and a setter inside the class. We can also implement this property with a custom getter, as a delegate, or as a *computed property*:

```kotlin
override val isVisible: Boolean
    get() {
        return x > y
    }
```

Computed properties are properties where the getter (and setter, if it's a `var`) doesn't reference its backing field. In this case, a backing field won't be generated inside the class for the property at all. The accessors of these properties can rely on other methods or properties that are in scope.

This means that computed properties can even be present in interfaces, as they store no state - they're just getters/setters with default implementations.

Let's update our `Game` class, to add support for rendering `Renderable` entities:

```kotlin
class Game {
    val entities = mutableListOf<Entity>()

    fun renderScene(canvas: Canvas) {
        canvas.graphicsContext2D.fill = Color.BLACK
        canvas.graphicsContext2D.fillRect(0.0, 0.0, canvas.width, canvas.height)

        for (entity in entities) {
            if (entity is Renderable && entity.isVisible) {
                entity.render(canvas)
            }
        }
    }
    
    /* ... */
}
```

The `renderScene` method fills the background of the game, and then renders each `Renderable` entity in a loop. Within the loop, we check whether each entity implements this interface with the `is Renderable` syntax (essentially an `instanceof` check).

The surprising part of this code is that there's no casting to a `Renderable` after this check passes. We just use the `isVisible` property and the `render` method of the entity that passed the type check directly.

This is thanks to a feature called [*smart casts*](https://kotlinlang.org/docs/reference/typecasts.html#smart-casts). Whenever the compiler can reason about the type of a variable based on type checks and control flow, it will automatically make the variable available as the known type, performing the cast for us.

This would even work if we checked for non-conformance to the `Renderable` interface, with the `!is` operator:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) {
        continue
    }
    if (entity.isVisible) {
        entity.render(canvas)
    }
}
```

> `continue` is a somewhat rarely used keyword in C-style languages, which terminates the current iteration of a loop, and skips to the next one.

Smart casts replace most manual casting in Kotlin, but casting explicitly is still possible with the `as` keyword. `entity as Renderable` will throw an exception if `entity` is not a `Renderable`, and return it with the `Renderable` type if it is.

This completes the interesting bits of implementation for our UFO game - find the full code of the game [in this project](../projects/chapters/chapter-2-inheritance-demo).

### Class delegation (implementation by delegation) [Extra content]

Classes can also implement interfaces _by delegation_. Instead of implementing the members declared in the interface in the class itself, the class may delegate to another instance that already implements that interface.

This looks something like this:

```kotlin
class RocketShip(delegate: Renderable) : Renderable by delegate
```

Whenever a member of `Renderable` is invoked on the `RocketShip` instance, it will forward that call to the same member of `delegate`.

Learn more about why this is useful in the [extras for this chapter](./2-extras.md#class-delegation-implementation-by-delegation).

### Sealed classes

> Nothing to do with C# sealed classes!

At times, it's handy to be able to restrict inheritance from a class. *Sealed classes* prevent unknown subclasses of a base class by allowing it to be extended only by classes that are in the same package ([before Kotlin 1.5: in the same file](https://kotlinlang.org/docs/whatsnew15.html#package-wide-sealed-class-hierarchies)).

> [Before Kotlin 1.1](https://kotlinlang.org/docs/reference/whatsnew11.html#sealed-and-data-classes), subclasses had to be *nested* in the sealed class. You can still see this pattern of nesting in many usages of sealed classes today.

For example, we may represent the response from a network call with a sealed class:

```kotlin
sealed class Response
class Success(val data: String) : Response()
class Error(val exception: IOException) : Response()
```

Then, instead of the unfriendly APIs that throw exceptions at us when something goes wrong, we can provide an API that will always return a `Response` instance as the result of a network call.

```kotlin
fun getDataFromAPI(): Response {
    return try {
        val data = URL("https://www.kotlinlang.org/").readText()
        Success(data)
    } catch (e: IOException) {
        Error(e)
    }
}
```

> Remember, `try-catch` is an expression!

We know that this `Response` will either be an instance of `Success` or `Error`. This small set of possible values can only change if someone has access to this source file, and can recompile it.

This brings us to a frequently used capability of `when`, its ability to perform type checks:

```kotlin
when (val response = getDataFromAPI()) {
    is Success -> {
        println("Network success")
        println(response.data)
    }
    is Error -> {
        System.err.println("Network error")
        response.exception.printStackTrace()
    }
}
```

> Notice that in each branch, the value of `response` is smart cast to its concrete type, making properties like `data` and `exception` accessible on them!

If we use `when` as an expression (we return a value from it), we can do so with sealed classes without having to provide an `else` branch. The compiler can guarantee that the statement is already exhaustive with just these two branches, since we know all existing implementations of `Response`:

```kotlin
val message = when (getDataFromAPI()) {
    is Success -> "Network success"
    is Error -> "Network error"
}
println(message)
```

> Using sealed classes for error handling is a neat way of avoiding having to deal with exceptions in Kotlin. For more error handling strategies, watch [this KotlinConf 2019 talk by Nat Pryce and Duncan McGregor](https://www.youtube.com/watch?v=pvYAQNT4o0I). Spoiler alert: contains quite a few advanced Kotlin features that we haven't covered yet.

Since Kotlin 1.5, [sealed interfaces are also available](https://kotlinlang.org/docs/whatsnew15.html#sealed-interfaces). The rules for implementing these interfaces are the same as subclassing sealed classes. A prominent use case for sealed interfaces is using them in libraries to ensure that users of the library can never implement a given interface.

> Java 17 also introduced [sealed classes](https://openjdk.org/jeps/409) with slightly different syntax.

### Enums

Enums are classes in Kotlin, and a basic enum declaration looks like this:

```kotlin
enum class Sizes {
    S, M, L
} 
```

It's useful to think of enums as a class with a very specific number of instances. In the example above, `S`, `M`, and `L` are the only three instances of `Sizes` that will ever exist.

> You could also think of enums as sealed classes, with all of their subclasses being `object`s. If that makes sense to you, you're getting a good grasp of OOP in Kotlin! (Please note though that this is not actually the case - enums are their own thing.)

Enums may also have properties and methods, just like any regular class. These can be implemented once for each of them, in the "base class", or be "abstract" and implemented by each value separately:

```kotlin
enum class MenuItem(val price: Double) {
    Hamburger(4.65),
    Fries(3.50),
    Coke(2.50) {
        override fun purchase() {
            super.purchase()
            println("It's a coke!")
        }
    }; // !
    
    open fun purchase() {
        println("Spending $price")
    }
}
```

> The semicolon separating the list of instances from the enum's methods is one of the very very few required semicolons in the Kotlin language.

### Visibility

Kotlin has similar [visibility modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html) to Java on first sight, but they come with a few significant changes. These modifiers can be applied to declarations of various types: classes, objects, properties, and so on.

- `public` declarations are accessible from anywhere. *This is the default visibility in Kotlin*, and it's implicit. The "package" visibility that was the default in Java is not available in Kotlin.
- `private` declarations in classes are only accessible within the same class, while top-level* `private` declarations are only accessible in the same file.
- `protected` declarations are only accessible in the containing class or its subclasses. They are *not* also accessible from code in the same package, like they are in Java.
- `internal` declarations are accessible within the same compilation unit, for example, the same Gradle module. This is a visibility unique to Kotlin, and it's especially useful for keeping library internals private from clients.

**top-level: Declarations that are declared directly in a file, and not nested in classes. Really, these are package level declarations, it's their package that contains them lexically.*

Some non-obvious use cases of visibility modifiers would be applying them to constructors, or auto-generated getters/setters:

```kotlin
class SecretValue internal constructor(initialValue: Int) {
    var state: Int = initialValue
        private set
}
```

This class cannot be instantiated from another module due to the limited visibility of its constructor. Note that in this case, the `constructor` keyword must be added to the primary constructor.
 
 Additionally, while its `state` property is a `var`, its setter will not be visible externally, essentially making it a `val` to the outside world.

## Summary

The elements of object-oriented programming in Kotlin are very similar to mainstream OO languages such as Java, with a few notable exceptions.

Instead of fields, getters, and setters, Kotlin operates on the abstraction level of properties. These properties can have auto-implemented accessors or custom ones. They may also be delegated, or be computed (have no backing field).

The primary constructor is the main way of initializing instances, and it comes with special safety guarantees. Secondary constructors have to rely on the primary constructor to perform the basic initialization of the class in most cases.

Data classes come with auto-generated utility methods in exchange for suffering a few restrictions. `object` declarations are a brief way to create singletons in Kotlin. Nested objects and companion objects can act as the "static" parts of classes. Inner classes are "static" by default, and have to be marked with `inner` to get a reference to the outer class.

Classes are final by default, and have to be marked with `open` (or `abstract`) to be inherited from. Interfaces can contain property and function declarations, as well as default implementations for functions. Casting in Kotlin is mostly done via smart casts which happen automatically after a successful type check. Sealed classes are a way to restrict an inheritance hierarchy, which can guarantee exhaustive checks on what the type of a given instance is.

Visibility modifiers are slightly different than in Java. Declarations are `public` by default, and Kotlin offers an `internal` modifier.

## Sources

- [Execution in the Kingdom of Nouns - Steve Yegge](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html)
  - A tale of how functions are treated in Java.
- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Data classes aren't (that) magical](https://zsmb.co/data-classes-arent-that-magical/)
- Official documentation
  - [Classes and Inheritance](https://kotlinlang.org/docs/reference/classes.html)
  - [Interfaces](https://kotlinlang.org/docs/reference/interfaces.html)
  - [Properties and Fields](https://kotlinlang.org/docs/reference/properties.html)
  - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html)
  - [Data Classes](https://kotlinlang.org/docs/reference/data-classes.html)
  - [Sealed Classes](https://kotlinlang.org/docs/reference/sealed-classes.html)
  - [Nested and Inner Classes](https://kotlinlang.org/docs/reference/nested-classes.html)
  - [Enum Classes](https://kotlinlang.org/docs/reference/enum-classes.html)
  - [Visibility Modifiers](https://kotlinlang.org/docs/reference/visibility-modifiers.html)

# Chapter 3: Nullability

Safety, as we've discussed in the [introduction](1.md#chapter-1-introduction), is a defining property of the Kotlin language. So why do we need safety guarantees from languages?

The worst kind of errors are runtime errors: they happen while users are interacting with the application, likely resulting in an unpleasant experience. Compile time errors are better than runtime errors, as developers face these instead. Even better than compile time errors are edit time errors (or design time errors, if you will): not having to build the project, but seeing the error immediately when making it while writing the code. For Kotlin, the latter two categories of errors are essentially the same, as IntelliJ will show you nearly all compilation errors in real time (as it runs the exact same code to analyze Kotlin code as the compiler).

To move as many errors as possible to compile/edit time, Kotlin is...

- A statically typed language, meaning that each variable has a fixed type which is known at compile time, and doesn't change later. This allows verification such as making sure that whatever methods are called on a variable do, in fact, exist.
- A strongly typed language, which means that values are almost never converted to other types implicitly.

> JavaScript is an excellent counter-example for both of these traits.

Another safety feature, which is perhaps the most often touted one in Kotlin, is *null safety*. This is often advertised as *"Kotlin doesn't have NullPointerExceptions!"*. While this statement is categorically false, we'll see that Kotlin really does do a lot to minimize nullability problems.

### The issue on the table

What's the problem with nulls in the first place? For example, that even this trivial Java method isn't "safe":

```java
public static boolean isEmpty(String str) {
    return str.length() == 0;
}
```

For example, if you pass in `null` as its parameter, it will throw an exception. Would you ever expect a method like this to do that?

The core problem is that you have to keep `null` in mind constantly as you write Java code. These are everyday questions with Java:

- Will a given method accept `null` as its parameter? Will it throw a validation exception for the parameter, or will it crash unexpectedly somewhere halfway?
- Will a given method ever return a `null` value? Do you need to check for that before you operate on it? 
- Does this field in this class ever hold `null`, or can you trust that it's always initialized?

Null checks themselves aren't the problem. It's not knowing when they're needed for certain that's the issue. You can't feasibly null check every value you ever call a function on, which means that sooner or later you'll try to do it on a `null` value. And of course, you'll only find this out at runtime, with the infamous `NullPointerException` (NPE).

Null - the absence of value - is something we need to be able to express, and it can actually [be your friend](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5) if the language allows you to [deal with it safely](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903).

### Nullability

Null safety means that each type in the Kotlin language is either nullable or non-nullable. The former allows a `null` value, while the latter forbids it. This is known at compile time, and the compiler enforces null safety as part of type checking.

The types we've seen so far have all been non-nullable: `Int`, `Person`, and `FileInputStream` are examples of this. You can't assign `null` to a variable of any of these types:

```kotlin
val person: Person = null
```

> e: Null can not be a value of a non-null type Person

The nullable counterparts of these types are denoted by a `?` at the end of the typename: `Int?`, `Person?`, and `FileInputStream?` are all nullable. A variable with one of these types is able to hold `null`, in addition to being able to hold a reference to an object of the given type. This code will compile:

```kotlin
var person: Person? = null
person = Person("Ann", 37)
person = null
```

> The `?` syntax implies uncertainty, or even a question: does a variable of type `Person?` hold an actual `Person`? Maybe. It's a person (?). It's a `Person?`.

If you choose a nullable type, the compiler will know that you have a possibly `null` value, and prevent you from accidentally calling something on this reference - whether that's a method invocation, or reading a property:

```kotlin
println(person.name)
```

> e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type Person?

The error message tells us that this call is not allowed, and even suggests some ways to fix the issue of trying to work on a nullable value.

Thankfully, Kotlin provides several convenient features to perform a null check. Let's start with the simplest one, an actual, explicit null check using `if`:

```kotlin
if (person != null) {
    println(person.name)
}
```

This code works, because inside the `if` statement, we receive a *smart cast*. The `person` variable's type changes from `Person?` to `Person` within that scope, and we can operate on it as usual.

Note how this gets us from a broader type to a more specific type, just like a smart cast from an `Animal` type to a `Dog` type would in this scenario:

```kotlin
abstract class Animal
class Dog(val name: String) : Animal()

fun dogCheck(animal: Animal) {
    if (animal is Dog) {
        println("${animal.name} is a good boy")
    }
}
```

Null handling in the type system isn't as special as it seems. We'll take a deeper look at how it works in [chapter 9](./9.md#the-parallel-nullable-and-non-nullable-type-hierarchies).

### Safe calls

One of the basic ways to handle a `null` value is the safe call operator `?.`. It simply replaces the regular accessor `.` of a property access or method call:

```kotlin
println(person?.name)
```

If the operand of `?.` is `null`, it will skip the operation on it, and the entire expression (`person?.name` in the example) will just evaluate to `null`.

This operator can be chained if you have nested data models, where any of them might be `null` along the way. If this happens, the entire chain will short circuit and return `null`.

```kotlin
val street: String? = person?.company?.address?.building
```

While the safe call operator lets you make method calls safely, without the possibility of an NPE, it's not perfect:

- It will never get you a non-nullable value. Whatever values you get from a safe call will always be nullable, as the call might have been skipped.
- It can hide certain issues in your code if you use it carelessly. A call such as `service?.sendEmail()` silently skips sending the email if `service` happens to be `null`, and you don't get to handle the error case. The safe call is shorthand for an `if-else` statement with an implicitly empty `else` branch:

    ```kotlin
    if (service != null) {
        service.sendEmail()
    } else {
        /* Do nothing */
    }
    ```

    Only use this operator if your calls are *truly* optional, and you don't mind if they don't happen.

### Elvis operator

The Elvis operator `?:` (tilt your head to the left) is a path from the nullable world to the non-nullable one. Here's how it's used:

```kotlin
val message: String? = getMessage()
val length: Int = message?.length ?: 0
```

If the value on the left side of the operator is not `null`, it will return that value. Otherwise, the Elvis expression returns the right hand side value. That's it!

This operator is often used to provide a default value of sorts if something happens to be `null`, like in the example above. It also comes in handy to throw an exception or return from a method due to a `null` value:

```kotlin
fun processInput() {
    while (true) {
        val input: String = readLine() ?: return
        println("Input was: $input")
    }
}
```

> The [`readLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/read-line.html) function from the Standard Library reads a line from the standard input stream, and returns `null` if the end of the input has been reached.

We'll look at how the evaluation and inference of types works exactly when using the Elvis operator [later on](./9.md#elvis-revisited), when we dive deeper into the Kotlin type system.

> Fun fact: this operator is also referred to as the [null coalescing operator](https://en.wikipedia.org/wiki/Null_coalescing_operator), and is present in many languages.

### `!!` operator

If you really want to shoot yourself in the foot, Kotlin provides you the tool to do so. The *not-null assertion operator* is a favourite of NPE lovers. It's very simple: it either returns whatever you've applied it to with a non-null type, or it throws an exception ~~(a `KotlinNullPointerException`, to be precise)~~ (a regular [`NullPointerException`](https://docs.oracle.com/javase/8/docs/api/java/lang/NullPointerException.html), [since Kotlin 1.3.50](https://blog.jetbrains.com/kotlin/2019/08/kotlin-1-3-50-released/)).

```kotlin
println(person!!.name)
```

This code is equivalent to the following:

```kotlin
val person: Person? = null
if (person == null) {
    throw NullPointerException()
}
println(person.name)
```

Note that unlike the safe call operator `?.`, this operator doesn't include the `.` accessor. It can be used just on its own in an expression to force a null check / smart cast, as it will be evaluated, and throw an exception if it fails the check:

```kotlin
person!!
println(person.name) // person is smart cast to `Person` here
```

For the same reason, you'll never be able to construct an instance of a class like this one, as it will always throw an exception while it's being constructed:

```kotlin
class Episode {
    var airdate: Date = null!!
}
```

### Safe casts

We see that handling nullable values is convenient in Kotlin, since the language provides many tools for this purpose. *Safe casts* let us make use of these tools when we need to perform type checks, by transforming a question of type conformance to a question of nullability:

```kotlin
val renderable: Renderable? = entity as? Renderable
```

A safe cast performed with `as?` will either succeed and return the original value as the given type, or fail and return `null` instead. Handling this `null` value is often more convenient than performing a type check, or attempting a regular cast and catching a possible exception.

Take this slightly modified example from our game in the previous chapter, which uses a type check:

```kotlin
for (entity in entities) {
    if (entity is Renderable) {
        entity.render(canvas)
    }
}
```

We can easily rewrite this using a safe cast, and then a safe call:

```kotlin
for (entity in entities) {
    (entity as? Renderable)?.render(canvas)
}
```

Similarly, if you take this loop, with an inverted condition:

```kotlin
for (entity in entities) {
    if (entity !is Renderable) continue
    entity.render(canvas)
}
```

... you can rewrite it using a safe cast and an Elvis operator:

```kotlin
for (entity in entities) {
    val renderable = entity as? Renderable ?: continue
    renderable.render(canvas)
}
```

These may or may not be more legible than the original code for you at this point. As you get used to Kotlin and read more Kotlin code, such patterns will surely become familiar.

### lateinit

The language's strict class initialization rules require every property to be initialized when an instance is constructed. This applies to nullable properties as well, even if you're just initializing them to `null`.

However, there are several frameworks that rely on lifecycle callbacks for initialization rather than the constructor. When working with these, you may end up having to make properties nullable just because you're initializing them later than "constructor-time":

```kotlin
class MyApplication : Application() {
    private var timer: AnimationTimer? = null

    override fun start(primaryStage: Stage) {
        // Setup things
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }
    }
}
```

> Here's a new use of the `object` keyword, an [*object expression*](https://kotlinlang.org/docs/object-declarations.html#object-expressions)! This is the way to create anonymous implementations of interfaces or anonymous subclasses in Kotlin. It's equivalent to using `new AnimationTimer() {}` in Java. Note the parentheses indicating the call to the superclass constructor in the Kotlin syntax, which is the same as with regular subclassing.

The compiler will guarantee null safety by continuously forcing us to perform null checks of one kind or another when we interact with this `timer` property. This is inconvenient, since we know that `timer` will be initialized in time, and never be `null` when we're trying to use it. Both of these calls will work, but they are both unnecessarily verbose, and introduce complexity in the code:

```kotlin
timer?.start()
timer!!.stop()
```

What's even worse is that regular null checks will not work on `timer`, as it's a class-level, mutable property:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer = object : AnimationTimer() { ... }

    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

> e: Smart cast to 'AnimationTimer' is impossible, because 'timer' is a mutable property that could have been changed by this time

The compiler's worry here is that the class might be used in a multithreaded environment, where a thread executing in parallel to the current one may change the value of `timer` between the `if` statement's condition being evaluated and its body executing, which could lead to an NPE.

> We'll see a neat way to perform a null check for such a `var` later on.

The solution for this is the `lateinit` keyword, which signals to the compiler that a property will be initialized late - later than constructor time. (In the case of a `lateinit` local variable, later than declaration time.)

By using it, you, the developer, will bear the responsibility of initializing the property before you start using it. In turn, the compiler will stop worrying about it, and let you use it freely. Using this keyword is the equivalent of turning `null` safety off, but it's appropriate and useful in situations like these.

Adding it to `timer` lets us make it non-nullable (in fact, `lateinit` declarations can not be nullable), and use it freely:

```kotlin
class MyApplication : Application() {
    private lateinit var timer: AnimationTimer

    override fun start(primaryStage: Stage) {
        timer = object : AnimationTimer() {
            override fun handle(now: Long) {
                // Draw stuff somewhere!
            }
        }

        timer.start()
        timer.stop()
    }
}
```

What happens if you fail to initialize such a property in time? You'll get a nicely formatted `UninitializedPropertyAccessException`, with a message like this:

> lateinit property timer has not been initialized

If you ever forget to set a `lateinit` variable in time, this is still more useful for tracking down the issue than getting a generic NPE.

### Java interop, platform types

Kotlin prides itself on interoperability with the native languages and tools of whatever platform you're running it on. Since Java doesn't have a language level concept of nullability, how can Kotlin's strict null handling be reconciled with going back and forth between the two languages?

##### Kotlin to Java interop

By default, declarations coming from Java have _platform types_. This means that their nullability is just... Unknown. ¯\\\_(ツ)\_/¯

For example, consider this class, which - like most Java code - contains no nullability information.

```java
public class JavaTest {
    String platform;

    public JavaTest(String platform) {
        this.platform = platform;
    }
}
```

This is true about the data it's storing, as well as its constructor parameter. Both of these will have the platform type of `String!` when looking at them from Kotlin. Platform types are *non-denotable*, meaning that while they're a part of the language, they can not be used directly in source code. They will only show up in IDE hints and compiler messages.

Whenever we use this class from Kotlin, we are free to pass in either a nullable or non-nullable value as the constructor parameter:

```kotlin
val test1 = JavaTest(null)
val test2 = JavaTest("string")
```

We're also allowed to either perform null handling when we read the value of `platform`, or not:

```kotlin
val test = JavaTest(null)
println(test.platform.length)
println(test.platform?.length)
```

When we work with platform types, our null safety drops to the level of safety that Java provides - *none*. We either perform null checks when something may be null, or we don't, and then we might crash with an NPE.

This seems like a major blow for Kotlin's null safety - and, well, it is. This is the cost of interoperating with a language that inherently doesn't care about nullability, and you'll have to keep this in mind whenever you call a Java-based API. You can hope for the best and just use values that have platform types directly, you can treat all of them as if they were nullable (though the Kotlin compiler won't enforce this), or you can try to balance the two somehow.

> Fun fact: in early stages of the interop design, _everything_ coming from Java was considered nullable, and had to be checked or handled accordingly. While super safe, this turned out to be unfeasible in practice, and was replaced by platform types.

It's a good idea to make your choices about how you treat something with a platform type explicit, by not letting the compiler infer platform types for variables. Instead of this declaration, which implicitly creates a variable with the type `String!`:

```kotlin
val str = test.platform
```

You should choose one of these explicitly typed declarations, which essentially documents whether you thought this value was nullable or not:

```kotlin
val str1: String = test.platform
val str2: String? = test.platform
```

If you choose the former, and `platform` does happen to be `null`, you'll get an exception immediately here, at the assignment. This is *much* easier to track down if it happens than giving the variable a platform type here, and crashing later in your code, when you try to actually use it.

> The bytecode performing the check is interesting to take a look at!

##### Nullability support from Java

So what's the solution for existing code that's written in Java, and all the existing libraries in the JVM ecosystem? How can they aid Kotlin's null safety?

The ultimate solution is to _"just"_ migrate that code to Kotlin, and while [this has been done](https://cashapp.github.io/2019-06-26/okhttp-4-goes-kotlin), it's certainly not feasible for all of the code in every project. You can still be a good citizen even if you're maintaining Java APIs though, thanks to the Kotlin compiler's support for [nullability annotations](https://kotlinlang.org/docs/java-interop.html#nullability-annotations).

These have been slowly gaining adoption in Java over the years, and several sets of them exist. There's a JSR implementation, and Lombok, Android, and of course JetBrains have their own too, just to mention a few. Each slightly different, each in different packages. The Kotlin compiler supports all of the ones mentioned and more, see [the compiler's source](https://github.com/JetBrains/kotlin/blob/master/core/compiler.common.jvm/src/org/jetbrains/kotlin/load/java/JvmAnnotationNames.kt) for the up-to-date list.

We'll use the JetBrains flavour of these annotations for the examples here. Using these, you can annotate your types in Java like this:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;
}
```

If you're using an IDE that supports these annotations, you'll see a warning on `notNull` here immediately, as it's not initialized by the implicit, empty constructor, and is therefore `null` when an instance of this class is created. 

> This code will still compile, however. These annotations are not enforced by the Java compiler!

This can be fixed by adding a proper constructor:

```java
public class JavaTest {
    @Nullable
    String nullable;
    @NotNull
    String notNull;

    public JavaTest(@Nullable String nullable, @NotNull String notNull) {
        this.nullable = nullable;
        this.notNull = notNull;
    }
}
```

These annotations will be picked up when using this class from Kotlin, which means that the constructor will have a `String?` and a `String` parameter. You'll be forced to perform a `null` check when you try using `nullable`, and the compiler will warn you that a `null` check is unnecessary if you add one for `notNull`.

```kotlin
val test = JavaTest(null, "string")

println(test.nullable.length) // e: Only safe (?.) or non-null asserted (!!.) calls are allowed on a nullable receiver of type String?
println(test.nullable?.length) // ok

println(test.notNull.length) // ok
println(test.notNull?.length) // w: Unnecessary safe call on a non-null receiver of type String
```

These annotations are trusted by the compiler, but unlike Kotlin's nullability, they aren't actually verified at compile time. You can easily write and compile code like this, as it only shows an IDE warning:

```java
@NotNull
String getData() {
    return null;
}
```

This method would be visible with a non-nullable return type in Kotlin, and probably cause crashes on the Kotlin side at some point.

It's your responsibility that you annotate your APIs correctly with these annotations. Providing these annotations makes the lives of both your Java and Kotlin clients easier, and if you are maintaining a Java API, you should definitely make use of them.

> In the Android community, the adoption of these annotations escalated quickly as Kotlin gained more and more popularity.

##### Java to Kotlin interop

What about the other direction, calling Kotlin code from Java? If you are using an IDE that understands nullability annotations in pure Java code, it will likely also pick up Kotlin nullability information, as the compiler injects these annotations into the bytecode produced from Kotlin sources.

Yet again, this won't be enforced when compiling Java code against a Kotlin API, but it will be present for you as extra information when you're writing your Java code, letting you code safer.

### Nullable basic types

Basic types (such as `Int`) are represented as a primitive at the bytecode level whenever possible. For example, the parameter of this function will be a primitive:

```kotlin
fun calculate(x: Int) { ... }
```

Decompiled, we'd be looking at code like this:

```java
void calculate(int x) { ... }
```

However, if we use a nullable type, the boxed variants of basic types will have to be used instead. Since primitives are not reference types, they can't hold `null` as their value.

```kotlin
fun configure(x: Int?) { ... }
```

Decompiled, we'll see the boxed type, which allows us to potentially pass `null` into this function:

```java
void configure(@Nullable Integer x) { ... }
```

### Runtime checks

Until now, we've talked about the compile time checks that are performed to grant null safety. These, however, aren't quite enough on their own. When you're calling into Kotlin from Java, you can easily pass in `null` for a parameter that's declared as non-nullable, and the implementation of the method won't be prepared for this.

As an example, let's take this method that takes a `String` as a parameter, and prints its characters line by line. It also modifies some state at the start and end of the method, which prevents multiple invocations printing two strings at the same time (let's ignore the threading issues with setting a regular `Boolean` flag here).

```kotlin
var printing = false

fun printCharacters(str: String) {
    if (printing) return
    printing = true

    for (c in str) {
        println(c)
    }

    printing = false
}
```

You can easily pass in `null` as the parameter if you call this method from Java:

```java
public static void main(String[] args) {
    Printer().printCharacters(null);
}
```

This would cause an exception when the `for` loop attempts to iterate it. As the `printing` flag has already been set at that point, this would leave your application in a broken state, never being able to print anything again. (Assuming that you've handled the exception, and the method has a chance to be called again.)

To prevent this kind of unexpected failure, caused by the presumed safety that you had when you implemented the Kotlin method, the compiler performs additional null checks at runtime, by injecting code during compilation. These pieces of code, again, can be found by decompiling the bytecode:

```java
public final void printCharacters(@NotNull String str) {
    Intrinsics.checkParameterIsNotNull(str, "str");
    if (!printing) {
        printing = true;
        /* ... For loop ... */
        printing = false;
    }
}
```

Since these checks are performed immediately at the beginning of the function before any of your code is executed, a failing check throwing an exception means that it's as if the incorrect call never even happened. This prevents your application from ending up in an unexpected, invalid state by aborting execution somewhere halfway through your method.

These kinds of null checks, and many other utility methods are contained by the [`Intrinsics`](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Intrinsics.java) class. You'll see static calls to it all over decompiled bytecode: for values of parameters and fields, return values, when using the `!!` operator or `lateinit` variables, and more.

It's also worth noting that these checks will generate nicely formatted, specific exception messages, which is why you'll see identifiers, and sometimes even longer pieces of code being passed into them as strings (such as the name of the parameter in the example above).

## Summary

Nullability is a core part of Kotlin's type system. Types are all nullable or non-nullable. When operating on nullable values, the compiler enforces performing null checks.

Safe calls `?.` skip calls to methods if the reference they were (would have been) invoked on is `null`. The Elvis operator `?:` yields its left-hand value if that's not `null`, and the right-hand value otherwise. The `!!` operator is a quick way to throw an NPE.

`lateinit` takes the responsibility of checking nullability out of the compiler's hand, and is useful when working with frameworks.

Safe casts `as?` allow rewriting type checks to nullability problems.

By default, Java declarations show up with platform types in Kotlin, which are unsafe to use. This can be improved upon by using nullability annotations.

## Sources

- [Null is your friend, not a mistake - Roman Elizarov](https://medium.com/@elizarov/null-is-your-friend-not-a-mistake-b63ff1751dd5)
- [Dealing with absence of value - Roman Elizarov](https://medium.com/@elizarov/dealing-with-absence-of-value-307b80534903)
- Official documentation:
  - [Nullability](https://kotlinlang.org/docs/reference/null-safety.html)
  - [Calling Java from Kotlin](https://kotlinlang.org/docs/reference/java-interop.html#null-safety-and-platform-types)
  - [Calling Kotlin from Java](https://kotlinlang.org/docs/reference/java-to-kotlin-interop.html#null-safety)

# Chapter 4: Functional Programming

In [chapter 2](2.md), we've looked at Kotlin's support for object-oriented programming. The other major paradigm that Kotlin supports is [*functional programming*](https://en.wikipedia.org/wiki/Functional_programming).

Some general aims of functional programming are:

- Functions as a first-class citizens
  - In most OO focused languages, [functions are inferior to classes](https://steve-yegge.blogspot.com/2006/03/execution-in-kingdom-of-nouns.html). They can not exist outside a class, they are just parts of classes - the larger, *more important* concept.
  - In functional programming, functions can exist on their own (remember [C](https://en.wikipedia.org/wiki/C_(programming_language)), which didn't even have classes?).
- Pure functions
  - A function is considered pure if it doesn't depend on anything but its parameters, and produces no side effects. This is how a mathematical function tends to work. Methods in OO are rarely pure. Most of them make use of state inside classes, and modify that state.
  - Pure functions have many advantages, the most important one of these is perhaps *referential transparency*, which means that they always produce the same results for the same inputs. This makes it very easy to reason about them, and also facilitates testing.
- Immutability
  - Mutable state is the enemy of functional programming, for good reason. The more mutable state, the more complex the code, as you have to keep thinking about the current state of the application as you're performing actions. Therefore, functional programming prefers immutable data structures and variables over mutable ones.
  - Shared mutable state being accessed from multiple threads in an application is also a frequent source of bugs.
  - We've already seen how Kotlin promotes these ideas with its preference of `val` over `var`, and the `copy` method generated for data classes. We'll find more of the same when we get to collection types in the next chapter.
- Declarative over imperative style
  - Instead of giving step-by-step instructions on *how* to manipulate data, functional programming focuses on *what* to do with the data.
  - This sounds rather abstract at first, but again, this is something that will be prevalent in Kotlin's [collection handling](./5.md#collection-processing), which we'll learn about later.

So when can a language declare that it's functional? Does it have to meet some, or all of the requirements above? Maybe even more than these? It's very hard to say definitely. [Haskell](https://www.haskell.org/) is sometimes touted as the only true, purely functional language. However, many languages support some amount of the concepts of functional programming, which blurs the lines quite a bit.

JetBrains' stance on the matter is that they consider the support for top-level functions the determining factor. This makes Kotlin a functional language, in addition to being object-oriented.

## Code organization

We've seen that Kotlin has top-level functions. They're what make the "hello world" program in Kotlin is as simple as this:

```kotlin
fun main() {
    println("Hello world")
}
```

Compare this to Java's "hello world":

```java
public class Main {
    public static void main(String[] args) {
        System.out.println("Hello world");
    }
}
```

> Just think of how many concepts you'd have to explain to someone getting started with Java to print their first message in the language. What's `public`? What's a `class`? What's `static`? What's `void`? What's a `String[]`? And so on.

So Kotlin allows for top-level functions, and you can place multiple of these in a file. In fact, you can place almost anything in a single file. Multiple functions, interfaces, public classes, and properties can all exist in one file.

These files are sorted into packages, which is declared at the top of each file. Just like classes, other top-level declarations can be used in other packages by importing them.

> Unlike with Java, the packages that files reside in don't *have to* match the directories they're in under the source folder. There is an [official recommendation](https://kotlinlang.org/docs/coding-conventions.html#directory-structure) that pure Kotlin projects should leave out the directories for the "root package" of the application, and place anything in that package directly in the root of the source folder. However, in practice, the Java conventions are followed 99.99% of the time.

The Java language isn't what requires everything to be wrapped in classes - this is a requirement on the bytecode level. So how are all the top-level declarations in Kotlin files compiled to bytecode? There's only one possible answer: they're wrapped in classes.

For example, take this piece of Kotlin code, residing in a file called `TextUtils.kt`:

```kotlin
package util

val LOWERCASE_ALPHABET = "abcdefghijlkmnopqrstuvwxyz"

fun isEmpty(str: String?): Boolean {
    return str == null || str.length == 0
}
```

Compiling this, we end up with a class called `TextUtilsKt` at the bytecode level, with all static contents:

```java
public final class TextUtilsKt {
    @NotNull
    private static final String ALPHABET = "abcdefghijlkmnopqrstuvwxyz";

    @NotNull
    public static final String getALPHABET() {
        return ALPHABET;
    }

    public static final boolean isEmpty(@Nullable String str) {
        return str != null || str.length() == 0;
    }
}
```

This is good news for any Java clients, as they can access this functionality by calling static methods on a class. However, the call site is littered with the `Kt` postfix, leaking the implementation detail of these utilities being written in Kotlin:

```java
public static void main(String[] args) {
     if (TextUtilsKt.isEmpty(args[0])) {
         // ...
     }
 }
```

Thankfully, the name of this generated class can be controlled by placing the [`@JvmName`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-name/) annotation on the entire file:

```kotlin
@file:JvmName("TextUtils")

package util

/* ... declarations ... */
```

This will have the expected effect of renaming the class to just `TextUtils`, which is much nicer to call from Java.

> In the previous code snippet, `@file` is an [annotation use-site target](https://kotlinlang.org/docs/annotations.html#annotation-use-site-targets). These are used to specify what exactly you want to apply an annotation to, when it would otherwise be ambiguous. For example, on a property declared in a primary constructor, you might want to annotate the parameter `@param:`, the property `@property:`, the backing field `@field:`, or the getter `@get:` of the property. This is useful sometimes when using Java-based tools with Kotlin code.

> In combination with `@JvmName`, you can also add the [`@JvmMultifileClass`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.jvm/-jvm-multifile-class/) annotation to files. This lets you use the same `@JvmName` for multiple files, and all top-level declarations from those files will be combined into a single class in the bytecode!

## Extensions

One of the often advertised, high-profile features of Kotlin are extension functions. These allow you to add new functionality to existing classes, without touching the class definition itself. This means that you can add extensions even to classes (types, really) that you don't own!

For example, if you need a quick and easy-to-read way to get the last character of a `String`, you can add an extension function like this:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}

fun main() {
    println("Steve".lastChar())
}
```

Let's take a close look at this piece of code:

- The type that you're extending is specified before the name of the function, in this case, with the `String.` syntax. You're defining a function _on_ the `String` type.
- Inside the function, you can write code as if you were writing a real method inside the `String` class. The instance that your extension was called on is available as `this`. This instance is called the *receiver* of the extension function.
- Invoking an extension has the same syntax as calling a real method of the class. If it's in a different package, it does have to be imported, like any other top-level function would be.

So... How is this possible? Don't worry, Kotlin doesn't attempt to rewrite the bytecode of existing classes. Instead, these extensions are implemented as simple static functions on the bytecode level (top-level extensions, that is - member extensions are discussed [below](#member-extensions)).

If we decompile the bytecode from the code above, we'll see just that:

```java
public static final char lastChar(@NotNull String $this$lastChar) {
    Intrinsics.checkParameterIsNotNull($this$lastChar, "$this$lastChar");
    return $this$lastChar.charAt($this$lastChar.length() - 1);
}

public static final void main() {
    char var0 = lastChar("Steve");
    System.out.println(var0);
}
```

The receiver of the function simply becomes the first parameter of the function, and any other parameters are shifted over by one. This implementation detail is very important, as it poses some limitations on extensions, and it explains some of their behaviour.

Since extensions aren't real members, just static functions operating on an object, they *can't access non-public API of the type that they're being added to*. This would break encapsulation. You can't implement anything with an extension that you couldn't implement in a function that takes the receiver as a parameter - you just get much nicer syntax.

> The [`CharSequence.last()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/last.html) function is actually part of the Standard Library.

---

As extension functions are static, they are resolved statically, which is a significant difference from how regular members work. Consider the following example:

```kotlin
abstract class Animal {
    open fun identify() {
        println("This is an animal.")
    }
}

class Cat : Animal() {
    override fun identify() {
        println("This is a cat!")
    }
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is a cat!
}
```

Even though we are holding onto a reference of a `Cat` as an `Animal`, when we call its `identify` method, the method defined in the `Cat` class is invoked. This feature - [dynamic dispatch](https://en.wikipedia.org/wiki/Dynamic_dispatch) - is the basis of polymorphism, a core concept of object-oriented programming. It allows choosing the concrete implementation that is invoked at runtime.

So what happens if we move both of these `identify` methods into extensions instead?

```kotlin
abstract class Animal

fun Animal.identify() {
    println("This is an animal.")
}

class Cat : Animal()

fun Cat.identify() {
    println("This is a cat!")
}

fun main() {
    val animal: Animal = Cat()
    animal.identify() // This is an animal.
}
```

We suddenly lose dynamic dispatch. Since the `identify` functions are static, the decision about which one to call has to be made at compile time (statically). At that time, all we know for certain is that we have an `Animal` instance. Any concrete `Animal` could (in theory) end up in that reference by the time we have to call `identify` at runtime. Therefore, the definitely-fitting overload is chosen out of our two static functions.

---

Extensions are a powerful tool that let you add missing functionality to types, and make existing, awkward APIs easier to use when you write Kotlin code. The Android ecosystem, for example, has [first-party](https://developer.android.com/kotlin/ktx) libraries containing many, many extensions around existing API.

For example, showing a quick message called a [Toast](https://developer.android.com/guide/topics/ui/notifiers/toasts) on-screen can be done with the following API, which requires you to pass in a [`Context`](https://developer.android.com/reference/android/content/Context) object as the first parameter, a length as the last one, and then _not forget to call `show`_ after creating the `Toast`.

```kotlin
Toast.makeText(this, "Network timed out", Toast.LENGTH_SHORT).show()
```

This can be very easily be wrapped up in an extension which is effortless to call when you're inside a class that's a `Context` itself (like an often-used Android [`Activity`](https://developer.android.com/reference/android/app/Activity)):

```kotlin
fun Context.toast(message: String, duration: Int = Toast.LENGTH_SHORT) {
    Toast.makeText(this, message, duration).show()
}

toast("Network timed out")
```

Note the use of the default parameter value, which allows you to provide fewer parameters in the common case, but still gives you the ability to customize the value, should you need to.

### Extension-oriented design

A significant amount of the functions in the Standard Library are defined as extensions. Many of them extend commonly used types, such as `String` or `File`. We'll take a closer look at these extensions later.

However, many functions that operate on Standard Library types (which could be easily added inside the class body) are also defined in extensions. This allows the classes to contain just the core, essential functionality that they need. Everything else can be defined as extensions, which are loosely coupled to the class, allowing it to more easily change later.

For example, take this `Node` class that can be used to build a binary tree:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null

    fun traverse() {
        leftChild?.traverse()
        println(value)
        rightChild?.traverse()
    }
}
```

It can be argued that the `traverse` member doesn't _really_ belong in this class. Traversing is not something a `Node` can do, it's a way that we use a `Node`. The class itself could be just a data holder, which doesn't have any behaviour.

> This member function also prevents anyone from adding their own function named `traverse` as an extension, which might not be desirable. Members always take precedence over extensions in case of signature clashes.

Instead of this function living inside `Node`, we can provide it as an extension:

```kotlin
class Node(val value: Int) {
    var leftChild: Node? = null
    var rightChild: Node? = null
}

fun Node.traverse() {
    leftChild?.traverse()
    println(value)
    rightChild?.traverse()
}
```

This allows other developers to define their own `traverse` extensions in different packages, which may perform a different kind of traversal (e.g. pre-order), or different actions during the traversal (e.g. draw the tree instead of printing its values to the console).

> What happens if you need to use multiple extensions with the same name in the same file? You have to [get a bit creative with your imports](https://stackoverflow.com/a/42753052/4465208). You can use the `import com.myutils.traverse as traverseInOrder` syntax to rename any imported symbol for a given file. This syntax is also useful if you want to conveniently use multiple classes with the same name, without having to fully qualify one of them everywhere in a file.

This pattern is referred to as [*extension-oriented design*](https://medium.com/@elizarov/extension-oriented-design-13f4f27deaee). It's prevalent in many first-party Kotlin libraries, for example in the Standard Library's collection processing functions, sequences, and coroutines.

> The `@JvmName` annotation mentioned earlier can also be used on individual declarations, like functions. For example, we could rename the `traverse` function above just for Java users by adding an annotation to it.
> 
> ```kotlin
> @file:JvmName("Utils")
>
> @JvmName("traverseNode")
> fun Node.traverse() { ... }
> ```
> 
> Usage from Java would now look something like this (while Kotlin usage remains unchanged):
> 
> ```java
> Utils.traverseNode(node);
> ```
> 
> This comes in handy when something makes sense in the context of Kotlin (for example, as the name of an extension function or an [operator](./8.md#operators)), but results in an odd-to-read call site from Java code, where it's the name of a static method. 

### Extension properties

Extension properties are much the same as extension functions under the hood, but they come with the regular property syntax. *They may only be "computed" properties, because to store data, the original class would have to be modified.*

As an example of an extension property, let's add a `bd` property to the `Int` type, to quickly and easily create `BigDecimal` instances:

```kotlin
val Int.bd: BigDecimal
    get() = BigDecimal(this)
    
val thousand: BigDecimal = 1000.bd
println(thousand)
```

Inside the getters and setters of these properties, the current instance is available as `this`, as you might expect.

### Member extensions

Extensions may also be declared *inside a class* (or interface, or object) as a member. In these cases, the extensions behave differently from top-level extensions.

First of all, they will have two receivers available as `this`. The *dispatch receiver*, which is the instance of the enclosing class, and the *extension receiver*, the instance of whatever type the extension was defined on. In ambiguous cases, the extension receiver will take precedence (in other words, the closer `this` scope):

```kotlin
class Queue(val length: Int) {
    fun String.process() {
        println(length) // String's length
        println(this.length) // String's length
        println(this@Queue.length) // Queue's length
    }
}
```

The dispatch receiver can be accessed with a [qualified `this`](https://kotlinlang.org/docs/this-expressions.html#qualified), which is also used when choosing from multiple implicit receivers in other situations, such as in nested classes.

These member extensions are *not* static, instead, they are regular member functions under the hood. This means that overriding and dynamic dispatch *does* happen, although not by the type that is extended, but by the containing type.

You can make these extensions `open` or `abstract`, and have subtypes implement them:

```kotlin
abstract class Validator {
    protected abstract fun String.isValid(): Boolean

    fun validate(str: String?): Boolean {
        return str != null && str.isValid()
    }
}

class EmailValidator : Validator() {
    override fun String.isValid(): Boolean {
        return this.contains('@')
    }
}
```

While this is technically possible, it's often simpler to use regular functions that take the receiver as an explicit parameter.

There _are_ valid use cases for these types of extensions. These declarations are only visible within the class that they're declared in, which is a way of scoping extensions that won't be widely used in a project.

However, they also come with some surprising behaviour, which can be avoided by using private, top-level extensions, or even function-local (covered later, [in chapter 6](./6.md#local-functions)) extensions instead, if applicable.

### Context receivers

Context receivers are an [upcoming feature in Kotlin](https://kotlinlang.org/docs/whatsnew1620.html#prototype-of-context-receivers-for-kotlin-jvm), and they're essentially a variant of extension functions. 

They are currently available only as a prototype, and only on the JVM target, therefore we won't cover them here, other than to note their existence.

You can learn more about them in [this official Kotlin video](https://www.youtube.com/watch?v=GISPalIVdQY).

## Function types

Other than supporting top-level, standalone functions, perhaps the most important functional aspect of Kotlin is its support for function types.

Take this class and this function for example:

```kotlin
data class Person(val name: String, val age: Int)

fun createGreeting(person: Person): String {
    return "Hello, ${person.name}"
}
```

This function takes a `Person` parameter, and returns a `String`. The type of this function is `(Person) -> String`. The function type that takes no parameters and returns no value would be `() -> Unit`. A function that adds two whole numbers together could have the type `(Int, Int) -> Int`.

Variables can have these function types in Kotlin. If we wanted to store the function above in a variable, we could either store a reference to it:

```kotlin
val greetingCreator: (Person) -> String = ::createGreeting
```

Or declare the entire function in-line, and assign it to a variable with a function type immediately (this is very, very rarely used):

```kotlin
val greetingCreator: (Person) -> String = fun(person: Person): String {
    return "Hello, ${person.name}"
}
```

Functions can be invoked from references the same way as usual, with the `()` syntax, passing in any parameters:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

### Lambdas

Instead of declaring anonymous functions with the full function syntax and the `fun` keyword, we can use function literals, or *lambdas*. The previously seen `greetingCreator` function could be implemented in a lambda like this:

```kotlin
val greetingCreator = { person: Person -> "Hello, ${person.name}" }
```

This variable still has the same type as before (`(Person) -> String`), but we are now letting the compiler infer it based on the expression on the right-hand side.

To explain the syntax briefly: the braces `{}` create a new function literal. The input parameters of the function are listed at the very start, inside the braces. As usual, types come after names, and multiple parameters are separated by commas. Then, the `->` separates the parameter list from the body of the lambda.

Lambdas may contain multiple expressions, and they implicitly return their last expression, without a `return` keyword:

```kotlin
val greetingCreator = { person: Person ->
    println("Creating greeting for ${person.name}...")
    "Hello, ${person.name}"
}
```

This function, now defined as a lambda, can still be invoked the same way as before, as the type of the variable hasn't changed:

```kotlin
val julie = Person("Julie", 36)
println(greetingCreator(julie)) // Hello, Julie
```

If we provide the type of the variable that holds a lambda on the left-hand side, we can omit the type of the lambda's parameter, and let type inference work the other way:

```kotlin
val greetingCreator: (Person) -> String = { person -> "Hello, ${person.name}" }
```

For lambdas that have *only a single parameter*, one final simplification may be performed - we can skip naming the parameter altogether (given that its type can be inferred from context). In this case, it will be available via the implicit name `it`:

```kotlin
val greetingCreator: (Person) -> String = { "Hello, ${it.name}" }
```

> It's common to see long, complex lambdas use this implicit `it` name for their parameter. Be wary of doing this - naming the parameter can go a long way towards increasing readability and avoiding mistakes of operating on the wrong object. A good rule of thumb is to use an explicit name when your lambda doesn't fit on a single line.

### Method references and bound references

We've seen references to top-level functions. You can also reference methods of a specific class, and then invoke them by passing in a concrete instance:

```kotlin
class Person(val name: String) {
    fun speak() {
        println("Hi, I'm $name!")
    }
}

val speak: (Person) -> Unit = Person::speak
val grace = Person("Grace")
val rebecca = Person("Rebecca")
speak(grace) // "Hi, I'm Grace!"
speak(rebecca) // "Hi, I'm Rebecca!"
```

References may also be bound to a specific instance, for example:

```kotlin
val claudia = Person("Claudia")
val speak: () -> Unit = claudia::speak
speak() // "Hi, I'm Claudia!"
```

Dealing with these method references skirts the boundaries of Kotlin's reflection features, which we'll explore later on.

> To explore a bit, take a look at what the inferred types of these references would be if we didn't type them explicitly.

## Higher-order functions

### Introduction

A *higher-order function* is a function that takes another function as a parameter or returns a function.

Kotlin has support for function types, and we've seen how we can store functions in variables. Passing them in and out of functions is a small step up from here technically, but it will open up a whole new world of possibilities.

Let's start with one of the simplest of higher-order functions, one that executes the function (i.e. a given piece of code) passed to it:

```kotlin
fun execute(actions: () -> Unit) {
    actions()
}

execute({ println("Hello world") }) // Hello world
```

Calling the function passed in just once is the simplest thing to do. We could also store this function, `actions` - which really is just a piece of code at the call site - and we could invoke it at any later point in time.

Or we could introduce a new parameter, and call it repeatedly - we'll also rename our function, which does more than just execute the parameter now.

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

repeat(3, { println("Hello world") })
```

At this point, the IDE is screaming at us with a warning, suggesting that we change our code style. Whenever a function's last parameter is a function type, and the corresponding argument is a lambda, we can move that lambda outside the parentheses:

```kotlin
repeat(3) { println("Hello world") }
```

If we reformat this a bit with some newlines, our `repeat` function will start looking *a lot* like a built-in language construct, such as a `for` loop...

```kotlin
repeat(3) {
    println("Hello world") 
}
```

### FunctionX types

We've seen that with function types, we can assign functions to variables, and even pass them around - a lot of possibilities open up in front of us. How does this work under the hood?

Kotlin lambdas on the JVM are implemented as anonymous classes, which implement certain interfaces. For example, the `Function0` interface is used for functions that take no parameters. For single-parameter functions, there's a `Function1` type. And so on, and so on. Here's the declaration of these two interfaces, *simplified* (you can always check out their [full source](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/functions/Functions.kt)):

```kotlin
interface Function0<R> {
    fun invoke(): R
}

interface Function1<P1, R> {
    fun invoke(p1: P1): R
}
```

> These numbered function types only go up to `Function22`, but the upper limit for the number of function parameters is 255 on the JVM. Try to find out what happens with function types that have more than 22 parameters!

These functional interfaces - such as `Function1` - all define just a single `invoke` method, which will have a signature that corresponds to their function type, and its body will contain the body of the function in whatever class implements it.

Creating instances of interfaces like these, storing references to them, and calling methods on them are very basic things that you could do in Java as well - Kotlin just provides all the syntactic sugar for doing it conveniently.

In fact, let's call our `repeat` function from Java, to see how we can create the `Function0` it requires as a parameter by hand.

```java
repeat(3, new Function0<Unit>() {
    public Unit invoke() {
        System.out.println("Hello world");
        return Unit.INSTANCE;
    }
});
```

`Unit`, the generic parameter of `Function0`, is the return type of this no-parameter function type.

> `Unit`-returning functions, and especially lambdas, are inconvenient in Java, as you have to explicitly return `Unit.INSTANCE`, unlike with `void` methods, where you can simply omit the return statement.

### Optimizations

Let's go back to our previous call from Kotlin that we've made to this same `repeat` function:

```kotlin
repeat(3) { println("Hello world") }
```

... and see what it decompiles to. We expect to see basically the same code as we've just written in Java, however...

```java
repeat(3, (Function0)null.INSTANCE);
```

It turns out the built-in decompiler isn't able to handle this code. This is a good example of things that it simply can't deal with for the time being. If we use a better decompiler (such as [jadx](https://github.com/skylot/jadx)), we'll quickly discover what's going on:

```java
final class HelloKt$example$1 implements Function0 {
    public static final HelloKt$example$1 INSTANCE = new HelloKt$example$1();
    
    public final void invoke() {
        String str = "Hello world";
        System.out.println(str);
    }
}
```

There was a class generated which implements `Function0` and prints `"Hello world"` in its `invoke` method, as expected. It also contains an extra member: a static instance of itself!

Since this lambda relies on no external values or parameters in its `invoke` method, the compiler optimizes it into a singleton, so that only a single instance of it is ever created and used over the lifetime of our program.

`null.INSTANCE` in the decompiler output, then, is just a read to this static field to get the instance, except the decompiler didn't manage to resolve the classname for some reason. What we should see there is this:

```java
repeat(3, (Function0) HelloKt$example$1.INSTANCE);
```

### Capturing values

We've seen what happens when a lambda relies on no external values. This often isn't the case though. Lambdas act as [closures](https://en.wikipedia.org/wiki/Closure_(computer_programming)), which means they will capture any variables from outer scopes that are referenced inside them.

Take for example this extension, which "multiplies" a string, making use of our existing `repeat` method:

```kotlin
fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

The lambda being passed in to `repeat` here reads *and modifies* the `result` variable from an outer scope.

We can imagine capturing a variable with an anonymous class in Java as well - the requirement for this is that the reference being captured needs to be *final*:

```java
public static String multiply(final String $this, int times) {
    final String result = "";
    repeat(times, new Function0<Unit>() {
        public void invoke() {
            result = result + $this; // e: Cannot assign a value to final variable 'result' 
            return Unit.INSTANCE;
        }
    });
    return result;
}
```

However, modifying this `String` is another story. Since we can't change what the `result` reference points to, we'd need to modify the object it points to... But the `String` type on the JVM is immutable.

So that's our catch-22 here: we need the reference to be final so that we can capture it, but we also need it to be mutable so that we can assign newly created `String` instances to it. In Java, this might feel unsolvable at first, and needs some kind of workaround. In Kotlin, the code above compiles and works as expected.

What's happening under the hood? Let's decompile!

```java
@NotNull
public static String multiply(@NotNull final String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    final ObjectRef<String> result = new ObjectRef(); // 1
    result.element = ""; // 2
    repeat(times, new Function0() {
        public final void invoke() {
            ObjectRef var10000 = result; // 3
            String var10001 = var10000.element;
            var10000.element = var10001 + $this$multiply;
        }
    });
    return result.element; // 4
}
```

1. There's an instance of the `ObjectRef` class being created. This class is just a wrapper around a generic value (its definition here is slightly simplified):

    ```java
    public class ObjectRef<T> {
        public T element;
    }
    ```
    
    This reference to the `ObjectRef` instance is *final*, so it can be captured by an inner class.

2. The empty `String` instance we start with is stored in the *mutable* reference inside the `ObjectRef`.
3. Inside the lambda, the current `String` instance is removed from the `ObjectRef`, concatenation happens, and then the new `String` instance is placed in the `ObjectRef`.
4. Whatever reference ends up being in the `ObjectRef` by the time the method reaches its last line is returned.

`ObjectRef` is one of several wrappers that can provide an extra level of indirection in the bytecode to allow capturing mutable references. This one is used for reference types, such as `String`. An additional wrapper just like it exists for each primitive type for performance reasons - [see them all here](https://github.com/JetBrains/kotlin/blob/master/libraries/stdlib/jvm/runtime/kotlin/jvm/internal/Ref.java).

These aren't types you need to use yourself - the Kotlin compiler will deploy them as necessary when you capture values from outer scopes that you want to mutate. However, it's good to know that this happens, as it might cause memory leaks if you're not careful.

> If you're writing Java code, you can make use of this pattern manually to solve similar problems.

### Inline functions

Passing around lambdas is simple, convenient, and it allows for powerful abstractions that we'll see great examples of when we discuss collections. However, the previous example shows that we pay a price when passing in lambdas to functions. Each lambda will cost an object allocation, and capturing references can also lead to further allocations.

Let's be greedy. What if we could have our cake and eat it too? What if we could get these abstractions "for free", with no runtime performance hit?

This is where *inline functions* come to the rescue. Their name describes what they are fairly well. They are functions that get *inlined* to wherever they're called from. For the simplest example, take the following `greet` method, and the call to it in `main`:

```kotlin
inline fun greet(name: String) {
    println("Hello, $name!")
}

fun main() {
    greet("Abby") // Hello, Abby!
}
```

Decompiling the `main` function, you'd usually expect to see just one line, the call to `greet`. Instead, you'll see this:

```java
public static final void main() {
    String name$iv = "Abby";
    String var2 = "Hello, " + name$iv + '!';
    System.out.println(var2);
}
```

The entire body of the `greet` function has been "copy-pasted" to the call site, with any parameters substituted as well. This is what inlining does.

With a function as simple as this, the IDE will warn us that the gains from inlining the method won't be very significant, as function calls are not too expensive in general. It's up to you to decide in each case whether inlining a certain function is worth it.

> If you have a very long, complex function, inlining might not be the best idea. Every time you call it, its contents will be copied to the call site, bloating your compilation output.

Where inlining is definitely useful and often recommended is with higher-order functions, as it can get rid of allocations! Just like parameters are substituted into the inlined function body, so are the contents of lambdas that are called inside the inline function. That sounds complex, but let's take a look at it in practice.

Taking our previous example of `multiply`, and adding the `inline` modifier to `repeat`:

```kotlin
inline fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun String.multiply(times: Int): String {
    var result = ""
    repeat(times) {
        result += this
    }
    return result
}
```

After decompiling, there's no call to `repeat` present anymore. The loop from that function body simply exists directly in the `multiply` method, as if we've written it ourselves right there:

```java
@NotNull
public static String multiply(@NotNull String $this$multiply, int times) {
    Intrinsics.checkParameterIsNotNull($this$multiply, "$this$multiply");
    String result = "";
    int var4 = 0;
    for (int var5 = times; var4 < var5; ++var4) {
        result = result + $this$multiply;
    }
    return result;
}
```

Inlining is most often used with higher-order functions, where there is a very clear performance gain. Another good use case is when wrapping existing, difficult-to-use APIs with extensions. By inlining your wrappers, the bytecode produced is _exactly_ the same as if you've written the code the complex way (no extra call to a static helper function), but your source can be simpler thanks to your extensions. Free abstraction!

> The [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/repeat.html) function is actually part of the Standard Library, so you shouldn't implement it yourself.

##### Non-local returns

Return statements inside lambdas can get quite complicated. Take the example where we want to `return` inside this `repeat` function (changed to be non-inline again!) on some condition:

```kotlin
fun repeat(times: Int, actions: () -> Unit) {
    for (i in 0 until times) {
        actions()
    }
}

fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return
        }
        println("Success")
    }
}
```

You might expect this `return` to return within the lambda, and to skip just a single iteration of the loop. This is not the case. The rule for a `return` statement is that by default, it always returns from the closest `fun`. In this case, this would be the `test` function.

Such a return inside this lambda isn't allowed, as the `repeat` function could do many things with its parameter - for example, store it and invoke it later. In those invocations, the lambda containing a `return` from `test` wouldn't make any sense!

> The closest `fun` rule means that there's a difference between anonymous functions declared with `fun() {}` and function literals declared with `{}` when it comes to returns!

So how do we return from just a single iteration of the lambda? We have to qualify the `return` statement with the scope that we want to return from:

```kotlin
fun test() {
    repeat(10) {
        if (Random.nextDouble() > 0.6) {
            println("Failure")
            return@repeat
        }
        println("Success")
    }
}
```

What about the other case, can we somehow return from the `test` function from inside a lambda?

Yes! The solution for this is to inline the `repeat` function. This way, we know that the lambda we pass to it will only be executed in place, within the context of the `test` function. This will let us compile our original code above, and cancel `repeat` altogether on the first failure.

##### noinline and crossinline

When you inline a function, by default, all of its lambda parameters will be inlined. You can use `noinline` to mark any lambda parameters that you _don't_ want to be inlined - instead, they'll be passed in the regular way, with a function object being allocated for them. This will prevent you from using non-local returns in these lambdas, but allow you to, for example, store them in properties for later use.

> TL;DR: `noinline` prevents the inlining of a given parameter with a function type, and passes it in the regular way, like to any non-inline function.

A slightly more complex use case is when you're passing in a lambda somewhere and you want it inlined, but you can't allow non-local returns from it, as it doesn't make sense in the execution context.

For example, here, `body` would be inlined inside the `run` function's body. At the call site, since we're in an inline function, we'd expect to be able to use `return` freely to return from `test`, but the `Runnable` that's being created will have no context of the `test` method, and couldn't perform a return from it.

```kotlin
inline fun funky(body: () -> Unit) {
    val runnable = object: Runnable {
        override fun run() { 
            body()
        }
    }
    runnable.run()
}

fun test() {
    funky {
        // Return could not work here
        println("This is really quite complicated!")
    }
}
```

We could solve this by marking `body` with `noinline`, but then we'd suffer an object allocation, and inside `run`, we'd see something like this after compilation:

```java
new Runnable() {
    public void run() {
        body$iv.invoke();
    }
};
```

Instead of this, we can use `crossinline`, which will still inline the lambda's contents (*inside* the `run` method of the `Runnable` being created), but prevent non-local returns from being used inside it. This fixes our context issues, and still saves us the allocation:

```java
public static void test() {
    Runnable runnable = new Runnable() {
        public void run() {
            String var2 = "This is really quite complicated!";
            System.out.println(var2);
        }
    }
    runnable.run();
}
```

> TL;DR: `crossinline` disables non-local returns in a parameter with a function type, removing some limitations on how you may use it.

In general, you don't need to worry about remembering the exact mechanics of `noinline` and `crossinline`, as they are rarely used. But it's useful to know they exist so that you can look them up as needed. When you get into the special situations that require them while writing your own code, your IDE will most likely suggest adding them automatically.

### Typealiases

Typealiases let you rename types. As their name says, they don't create new types, just aliases for existing ones. This can come in handy when you want to rename a type for local use (similarly to renaming an imported symbol, but not just for a single file), and they are perhaps most often used to give semantics to function types.

Take the example of a `View` interface that allows you to register a click listener:

```kotlin
interface View {
    fun setOnClickListener(listener: () -> Unit)
}
```

Instead of the regular function type of `() -> Unit`, you may choose to be more expressive, and use a typealias for this parameter:

```kotlin
typealias OnClickListener = () -> Unit

interface View {
    fun setOnClickListener(listener: OnClickListener)
}
```

These two types will be cross-compatible. You can assign an `OnClickListener` to something with the type `() -> Unit` and vice versa, because they *are* the same type.

### Inline classes

You might find it odd that we're discussing a type of class here instead of in the earlier chapter about object-oriented programming. However, inline classes relate to two topics we've just covered: inline functions and typealiases. 

An inline class is a wrapper around a single value: it must have exactly one property in its primary constructor. At runtime, usages of the inline class will be replaced by just its contained value ([wherever possible](https://typealias.com/guides/inline-classes-and-autoboxing/) - same as usages of primitives). The idea for these classes is very similar to that of inline functions: allowing you to create extra constructs in your source code, but then eliminating runtime overhead by rewriting the code during compilation.

If your inline class wraps a primitive type, you'll even get all the [performance benefits of using a primitive](./1.md#primitives-vs-boxed-types) at runtime.

Let's take the example of a class that represents an RGB color value. To declare an inline class, we have to use both the `value` keyword and the `@JvmInline` annotation.

```kotlin
@JvmInline
value class Color(private val value: Int)
```

> The `@JvmInline` annotation might seem excessive - why not just `inline class` instead? Inline classes are just one small usages of a more general concept, *value classes*, which will get more support in Kotlin in the future. You can read about this in great detail in the [value classes KEEP document](https://github.com/Kotlin/KEEP/blob/master/notes/value-classes.md). 

Since this is a class, we can add properties and methods to it - with the limitation that it can't have properties that would require backing fields. Since the usage of this class is replaced at runtime with just a primitive `Int`, there would be nowhere to store such values.

We can still add properties without backing fields, for example, convenient accessors for each component of the color:

```kotlin
@JvmInline
value class Color(private val value: Int) {
    val red: Int
        get() = (value shr 16) and 0xFF
    val green: Int
        get() = (value shr 8) and 0xFF
    val blue: Int
        get() = (value shr 0) and 0xFF
}
```

The class is used the same way as any other: we can create instances via the constructor, and access members:

```kotlin
val myColor = Color(0x005FFF)
println(myColor.red)    // 0   (00)
println(myColor.green)  // 95  (05)
println(myColor.blue)   // 255 (FF)
```

However, if we decompile the bytecode that this usage of our inline class outputs, we'll see something like this (simplified here!):

```java
int myColor = Color.constructor-impl(24575);
System.out.println(Color.getRed-impl(myColor));
System.out.println(Color.getGreen-impl(myColor););
System.out.println(Color.getBlue-impl(myColor));
```

`myColor` is just a simple primitive `int` value, giving us great runtime performance. The methods and properties of the `Color` class are turned into static functions, which receive the `$this` value to operate on as a parameter (this "trick" should be familiar by now!):

```java
public static int getRed_impl(int $this) { return $this >> 16 & 255; }
public static int constructor_impl(int value) { return value; }
```

> This `Color` class could be improved by adding some range checks to its constructor (into an `init` block). Thanks to how inline classes work, that code would actually be invoked at runtime and could perform its task - even though no class instance is actually constructed.

While typealiases for the same type (and the original type itself) are cross-compatible, inline classes *create new types*, which means that this code won't compile:

```kotlin
val color: Color = 0 // e: The integer literal does not conform to the expected type Color 
```

Kotlin supports [unsigned numerical values](https://kotlinlang.org/docs/basic-types.html#unsigned-integers) such as `UInt` and `ULong`. Under the hood, these are implemented as inline classes as well, simply wrapping their signed counterparts! This way these unsigned types can also be represented as primitives when used on the JVM.

### SAM conversion, SAM constructor

Getting back to the topic of function types, one of Kotlin's primary Java interop features has to be mentioned. We've seen the `FunctionX` interfaces in Kotlin, which served the sole purpose of wrapping a block of code in a class instance, with their single `invoke` method.

Modern Java versions support lambdas as well, but lack truly standard function types, so libraries usually introduce their own (in addition to the many that are included in the platform, such as [`Predicate`](https://docs.oracle.com/javase/8/docs/api/java/util/function/Predicate.html) or [`BiFunction`](https://docs.oracle.com/javase/8/docs/api/java/util/function/BiFunction.html)). You are encouraged to create your own as well, and mark it with [`@FunctionalInterface`](https://docs.oracle.com/javase/8/docs/api/java/lang/FunctionalInterface.html), indicating that it's supposed to be used in a functional manner, often instantiated with lambda syntax.

The requirement for a functional interface is simple: have a single method that you require to be implemented. These are often also called Single Abstract Method (SAM) interfaces.

Kotlin supports passing in lambdas and functional types as parameters where an implementation of a Java-declared functional interface is expected. For example, given this Java code:

```java
interface View {
    interface OnClickListener {
        void onClick(View view);
    }

    void setOnClickListener(OnClickListener listener);
}
```

The way to pass in an instance of `OnClickListener` in Kotlin would be to create a separate class that implements the interface and instantiate it, or to use an `object` expression:

```kotlin
view.setOnClickListener(object: View.OnClickListener {
    override fun onClick(view: View) {
        println("Clicked!")
    }
})
```

This is a lot of code for just the single line print statement that we're trying to pass in here. Using *SAM conversion*, we can pass in a lambda that matches the signature of the single method in the interface, in this case, one that has the type `(View) -> Unit`:

```kotlin
view.setOnClickListener { 
    println("Clicked!") 
}
```

The compiler will perform the heavy lifting here, creating an object instance under the hood that implements `View.OnclickListener` and contains the code of the lambda inside the `onClick` method.

When the conversion would be ambiguous due to overloads, or you want to be more explicit about creating an instance, the slightly more verbose *SAM constructor* syntax may be used:

```kotlin
view.setOnClickListener(View.OnClickListener {
    println("Clicked!")
})
```

> One drawback of SAM conversions is that inside the lambda being passed in, there is no `this` reference to the lambda instance. If you need this reference (for example, for a listener to unregister itself in certain cases), you'll have to use the full object expression syntax.

### Functional interfaces in Kotlin

You can declare functional interfaces in Kotlin as well. These are marked not by an annotation (as the Java convention), but with a keyword instead: the `fun` keyword!

```kotlin
fun interface OnClickListener {
    fun onClick(view: View)
}
```

A functional interface can only have a single abstract method (but may have other, non-abstract methods as well). When you need to pass in an instance of such an interface somewhere, you can use the full object expression syntax, but you can also make use of SAM conversions or SAM constructors, exactly as seen in the previous section.

> Fun interfaces are a relatively new feature, available [since Kotlin 1.4](https://kotlinlang.org/docs/whatsnew14.html#sam-conversions-for-kotlin-interfaces). Previously, SAM conversions only worked for interfaces declared in Java, as it was specifically an interop feature for convenience. SAM conversion for Kotlin-declared interfaces was not supported, the reasoning being that you could just use function types in Kotlin instead of interfaces. However, there are times when using a dedicated interface type is more practical than using those function types.

## Summary

One of Kotlin's most advertised features is extensions, which allow you add new functionality onto existing types, even ones that you don't own yourself.

Functions are first-class citizens, just like classes or objects. They can be declared as top-level constructs in a file, and imported individually. Function types are a core part of the language, and they allow functions to be stored in variables, or passed around as parameters. Lambda expressions (function literals) are a concise way to define functions, especially if you're immediately passing them in as parameters.

Functions that take functions as parameters or return functions are called higher-order functions. The cost of passing function parameters to them (implemented as instances of classes under the hood) can be mitigated by making them inline. In certain situations, `noinline` and `crossinline` can come in handy.

Finally, Kotlin provides SAM conversion and SAM constructors as a way to interop with functional interfaces that are declared in Java code, and it also supports declaring functional interfaces.

## Sources

- Official documentation:
  - [Extensions](https://kotlinlang.org/docs/reference/extensions.html)
  - [Higher-Order Functions and Lambdas](https://kotlinlang.org/docs/reference/lambdas.html)
  - [Inline functions](https://kotlinlang.org/docs/reference/inline-functions.html)
  - [Type aliases](https://kotlinlang.org/docs/reference/type-aliases.html)
  - [SAM Conversions](https://kotlinlang.org/docs/reference/java-interop.html#sam-conversions)
  - [Functional (SAM) interfaces](https://kotlinlang.org/docs/reference/fun-interfaces.html)
- [jadx - Dex to Java decompiler](https://github.com/skylot/jadx)

# Chapter 6: Functions, Functions, Functions!

[Previously](./4.md), we've covered Kotlin's first-class support for functions and function types. Now, let's dive even further into some of its capabilities related to functions.

### Local functions

We've seen that we can have functions that exist outside of classes, as top-level declarations in a file - these functions exist on the _package level_. On the other extreme, functions can also exist in very small scopes: within another function. This can come in handy for quick helper functions that won't be used anywhere else in the application.

For example, let's say you have to populate a details screen such as this one:

![A detail screen with a name, role, and address field.](images/6_detail_screen.png)

Here's the model class which contains the value of each field:

```kotlin
class FormData(
        val name: String?,
        val role: String?,
        val address: String?
)
```

The business rule is that for any fields that are missing a value, both the title and the corresponding value field should be hidden. Instead of writing this logic over and over again for each field, we can extract it into a local function, which will only be in scope within the enclosing function:

```kotlin
private fun updateFormData(formData: FormData) {
    fun setTextAndVisibility(title: Text, content: Text, text: String?) {
        val shouldBeVisible = text.isNullOrBlank().not()
        title.isVisible = shouldBeVisible
        content.isVisible = shouldBeVisible
        content.text = text
    }

    setTextAndVisibility(nameTitle, nameContent, formData.name)
    setTextAndVisibility(roleTitle, roleContent, formData.role)
    setTextAndVisibility(addressTitle, addressContent, formData.address)
}
```

> [`isNullOrBlank`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/is-null-or-blank.html) is one of the many handy `String` extensions from the Kotlin Standard Library. We'll take a look at more of them in the [next chapter](./7.md#strings).

Note that this function also has access to the parameters of the enclosing function - it acts as a closure.

### Function literals with receivers

As stated before, Kotlin doesn't generally claim to have original features. Almost everything it does has been done in other languages before - though Kotlin does often improve on syntax and cohesion.

One feature that Kotlin does claim to have uniquely is *function literals with receivers* (or lambdas with receivers). This a powerful combination of two features that we've looked at before: lambdas and extension functions.

Not only can a function type in Kotlin have parameters and a return type, it can also have a *receiver*. For example, take the following, simple extension function from earlier:

```kotlin
fun String.lastChar(): Char {
    return this[this.length - 1]
}
```

If we create a reference to this, and assign it to a variable, we can type it like so:

```kotlin
val ref: String.() -> Char = String::lastChar
```

> Notice that an extension function on a type can be referenced with the `::` syntax, just like any real member of that type.

Similarly to how `String.` preceded the function name at its declaration to indicate that it's an extension on the `String` type, when declaring a function type that's an extension, the same `String.` syntax can show up before the parentheses of the parameter list.

Next, we'll look at two examples of higher order functions which make excellent use of this feature.

#### The StringBuilder example

First, let's take a look at an example that showcases that we can be placed in the scope of *any* object with such a lambda, even ones that we don't create ourselves.

[`StringBuilder`](https://docs.oracle.com/javase/8/docs/api/java/lang/StringBuilder.html) is a well-known class from Java that allows us to assemble strings from pieces without having to create many intermediate `String` instances, which would then be thrown away, wasting allocations. The basic usage of its API looks like this:

```kotlin
// 1
val builder = StringBuilder()
// 2
builder.append("Little Timmy is ")
builder.append(age)
builder.append(" years old today")
// 3
val result = builder.toString()
println(result)
```

There's a pattern here, which is repeated every time a `StringBuilder` is used.
 
 1. We create an instance.
 2. We perform a set of actions on it (various `append` calls).
 3. Finally, we call `toString` on it, to fetch the `String` that we've built.

Let's extract this to a higher order function, using lambdas with receivers:

```kotlin
inline fun buildString(actions: StringBuilder.() -> Unit): String {
    val builder = StringBuilder() // 1
    builder.actions()             // 2
    return builder.toString()     // 3
}
```

This function receives a lambda as a parameter, which itself *is an extension on `StringBuilder`*. This is practically the same as a lambda that receives a `StringBuilder` as a parameter, it just takes that reference as its *receiver* instead - either way, it can operate on it.

Inside `buildString`, we perform the pattern pointed out earlier:
 
 1. We create a new instance of `StringBuilder`.
 2. We perform the `actions` *on* it - which we can do, as `actions` is an extension on `StringBuilder`.
 3. We extract and return the result stored in the builder.

The real magic, however, happens on the call site, which looks like this:

```kotlin
val result = buildString {
    this.append("Little Timmy is ")
    append(age)
    append(" years old today")
}
println(result)
```

Within the curly braces defining the lambda that we're passing in to `buildString`, we are in the body of an extension on the `StringBuilder` type. This means that `this` refers to *some instance* of a `StringBuilder` (in this case, this will be the one being created inside the `buildString` function). Methods on `StringBuilder` can also be called without a qualifier in front of them, as if we were within the body of that class.

> It's important to see that all we are doing is defining an extension function on `StringBuilder` (with a lambda, for the sake of this example), because that's what the `buildString` function requires as a parameter. After we pass this parameter in, we don't actually know what `StringBuilder` instance (or instances) this lambda will be called on, how many times, or at what time.

Being able to "set the scope" of a lambda to any object so that it can operate *on* it is an immensely powerful language feature, and we'll see it used for various purposes.

#### The database example

Another classic example of using a function literal with a receiver, as well as some other functional language features, is that of a database transaction (as presented [by Jake Wharton in this talk](https://youtu.be/A2LukgT2mKc?t=1463)). Let's say we have the following database interface:

```kotlin
interface Database {
    fun beginTransaction()
    fun commitTransaction()
    fun rollbackTransaction()
    fun insert(item: Int)
    fun delete(item: Int)
}
```

We'll assume that `insert` and `delete` might throw exceptions (`IllegalStateException`, specifically) if the item being inserted already exists, or if there's nothing to delete. Every modification has to happen inside a transaction, which can be started with `beginTransaction`, and then either cancelled with `rollbackTransaction` in the case of an error, or completed with `commitTransaction` if everything went well.

So basic usage when we need to interact with this database will look like this:

```kotlin
db.beginTransaction()
try {
    db.insert(11)
    db.delete(12)
    db.commitTransaction()
} catch (e: IllegalStateException) {
    db.rollbackTransaction()
}
```

We'd ideally want to focus on just the one tiny bit of code in the middle that matters to us from the example above - the insert and delete operations. Everything else is just boilerplate we'll repeat every time we touch the database. We can easily introduce a higher order function that takes care of all the ceremony of handling transactions and exceptions for us, extracting just that inner code into a parameter:

```kotlin
fun inTransaction(db: Database, block: () -> Unit) {
    db.beginTransaction()
    try {
        block()
        db.commitTransaction()
    } catch (e: IllegalStateException) {
        db.rollbackTransaction()
    }
}
```

We can now use this function as clients, by passing in our two operations in a lambda:

```kotlin
inTransaction(db) {
    db.insert(11)
    db.delete(12)
}
```

Now, let's make use of extension functions, and make our helper function an extension on `Database`, to make the call site even nicer:

```kotlin
fun Database.inTransaction(block: () -> Unit) {
    beginTransaction()
    try {
        block()
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}

db.inTransaction {
    db.insert(11)
    db.delete(12)
}
```

Next, let's make the lambda we're passing in take the `Database` as a parameter, so that we can make sure that our block of code operates on the same instance that we've started the transaction on:

```kotlin
fun Database.inTransaction(block: (Database) -> Unit) {
    beginTransaction()
    try {
        block(this)
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}
```

We now get the `Database` in our lambda as the single parameter, which means that it can be referred to as `it` by default:

```kotlin
db.inTransaction {
    it.insert(11)
    it.delete(12)
}
```

Now, to put our newly acquired knowledge of lambdas with receivers to work, it's time for another improvement. Even better than giving the lambda supplied by our clients a `Database` as a parameter, we can *put them in the scope of the `Database`* that they'll operate on, by making the lambda parameter an extension on that type.

```kotlin
fun Database.inTransaction(block: Database.() -> Unit) {
    beginTransaction()
    try {
        this.block() // or just block()
        commitTransaction()
    } catch (e: IllegalStateException) {
        rollbackTransaction()
    }
}
```

With that, the call site is as clean as can be - inside the braces, we're writing code as if we were in the `Database` class. We're also still in a transaction.

```kotlin
db.inTransaction {
    insert(11)
    delete(12)
}
```

Of course, we mustn't forget performance. Passing in a lambda would mean an object allocation, which we can avoid by making the method `inline`:

```kotlin
inline fun Database.inTransaction(block: Database.() -> Unit) { /* ... */ }
```

Having the code handling transactions and performing the try-catch inlined will result in bytecode that's the same as if we've written these structures around our database operations everywhere in our codebase where we perform them. However, at the source level, we don't have to implement it over and over again. We've abstracted out the logic for it into a reusable function, and we did this, yet again, *for free*.

### Tail recursion

It's a relatively well-known fact (at least in computer science circles) that anything that can be solved iteratively can also be solved with recursion, and vice versa. Many problems lend themselves naturally to the recursive approach, calculating [factorials](https://en.wikipedia.org/wiki/Factorial) being one of them. The trivial recursive implementation of factorial looks like this:

```kotlin
fun fact(n: Int): Int {
    if (n == 0) 
        return 1
    return n * fact(n - 1)
}
```

This function works well enough - ignoring the upper limits of the `Int` type for the sake of this section - but it builds a call stack which is as deep as the parameter that was passed in. Why is this call stack maintained? Because when the last call of `fact` in the stack returns `1`, each level of the stack has to be visited backwards, so they can multiply the result calculated so far with their own `n` value, before returning it, thus removing their function call's frame from the stack.

There's another way to implement this same recursion, using an accumulator variable, `res`, which we'll expect clients to set to `1` initially. Inside the function, if we've reached the end of the recursion, we return whatever value is in `res`. Otherwise, we go a level deeper, decrementing `n`, and performing the multiplication on `res`.

```kotlin
fun fact(n: Int, res: Int): Int {
    if (n == 0)
        return res
    return fact(n - 1, res * n)
}
```

This means that instead of doing the multiplication going upwards, while unwinding the stack, we're instead performing it on the way down to the bottom. When we reach the bottom, we already have our final value computed. At this point, all the intermediate steps of walking back through the stack are unnecessary. Nothing happens in those intermediate functions anymore, they all just return what they've received from a level down. We don't really need the call stack here!

This is a well-known pattern, called [*tail recursion*](https://en.wikipedia.org/wiki/Tail_call). A function is tail-recursive if all of its recursive calls to itself are the very last call in the function (in a given execution branch, that is), and if the result of that recursive call is returned *as-is*, without any additional operations being performed.

In such functions, the recursive calls and the stack building can be optimized away, so that the recursion is replaced with an iterative solution *at compile time*. The trick is simple: instead of performing a recursive call at the tail of the function, simply rewrite the values of the function's parameter with those values that are in the recursive call's parameter list (in the current call frame), and then jump back to the beginning of the function to execute it again! This is semantically the same as performing the recursive call, but it doesn't deepen the stack.

Some compilers perform this optimization automatically when they notice that a function is tail recursive. Kotlin, however, chooses to be explicit about this. You have to mark your function with the `tailrec` keyword for the optimization to kick in:

```kotlin
tailrec fun fact(n: Int, res: Int): Int {
    if (n == 0)
        return res
    return fact(n - 1, res * n)
}
```

[Why?](https://stackoverflow.com/q/51638557/4465208) Well, mostly to make sure that whatever you want optimized is truly eligible for the optimization. If you mark a function that's not truly tail recursive with the keyword, you'll get a warning.

This tail-recursive implementation comes with the downside of requiring callers to pass in an extra `1` as a parameter, which is a bit odd. This can be easily fixed by adding a one-parameter helper function for clients to use (and the recursive function could then be marked `private`):

```kotlin
fun fact(n: Int) = fact(n, 1)
```

### The Standard Library's scoping functions

The Standard Library contains a small suite of very simple functions that perform basic "scoping" operations, using features we've learned about: higher order functions and function literals with receivers.

These are used so frequently in Kotlin that they are often seen as language features - but it's important to see that these are not special whatsoever, and you could implement any of them in a minute. They, as many other constructs in the language, are just *functions*.

#### The `let` function

Let's start with [`let`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/let.html). `let` is defined as an extension on a generic `T` type, so you can invoke it on any value. It takes a lambda as its parameter, which accepts the same `T` type, and returns some `R` type.

This all sounds rather abstract, so let's just take a look at the implementation:

```kotlin
public inline fun <T, R> T.let(block: (T) -> R): R {
    return block(this)
}
```

So what does `let` do, in simple terms? It executes the piece of code you pass to it (usually as a lambda). Your lambda will be called with the receiver of `let` as its parameter. Whatever you return from the lambda will also be the return value of the `let` call. 

Take this example:

```kotlin
val length = File("./README.md").let {
    println(it.name)
    println(it.absoluteFile)
    println(it.length())
    it.length()
}
```

Inside the lambda, `it` will refer to the `File` instance, as that's what you've called it *on* - that's the receiver of `let`. The last expression of the lambda will be the return value of the entire `let` call.

> Remember the [`map`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/map.html) function? You can think of `let` as a `map` operation on a single element.

You can use `let` instead of creating a local variable to introduce a temporary name for an object, if you give the lambda's incoming parameter an explicit name. Take a look at this usage of `let`:

```kotlin
File("./README.md").let { file ->
    println(file.name)
    println(file.length())
    println(file.absoluteFile)
}
```

Since `let` is `inline`, this is exactly equivalent* to the following code, which creates a regular local variable, with no extra cost at runtime (no actual lambda allocation, for example).

_*except `let` also contains the variable in its own scope_

```kotlin
val file = File("./README.md")
println(file.name)
println(file.length())
println(file.absoluteFile)
```

A popular use case for `let` is using it to perform `null` checks. Since there's a function invocation (not really, due to inlining, but semantically and on the source level) right before the actions are executed on the receiver of `let`, a safe call can be injected here:

```kotlin
val someFile: File? = ...
someFile?.let { file: File ->
    println(file.name)
}
```

If `someFile` happens to be `null`, the function call `let` will simply not be invoked by the safe call operator. If it *is* invoked, we get the receiver inside the lambda with a non-null type. This makes sense: if it *was* null, the lambda wouldn't be executing in the first place. This is a `null` check, which conditionally executes the code inside the lambda that we've passed in!

This `null` check is a versatile one. It can, for example, be used in the situation of dealing with a nullable, class level property which is declared as a `var`. We've seen before that these can not be `null`-checked and smart cast by regular means:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    if (timer != null) {
        timer.stop()
        // ^ This line doesn't compile!
    }
}
```

The issue was that the value of `timer` was being read again inside the body of the `if` statement, and it might have a new value by that time, which might be `null`.

This isn't an issue for the `?.let {}` idiom, however. Take the following code:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
    timer?.let {
        it.stop()
    }
}
```

If `timer` is not `null`, its current value is passed into the `let` function and then back into the lambda as a parameter. If the value of the property changes in the meantime, that change won't be reflected in the reference that the lambda receives - that reference is held onto as a parameter value, and can not change.

The `let` call here is equivalent to this longer, more manual solution:

```kotlin
private var timer: AnimationTimer? = null

override fun start(primaryStage: Stage) {
   val t = timer
   if (t != null) {
       t.stop()
   }
}
```

In essence, we are using `let` to very concisely create this local, temporary copy of the reference that's stored in the property.

#### The `apply` function

Along with `let`, [`apply`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/apply.html) is one of the most used scoping functions in Kotlin.

`apply` can also be called on any generic type, and it also takes a lambda as its parameter. This lambda is an extension on the type that `apply` was called on, and `apply` invokes the lambda on its receiver. In other words, the lambda is *applied to* the object. Finally, `apply` returns the original object. 

Here's all of that in code:

```kotlin
public inline fun <T> T.apply(block: T.() -> Unit): T {
    this.block()
    return this
}
```

Let's see a real-life use case. Take a `Rectangle` class, which only has a no-param constructor. If you want to create an instance and initialize it, you'll end up writing code like this:

```kotlin
val rect = Rectangle()
rect.x = 8.0
rect.y = 9.0
rect.width = 100.0
rect.height = 200.0
```

Using `apply`, you can move your code *into the scope of* that `Rectangle`, as its parameter will be an extension on the `Rectangle` type, and executed on the receiver. This lets you be a lot more concise with these assignments:

```kotlin
val rect = Rectangle().apply {
    x = 8.0
    y = 9.0
    width = 100.0
    height = 200.0
}
```

Remember our earlier `buildString` implementation?

```kotlin
inline fun buildString(actions: StringBuilder.() -> Unit): String {
    val builder = StringBuilder()
    builder.actions()
    return builder.toString()
}
```

We can now rewrite this using `apply`, to avoid having to create a local variable:

```kotlin
inline fun buildString(builderAction: StringBuilder.() -> Unit): String =
    StringBuilder().apply(builderAction).toString()
```

> The [`buildString`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/build-string.html) function is actually part of the Standard Library, with this exact implementation.

This is all that `apply` does: it executes an extension on its receiver, and then returns the original object. It's a quick way to open a lambda into the scope of an object, and is usually used at object creation and initialization.

#### Also, run.

There are two more extensions that are more rarely used variations on these previous two.

[`also`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/also.html) is similar to `apply`, as it returns its receiver. It also executes the lambda passed to it, but it passes in its receiver as a parameter (unlike `apply`, which exposed it to the lambda as a receiver). 

```kotlin
public inline fun <T> T.also(block: (T) -> Unit): T {
    block(this)
    return this
}
```

Like `apply`, this is usually used around object creation, to perform side effects:

```kotlin
fun register(name: String): Person {
    return Person(name).also {
        log(it)
    }
}
```

> This could also be done by using `apply`, it would simply change the syntax inside the lambda to `log(this)`. In general, a good rule of thumb is that you shouldn't really need to reference `this` inside an `apply` call. If you find yourself doing that, consider using `also` instead.

---

[`run`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/run.html) is similar to `let`, it returns the result of the lambda passed to it, performing a mapping operation. However, inside the lambda, it exposes its receiver as a receiver (unlike `let`, which uses a regular function parameter instead).

```kotlin
public inline fun <T, R> T.run(block: T.() -> R): R {
    return block()
}
```

---

Here's a handy chart to sum it all up:

![Chart of scope functions](images/6_scope_functions.png)

The [`with`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/with.html) function deserves an honourable mention. It's just like `run`, as it places code into the scope of a given object. However, instead of being an extension, it's a regular function that takes its "receiver" as the first parameter.

```kotlin
with(robot) {
    goForward()
    turnLeft()
    goForward()
    turnRight()
}
```

#### The `use` function

An excellent example of just how powerful Kotlin's features around functions are is its [`use`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/use.html) function. This function is equivalent to the try-with-resources construct in Java, which automatically closes a given resource when the end of its block is reached:

```java
try (PrintWriter writer = new PrintWriter(new File("test.txt"))) {
    writer.println("Hello World");
}
```

In Kotlin, we can replace this language construct with a simple call to a higher order function:

```kotlin
PrintWriter(File("test.txt")).use { writer -> 
    writer.println("Hello World") 
}
```

Here's a (greatly simplified) version of the `use` function's implementation, to give you an idea of how it works:

```kotlin
public inline fun <T : Closeable?, R> T.use(block: (T) -> R): R {
    try {
        return block(this)
    } catch (e: Throwable) {
        throw e
    } finally {
        close()
    }
}
```

> The real implementation has a lot more error handling - exceptions and Closables are a complex topic.

## Summary

Kotlin has a lot to offer when it comes to functions. It has functions in many scopes: top-level, member, and even local functions.

One of its most powerful functional features is *function literals with receivers*, which allows you to place the caller of your function into the scope of a specific type when they're defining a lambda.

The Standard Library offers several of its own scoping functions (building on lambdas with receivers, as well as higher order functions in general) that make simple, everyday tasks easier.

## Sources

- Official documentation:
  - [Local functions](https://kotlinlang.org/docs/reference/functions.html#local-functions)
  - [Function literals with receiver](https://kotlinlang.org/docs/reference/lambdas.html#function-literals-with-receiver)
  - [Scope Functions](https://kotlinlang.org/docs/reference/scope-functions.html)

# Chapter 7: Standard Library Showcase

The [Kotlin Standard Library](https://kotlinlang.org/api/latest/jvm/stdlib/) contains a vast amount of useful functions. This includes various utilities (some of which we've already seen), as well as extensions for many common types that makes working with them a lot easier than their original APIs. In this chapter, we'll look at some small helper functions used to describe preconditions, and then two commonly used groups of extensions, for the `String` and `File` types.

Finally, to put what we've learned about collection processing earlier into practice, we'll perform some processing on an interesting data set - crime statistics from Chicago.

## Preconditions

Whenever we define a function, we list the parameters that it takes, and the types of these parameters. This, however, is not quite enough to describe the _contract_ of a function. We might also want to specify how and when the function may be called. We might place a restriction on the current state of the application, or the values of the arguments that are being passed in. To look at how Kotlin helps us clearly state these expectations, we'll use a simple `Reader` interface:

```kotlin
interface Reader {
    fun open()
    fun close()
    fun readBytes(byteCount: Int): ByteArray
}
```

We'll implement a `FileReader` based on this interface, which can read the contents of a given file:

```kotlin
class FileReader(private val fileName: String) : Reader {

    private var inputStream: FileInputStream? = null

    override fun open() {
        inputStream = FileInputStream(File(fileName))
    }

    override fun close() {
        inputStream?.close()
        inputStream = null
    }

    override fun readBytes(byteCount: Int): ByteArray {
        val arr = ByteArray(byteCount)
        inputStream!!.read(arr)
        return arr    
    }

}
```

The reader can be initialized with a filename, and uses a [`FileInputStream`](https://docs.oracle.com/javase/8/docs/api/java/io/FileInputStream.html) to read from that file.

If we take a good look at `readBytes` method, we can find a couple of issues in it:

- There is a use of the `!!` operator here, which will result in a `NullPointerException` if the `open` method hasn't been called yet. Not exactly friendly behaviour.
- The other issue is less obvious: if a negative value is passed in as the parameter, we'll attempt to allocate an array with a negative length, which is invalid, and also produces an exception.

How can we make sure that these things don't happen? For starters, documenting these methods might be a good idea:

```kotlin
/**
 * Opens the reader. Every call to this method
 * must be followed by a call to [close] to
 * free up underlying resources, when the
 * reader is no longer being used.
 */
fun open()

/**
 * Closes the reader, freeing up any resources
 * associated with it.
 */
fun close()

/**
 * Reads bytes from the reader. The reader must
 * be open for this operation.
 * 
 * @param byteCount The number of bytes to read.
 *                  Must be a positive number.
 */
fun readBytes(byteCount: Int): ByteArray
```

> Kotlin's documentation format is called [KDoc](https://kotlinlang.org/docs/kotlin-doc.html). Its syntax is very similar to JavaDoc, but it extends it with Markdown support and some additional block tags that are Kotlin-specific (e.g. `@property`). [Dokka](https://github.com/Kotlin/dokka) may be used to generate documentation from Kotlin code comments.

This, of course, makes us reliant on everyone reading the documentation for our interface, and if the methods are used incorrectly, they'll still result in exceptions. To fix this, we'll use two functions from the Standard Library to codify our requirements for the `readBytes` method: `check` and `require`.

> What we're doing here falls in line with another item of *Effective Java*: *Item 49: Check parameters for validity*. There's also a corresponding item in the [*Effective Kotlin*](https://leanpub.com/effectivekotlin) book: *Item 5: Specify your expectations on arguments and state*.

[`check`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check.html) is meant to ensure that our application is in some expected state at the given time. What we want to check in this case is that our `inputStream` is non-null when `readBytes` is called:

```kotlin
override fun readBytes(byteCount: Int): ByteArray {
    val input = inputStream
    check(input != null) { "Reader must be opened first" }

    val arr = ByteArray(byteCount)
    input.read(arr)
    return arr
}
```

This call will throw an `IllegalStateException` with the given message if its parameter doesn't evaluate to `true`. As a bonus, thanks to [a certain advanced language feature](https://kotlinlang.org/docs/whatsnew13.html#contracts), the compiler can infer that the `check` function not throwing an exception means that `input` was not null, and gives us a smart cast from `FileInputStream?` to `FileInputStream`, which lets us get rid of the usage of `!!`.

Similarly, we can use [`require`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require.html) to state our expectations about the method's parameter, and will throw an `IllegalArgumentException` if the condition fails:

```kotlin
require(byteCount > 0) { "Byte count has to be a positive number (was $byteCount)" }
```

You might have noticed that the second parameter of these functions is not just a regular `String` - it's a lambda that returns a `String`. Why is this useful? This way, if the message has to be constructed (for example, concatenated together from multiple pieces, to include values of variables in it, like above), this computation won't happen on the happy path. If we were passing in a `String` as the parameter, we'd always have to format the error message before performing the check - unnecessarily, most of the time. The indirection that a lambda offers allows us to do this work lazily.

> You might ask: doesn't a lambda allocation's cost outweigh the gains of not assembling these `String`s? Take a look at the implementation of these functions to figure out why that's not an issue (but try to guess first!).

Notice how having these checks and requirements at the very top of our method makes them very easy to read if someone navigates to the source code. They are also clearly separated from the actual implementation of the method.

```kotlin
override fun readBytes(byteCount: Int): ByteArray {
    val input = inputStream
    check(input != null) { "Reader must be opened first" }
    require(byteCount > 0) { "Byte count has to be a positive number (was $byteCount)" }

    val arr = ByteArray(byteCount)
    input.read(arr)
    return arr
}
```

These checks that we've added are very similar to the [runtime null checks](./3.md#runtime-checks) added by the Kotlin compiler for nullable parameters, and they serve the same purpose: they prevent executing the implementation inside the method completely if given preconditions fail, instead of allowing an unexpected crash somewhere down the line.

> Handling exceptions in a way that leaves the application in a healthy state is actually yet another piece of advice from Effective Java: *Item 76: Strive for failure atomicity*.

> The `open` method also has a bug: if called multiple times without `close` being called, we'll lose references to open `FileInputStream` instances, thus leaking resources. Fix this bug using the helpers we've just learned about!

### Null checking

Preconditions are often about the nullness of values, checking whether something is null or not. Therefore, the Standard Library functions specifically for null checking, like [`checkNotNull`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/check-not-null.html), which could replace the usage of `check` above:

```kotlin
val input = checkNotNull(inputStream) { "Reader must be opened first" }
```

Like `check`, this function throws an `IllegalStateException` if its condition fails (if its parameter was null). Otherwise, it returns the value as a non-null type, allowing us to merge this check with the declaration of the `input` variable. Neat!

Notice that `checkNotNull` is essentially the same as writing down `inputStream!!`. However, it looks a bit more deliberate in your code, and it allows you to provide a meaningful exception.

> There's also a [`requireNotNull`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/require-not-null.html) function, which follows the semantics of `require`.

## Strings

When we're using strings in Kotlin, we're using the [`kotlin.String`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-string/) type - but under the hood, this is nothing but a [`java.lang.String`](https://docs.oracle.com/javase/8/docs/api/java/lang/String.html). This is another example of a [mapped type](https://kotlinlang.org/docs/java-interop.html#mapped-types). We are using the regular Java `String` at the bytecode level and at runtime, but at the source level, we see it through a different interface.

This interface has some slight changes from the Java variant (for example, `length` is a property, while it used to be a function), and is generally very bare-bones. Lots of the functionality that we can find right inside the `java.lang.String` class is missing. There's no `isEmpty`, `indexOf`, `toLowerCase`, and so on. Not even constructors!

```kotlin
package kotlin

public class String : Comparable<String>, CharSequence {
    companion object {}

    public operator fun plus(other: Any?): String
    public override val length: Int
    public override fun get(index: Int): Char
    public override fun subSequence(startIndex: Int, endIndex: Int): CharSequence
    public override fun compareTo(other: String): Int
}
```

Worry not, we're just looking at another example of [extension oriented design](./4.md#extension-oriented-design) here. The class contains only the very essential functionality that it needs (e.g. `get`, `length`, or `plus`), presenting a minimal API, and everything else is implemented on top of this as extensions.

```kotlin
println("".isEmpty()) // true
println("kitten".isEmpty()) // false
println("kitten".indexOf('t')) // 2
println("KitTeN".lowercase()) // "kitten"
```

Not only is the base functionality of `java.util.String` provided as extensions, there's much, much more in terms of useful functions:

```kotlin
println("".isNotEmpty()) // false
println("   \t   \n\t ".isBlank()) // true
println("   word       ".isNotBlank()) // true
println("kitten".lastIndexOf('t')) // 3
println("kitten".replaceFirstChar { it.titlecase() }) // "Kitten"
println("   kitten     ".trim()) // "kitten"
println("kitten".reversed()) // "nettik"
```

> A `String` is considered "blank" by these APIs if it only contains whitespace.

There's one more thing missing from the `kotlin.String` class: constructors. They are replaced by top-level factory functions, which use the widespread Kotlin convention of being named after the class that they're creating, making them look just like real constructors:

```kotlin
public inline fun String(chars: CharArray): String
public inline fun String(bytes: ByteArray): String

String(charArrayOf('a', 'b', 'c'))
String(byteArrayOf(0x68, 0x65, 0x78))
```

### Raw strings

A handy language feature that we didn't cover yet is [*raw strings*](https://kotlinlang.org/docs/basic-types.html#string-literals). A raw string is bounded by `"""` (triple quotation marks) on each end, and it can contain nearly any character. This includes those that usually have special meaning inside a `String`, such as `\`,  and even newlines.

> String templates, using `$`, are still evaluated as normal.

```kotlin
val map = """
    X X
     X 
    X X
"""
```

Printing the value of `map` above will print the following:

```

    X X
     X 
    X X

```

Both the newlines at the start and end of the string are present, as well as the indentation at the start of each line.

The Standard Library makes using multi-line strings even easier, by letting you manage the whitespace at the start of each line, to keep your code neatly formatted. To remove the smallest amount of common whitespace from the start of each line, you can use [`trimIndent`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-indent.html):

```kotlin
val map = """
    X X
     X 
    X X
""".trimIndent()
```

This makes our output a lot nicer:

```
X X
 X
X X
```

Another similar function is [`trimMargin`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/trim-margin.html), which will remove whitespace and the first occurrence of a given prefix character (`|`, by default) from each line:

```kotlin
val map = """
        |X X
        | X
        |X X
""".trimMargin()
```

In our example, this achieves this output again:

```
X X
 X
X X
```

These two functions might seem like they perform expensive computations - and they do. However, if you're using them on `String` instances that are constant at compile time, the calls to these functions will be optimized away during compilation.

> Check this by decompiling the previous examples!

## Files

Let's move on to dealing with files, through the [`java.io.File`](https://docs.oracle.com/javase/8/docs/api/java/io/File.html) class. Kotlin doesn't replace or map this class to another, but it augments it in many ways.

### Browsing files

The first functions we'll look at help us find the files that we want to work on. The `File` class represents both files and directories in the file system. Given a `File` that points to a directory, we can start a *walk* on the file tree from that node:

```kotlin
val walk: FileTreeWalk = file.walk()
```

A [`FileTreeWalk`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/-file-tree-walk/index.html) is actually a `Sequence<File>` (with some cool extra options), which will recursively enumerate all files (and directories) under the given directory.

This is a powerful API, since we can use any `Sequence` operations on this walk. For example, we can print the names of all files that have `IMG` in their name and have the `jpg` extension, in any subdirectory of the current one:

```kotlin
walk.filter { it.isFile }
        .filter { it.nameWithoutExtension.contains("IMG") }
        .filter { it.extension.equals("jpg", ignoreCase = true) }
        .forEach { file ->
            println(file.name)
        }
```

> [`nameWithoutExtension`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/name-without-extension.html) and [`extension`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/extension.html) are both *extensions* (pardon the pun) on the `File` class. You can also see a handy overload of [`String#equals`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/equals.html) at work here, allowing you to ignore case differences for the comparison.

### Reading and writing files

For read/write operations on a single file, let's start with an example in Java style, which reads lines from a file, and collects them into a `List<String>` (this example omits exception handling):

```kotlin
val file = File("filename")
val lines = mutableListOf<String>()
val reader = BufferedReader(FileReader(file))
var line: String? = reader.readLine()
while (line != null) {
    lines.add(line)
    line = reader.readLine()
}
reader.close()
```

Kotlin makes opening a file for reading or writing very simple with extensions. You can use these to open a stream for a file, or to access even higher level APIs, such as various readers and writers.

```kotlin
file.inputStream() // FileInputStream
file.outputStream() // FileOutputStream

file.reader() // InputStreamReader
file.bufferedReader() // BufferedReader

file.writer() // OutputStreamWriter
file.bufferedWriter() // BufferedWriter
file.printWriter() // PrintWriter
```

If you use these APIs, it's your responsibility to free these resources when you're done using them. Remember that you have the `use` function in the Standard Library that can do this for you safely. This function returns whatever the lambda passed to it returns, and closes the opened resource:

```kotlin
val lines = file.bufferedReader().use { reader ->
    val lines = mutableListOf<String>()
    var line: String? = reader.readLine()
    while (line != null) {
        lines.add(line)
        line = reader.readLine()
    }   
    lines
}
```

To simplify this snippet, you can also use [`forEachLine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/for-each-line.html), which runs a given action for each line in a file:

```kotlin
val lines = mutableListOf<String>()
file.forEachLine { lines.add(it) }
```

This function will open a `BufferedReader` on the given file, read its contents - performing your actions for each line - and then safely close the reader.

And then there's also an even simpler way...

```kotlin
val lines: List<String> = file.readLines()
```

Creating a list of `String` instances in memory for an entire file may be a costly operation if your file contains a large amount of data. If you don't need all of its contents to be loaded in memory at once (for example, if you can process them all individually, just on their own), you can use a lazy `Sequence` instead, with the help of [`useLines`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/use-lines.html).

Here's an example of calculating the average length of a line, using the `Sequence` API. This will pull in the lines of the file one by one during the processing, instead of all at once.

```kotlin
val avg: Double = file.useLines { lines: Sequence<String> ->
    lines.map { it.length }.average()
}
```

If you want to operate simply on the entire text content of a file, the Standard Library also has you covered: the [`readText`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/read-text.html) extension will give you the entire contents of the file as a single `String`, and the [`writeText`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/write-text.html) extension can be used to set a file's content to a `String`. Again, these wrap various operations with file streams.

## The crimes of the Windy City

To put our knowledge of file handling, string manipulation, and collection processing to the test, we'll perform some simple analysis on [freely available crime statistics from Chicago](https://data.world/publicsafety/chicago-crime).

The data set consists of three files, containing the stats from the years 2014, 2015, and 2016. The files are [CSVs](https://en.wikipedia.org/wiki/Comma-separated_values), and they contain data like this:

```
id,case_number,date,block,iucr,primary_type,description,location_description,arrest,domestic,beat,district,ward,community_area,fbi_code,latitude,longitude,location
9446824,HX100141,2014-01-01T02:00:00,0000X W ILLINOIS ST,0460,BATTERY,SIMPLE,STREET,false,false,1831,18,42,8,08B,41.890828047,-87.630234746,POINT(-87.630234746 41.890828047)
9446748,HX100020,2014-01-01T00:00:00,006XX N DEARBORN ST,0890,THEFT,FROM BUILDING,BAR OR TAVERN,false,false,1832,18,42,8,06,41.893541578,-87.629701805,POINT(-87.629701805 41.893541578)
9446758,HX100030,2014-01-01T00:30:00,052XX W RACE AVE,1310,CRIMINAL DAMAGE,TO PROPERTY,APARTMENT,false,false,1523,15,28,25,14,41.890046233,-87.756333158,POINT(-87.756333158 41.890046233)
9446760,HX100027,2014-01-01T00:30:00,053XX W WELLINGTON AVE,0460,BATTERY,SIMPLE,APARTMENT,true,false,2514,25,31,19,08B,41.935011125,-87.759739272,POINT(-87.759739272 41.935011125)
```

To get started, we'll need to get references to all of these files. Assuming that they're in a `data` folder, we can get a `List<File>` containing each file like this:

```kotlin
val years = listOf("2014", "2015", "2016")
val filenames = years.map { year -> "data/chicago_crime_$year.csv" }
val files = filenames.map { name -> File(name) }
```

Of course, we can use chained calls instead of declaring a new variable each time:

```kotlin
val files: List<File> = listOf("2014", "2015", "2016")
        .map { year -> "data/chicago_crime_$year.csv" }
        .map { name -> File(name) }
```

We'll perform all of our analysis in-memory for simplicity, however, refactoring this code to use the `Sequence` file APIs instead would greatly improve its performance.

> Consider doing this for practice!

We'll fetch all lines of each file, drop the first line containing the column names, and then collect all these lines into a single `List`. `flatMap` is the perfect operator to use here, as we want to map each file to many lines:

```kotlin
val allLines: List<String> = files.flatMap { file ->
    file.readLines().drop(1)
}
```

Our data is hard to reason about when it's in a single `String` for each record. We'll create instances of a class from each line instead:

```kotlin
val crimes: List<Crime> = allLines.map { Crime(it.split(",")) }
```

> Splitting a line in a CSV file on the `,` character is a very common practice, but it is incorrect. A single field in a CSV file may contain commas if it's surrounded by quotation marks (e.g. `"SCHOOL, PUBLIC, BUILDING"`), and the naive split on the `,` character parses such fields incorrectly. We're going to sweep this under the rug here by simply ignoring it, as correctly parsing a CSV file would be too tedious. As a result, we'll have *some* incorrect data after parsing, but this won't affect our results too much.

Let's create the `Crime` class, which will have fields that each correspond to a given column of the input data:

```kotlin
class Crime(data: List<String>) {
    val id: String = data[0]
    val caseNumber: String = data[1]
    val date: LocalDateTime = data[2].toLocalDateTime()
    val block: String = data[3]
    val type: String = data[5]
    val description: String = data[6]
    val locationDescription: String = data[7]
    val arrest: Boolean = data[8].toBoolean()
    val domestic: Boolean = data[9].toBoolean()
    val latitude: Double? = data[16].toDoubleOrNull()
    val longitude: Double? = data[17].toDoubleOrNull()
}
```

This class takes the `List<String>` produced by splitting the line, and then converts the `String` representing each field to a more concrete data type, using Standard Library functions.

The only conversion not provided to us is the Standard Library is the `toLocalDateTime` function. We'll implement this ourselves. Dates in our data are in the ISO 8601 local date-time format, for example: `2014-01-18T15:52:00`. We can easily obtain each of these number values with the following `String` operations:

```kotlin
private fun String.toLocalDateTime(): LocalDateTime {
    val date = this.substringBefore('T').split('-').map { it.toInt() }
    val time = this.substringAfter('T').split(':').map { it.toInt() }

    return LocalDateTime.of(date[0], date[1], date[1], time[0], time[1], time[2])
}
```

This code works, but the hardcoded indices for the various components of the date and time are hard to read and error-prone. *Did you notice the mistake in the code above?*

We can make our code much more legible by using *destructuring declarations* again. We've seen that we can do this for data classes - the good news is that the `List` type also supports it (more details on this in the very [next chapter](./8.md#destructuring)). When destructuring a `List`, we can grab the first N elements of it, up to five of them. This cleans up our code like this:

```kotlin
private fun String.toLocalDateTime(): LocalDateTime {
    val (year, month, day) = this.substringBefore('T').split('-').map(String::toInt)
    val (hour, minute, second) = this.substringAfter('T').split(':').map(String::toInt)

    return LocalDateTime.of(year, month, day, hour, minute, second)
}
```

While that was fun to perform on our own, `LocalDateTime` actually contains parsing functionality that we can rely on instead of having to write it ourselves:

```kotlin
private inline fun String.toLocalDateTime() = LocalDateTime.parse(this)
```

With that, we have a `List<Crime>` to work with. Let's answer some questions.

#### How many crimes do we have data about in total?

This is simple enough, we just need the size of the list!

```kotlin
println("# of crimes: ${crimes.size}") // # of crimes: 754541
```

#### What percentage of reports resulted in an arrest?

This information is in the `Boolean` property called `arrest`. We simply need to count the number of arrests made, and divide with the total number of crimes. We'll use [`count`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/count.html) for this:

```kotlin
val ratio: Double = crimes.count { it.arrest }.toDouble() / crimes.size
println("Arrest percentage: ${ratio * 100}%") // Arrest percentage: 24.438565962618334%
```

> Notice how we've converted the count to a `Double` value before dividing it. Otherwise, we'd have performed integer division, and most likely ended up with a `0` value.

Another interesting (though quite inefficient) way of calculating this ratio would've been to map each `Boolean` value to either `0` or `1`, and then average those values:

```kotlin
val ratio = crimes.map { if (it.arrest) 1 else 0 }.average()
```

#### How many cannabis-related arrests happened between 1 AM and 6 AM, on the CTA?

> CTA stands for [the Chicago Transit Authority](https://www.transitchicago.com/).

This is a job for the `filter` operation, as each condition we have can be described with an appropriate filter:

```kotlin
val result = crimes
        .filter { it.arrest }
        .filter { it.date.hour in 1..5 }
        .filter { it.locationDescription.contains("cta", ignoreCase = true) }
        .filter { it.description.contains("cannabis", ignoreCase = true) }
        .count()
println("CTA cannabis arrests at night $result")
```

Having this many filters doesn't look very efficient. What can we do to optimize this?

- First, we could consider which ones are likely to exclude a lot of elements, and run those filters first. If the first steps get rid of *most* records, the rest of the steps have to inspect a lot fewer of them. We might also want to pull expensive filters (for example, our `String` search operations) to later down the line, and let the quicker filters run first (notice that we've already done this!).
- Using a single `filter` with all the conditions joined together by `&&` operators would iterate our original `List` just once, and only create a single new `List` that contains the elements that made it through. The original code iterates the current `List` and creates an intermediate `List` in each `filter`.
- If we want to keep the structure of separate filters for each condition, using the `Sequence` API might be a good idea here. All we have to do is add an `asSequence` call at the top of the chain.

Do these actually improve our performance? Here are some *very* unscientific measurements of these approaches, on just one machine:

```
Original code
17.998 ms

Merged filter operations
21.679 ms

Converted to a Sequence
39.575 ms

Filters in the wrong order, String operations first
144.898 ms
```

These results might be surprising, as the proposed improvements probably sounded great in theory. The lesson to learn here: always benchmark code that you want to optimize for performance, with real amounts of data. Don't use measurements such as `System.currentTimeMillis()` either, use real benchmarking tools instead. Here's [an article](https://www.oracle.com/technetwork/articles/java/architect-benchmarking-2266277.html) and [a tutorial](https://www.baeldung.com/java-microbenchmark-harness) that can help you get started with benchmarking on the JVM. If you're running code on Android, take a look [at this documentation](https://developer.android.com/studio/profile/benchmark).

> Note that we didn't inspect or compare the memory usage of each approach, which would probably also show significant differences.

#### What are the most common types of crimes?

We have a property called `type`, which contains values such as `NARCOTICS`, `BATTERY`, or `WEAPONS VIOLATION`. One of the frequently used collection functions in Kotlin is [`groupingBy`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/grouping-by.html), which lets us group our elements by some key. To group our crimes by their type, we can do the following:

```kotlin
val grouping: Grouping<Crime, String> = crimes.groupingBy { it.type }
```

A grouping is very similar to a `Map`, but like a `Sequence`, creating it doesn't trigger any processing yet. We need to call a further terminating method on it. One of these is [`eachCount`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/each-count.html), which is exactly what we need:

```kotlin
val counts: Map<String, Int> = crimes
        .groupingBy { it.type }
        .eachCount()
println(counts)
```

Printing the `Map` we have here will give us an output formatted like this. Readable, but not pretty:

```
{BATTERY=140287, THEFT=168404, CRIMINAL DAMAGE=82038, WEAPONS VIOLATION=9302, ...}
```

To improve this, here are some operations we can perform on the `Map`:

```kotlin
crimes.groupingBy { it.type }
        .eachCount()
        .mapKeys { it.key.lowercase().replaceFirstChar(Char::uppercase) } // 1
        .toList() // 2
        .sortedByDescending { (type, count) -> count } // 3
        .take(3) // 4
        .forEach { (type, count) -> // 5
            println("$type: $count")
        }
```

1. We modify the `Map`'s keys so that only their first letter capitalized. This "map" operation doesn't change the values in the `Map` entries, it just replaces each of their keys.
2. We convert our `Map<String, Int>` to a `List<Pair<String, Int>>`. Each `Pair` in the `List` will correspond to a key-value pair (an entry) from the `Map`.
3. We sort the `List` so that it starts with the types of crimes that have the largest `count` values. We use another form of destructuring here: we are declaring two variables local to the lambda's scope, which will be initialized by destructuring the `Pair<String, Int>` that it receives as a parameter.
4. We take the first 3 entries of the `List`.
5. Again, we use destructuring to create variables from the `Pair<String, Int>` that we receive as the parameter of this lambda.

> A `List` is easier to follow than a `Sequence`, but a `Sequence` would have probably been a good choice here, due to the many steps and large amount of data. Try replacing `toList` with an `asSequence` call!

This will give us the following, nicely formatted output:

```
Theft: 168404
Battery: 140287
Criminal damage: 82038
```

#### What time of the day are these crimes committed?

This, again, will be a job for `groupingBy`. After creating our grouping, we'll use [`toSortedMap`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/to-sorted-map.html) to make sure that our values are ordered by their keys (the hour), and then iterate over them.

```kotlin
crimes.groupingBy { it.date.hour }
        .eachCount()
        .toSortedMap()
        .forEach { (hour, count) ->
            val hourString = String.format("%2dh", hour)
            val percentage = (count.toDouble() / crimes.size * 100).toInt()
            println("$hourString ${"X".repeat(percentage)}")
        }
```

Inside the `forEach` call, we format the hour value, and calculate what percentage of crimes each hour contained. To visualize this primitively, we draw a barchart of sorts from `X` characters, using the [`repeat`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/repeat.html) extension:

```
 0h XXXX
 1h XX
 2h XX
 3h XX
 4h X
 5h X
 6h X
 7h XX
 8h XXX
 9h XXXX
 ...
```

## Summary

The Kotlin Standard Library contains hundreds of useful functions that make everyday tasks quicker and easier. Whether it's providing clear requirements, manipulating strings, or accessing files, the Standard Library's got you covered.

> It's worth browsing through the implementations of these functions, as they demonstrate excellent use of Kotlin's language features, as well as great API design.

Combining these quick-to-use extensions, Kotlin can be put to work as a scripting language of sorts - whether or not it's being used with its scripting environment.

## Sources

- [Effective Java - Joshua Bloch](https://www.amazon.co.uk/Effective-Java-Joshua-Bloch-ebook/dp/B078H61SCH/)
  - *The* book for writing better Java (and OO) code.
- [Effective Kotlin - Marcin Moskala](https://leanpub.com/effectivekotlin)
  - A collection of Kotlin best practices.
- Official documentation:
  - [The `kotlin.text` package](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.text/index.html)
  - [The `kotlin.io` package](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/index.html)

# Chapter 8: Operators, Conventions, and Delegates

Like many other modern languages, Kotlin supports operator overloading. However, *unlike* some other languages, it doesn't let you use arbitrary symbols as operators. Instead, it confines you to a predefined set of operators that you may define for each type.

Building on its operator semantics, the language also has a set of conventions that let you implement your own classes in ways that make them as convenient to use as first-party constructs, such as the `List` or `Array` types.

## Operators

### Simple operators

We'll need a type that we study operators on. Our example will mimic some of the behaviour of a built-in type: an `Int`. We'll do this in a very simple way, by wrapping an actual `Int` value with our own class.

For a start, we'll define a constructor that stores this value, and two utility methods, which let us access the stored value as an `Int` and as a `String`:

```kotlin
class MyInt(private val value: Int) {
    fun toInt(): Int = value
    override fun toString() = value.toString()
}
```

What can we do if we want to add two `MyInt` instances together? We can define a method for it. This method will create a new `MyInt` instance, containing the result.

```kotlin
class MyInt(private val value: Int) {
    // ...
    fun add(other: MyInt): MyInt {
        return MyInt(this.value + other.value)
    }
}
```

We can then create instances of `MyInt`, add them up, and print this result (which invokes `toString`, giving us the value as a `String`):

```kotlin
val a = MyInt(4)
val b = MyInt(8)
println(a.add(b)) // 12
```

This, of course, works as expected. But what we really want to do is use the operators that built-in types are using with our very own types:

```kotlin
println(a + b)
```

The key to this in Kotlin is the `operator` keyword. This lets you define every operator present in the language (`+`, `-`, `%`, and so on) for your own types. You can not create operators with arbitrary symbols, you can only work with the predefined set.

To define these operators, you need a function that's marked with the `operator` keyword, and it needs to have a specific name that corresponds to an operator. You can find the mapping between the operator symbols and their function names [in the official documentation](https://kotlinlang.org/docs/operator-overloading.html).

The mapping between the method names and the syntax of each operator has semantic importance. You should only use operators for cases where calling the functions with their regular syntax (i.e. by name) would be appropriate as well. For example, don't define a `plus` method that doesn't add things together. After all, these are just functions, and they can still be invoked with the regular function call syntax at any time.

> This is also an item in the Effective Kotlin book: *Item 12: Operator meaning should be consistent with its function name*.

For our purposes of a `+` operator, we'll need to define the `plus` function, marked as an `operator`:

```kotlin
operator fun plus(other: MyInt): MyInt {
    return MyInt(this.value + other.value)
}
```

The `plus` method has to be either a member or an extension on a type, and it has to take a single parameter. These are fixed requirements, since it's a binary operator.

There are no specific requirements for the types used in the method signature though. While this function takes another `MyInt` instance as its parameter, and returns `MyInt`, most Kotlin operators let you vary these types arbitrarily. You could define another `plus` method that takes a `String` as a parameter and returns a `Double`, or a `Cow`, or even `Unit` if you wanted to.

This was a binary operator, but the language also has unary operators, which are applied to just a single value. For example, the unary minus operator, which negates a number (or gives you its *additive inverse*, if you're feeling fancy).

As already mentioned, operators don't have to be defined as members, they can also be extensions on a type (as long as they don't need to access private members):

```kotlin
operator fun MyInt.unaryMinus(): MyInt {
    return MyInt(-this.toInt())
}
```

This operator can then be used for your custom type just like it's used on the built-in types, by prefixing them with it:

```kotlin
val x = MyInt(4)
println(-x) // -4
```

As operators can be defined as extensions, the Kotlin Standard Library ships operators for many built-in types, without modifying them. Some examples of these are the [`java.math.BigDecimal`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/java.math.-big-decimal/) and [`java.math.BigInteger`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/java.math.-big-integer/) extensions, as well as the [`plus`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/plus.html) and [`minus`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/minus.html) operators that are defined for many, many collection types.

These let you transform code like this...

```kotlin
fun solve(
    a: BigDecimal, b: BigDecimal, c: BigDecimal
): Pair<BigDecimal, BigDecimal> {
    val sqrtD = b.multiply(b).subtract(BigDecimal(4).multiply(a).multiply(c)).sqrt(MathContext.UNLIMITED)
    val x1 = b.negate().add(sqrtD).divide(BigDecimal(2).multiply(a))
    val x2 = b.negate().subtract(sqrtD).divide(BigDecimal(2).multiply(a))
    return Pair(x1, x2)
}
```

... into code like this:

```kotlin
fun solve(
        a: BigDecimal, b: BigDecimal, c: BigDecimal
): Pair<BigDecimal, BigDecimal> {
    val sqrtD = sqrt(b * b - 4.toBigDecimal() * a * c)
    val x1 = (-b + sqrtD) / 2.toBigDecimal() * a
    val x2 = (-b - sqrtD) / 2.toBigDecimal() * a
    return Pair(x1, x2)
}
```

The `Int.bd` extension property we've seen in chapter 4 would make this code even cleaner.

> For the record, this is **not** a proper implementation of a quadratic equation solver. Write a better one as practice!

### Getting and setting

You might have noticed that the "indexing" syntax that we use when accessing elements in an array also works for other collections in Kotlin, for example, for the `List` types:

```kotlin
val numbers = mutableListOf(3, 5, 1, 6, 7, 2)
println(numbers[3])
numbers[4] = 8
```

These, again, are a pair of operators: the [`get`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/get.html) and [`set`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/set.html) operators.

You can define these for your own types as well, and as they're just functions, you can place any code inside them. For example, you can have a `Vector3` class, which stores its data as `x`, `y`, and `z` properties internally, but exposes these components through `Int` indices through operators.

```kotlin
data class Vector3(var x: Int, var y: Int, var z: Int) {
    operator fun get(index: Int): Int {
        return when (index) {
            0 -> x
            1 -> y
            2 -> z
            else -> throw IllegalArgumentException("Invalid index")
        }
    }

    operator fun set(index: Int, value: Int) {
        when (index) {
            0 -> x = value
            1 -> y = value
            2 -> z = value
            else -> throw IllegalArgumentException("Invalid index")
        }
    }
}
```

You could then use a `Vector3` instance like this:

```kotlin
val v = Vector3(0, 0, 0)
v[2] = 42
v[0] = 169
println(v[2]) // 42
println(v) // Vector3(x=169, y=0, z=42)
```

> You can define an arbitrary number of parameters for these operators. For example, for a `Matrix` type, you could achieve syntax like `mx[4, 1] = 20`, with a 3-parameter `set` method. All but the last parameter of the `set` operator have to be provided between the brackets at the call site.

### Invoke

A special case of operators is the `invoke` operator, which lets you use the function call syntax on the type that it's defined for. We've already encountered this operator for the `Function` types in the Kotlin runtime, [back in chapter 4](./4.md#functionx-types):

```kotlin
interface Function0<R> {
    operator fun invoke(): R
}
```

This is why a `Function0` instance - which is anything with a function type that takes no parameters, such as `() -> Unit` - can be called as a function.

We can also use `invoke` in our own types if it makes sense. For example, if you're using the [command pattern](https://en.wikipedia.org/wiki/Command_pattern), you might define an interface like this:

```kotlin
interface Command {
    operator fun invoke()
}
```

As an example, you could write a command that can copy a file, implemented as simply as using [`copyTo`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.io/java.io.-file/copy-to.html):

```kotlin
class CopyCommand(
        private val source: File,
        private val target: File
) : Command {
    override fun invoke() {
        source.copyTo(target)
    }
}
```

You can invoke a command like this by calling its `invoke` method as a function, or using its operator form:

```kotlin
val command: Command = CopyCommand(File("current.txt"), File("archived.txt"))
command.invoke()
command()
```

### Equality and comparisons

Let's talk about equality. The `MyInt` class we've defined currently fails basic equality checks that two regular `Int` instances would pass successfully:

```kotlin
val x = MyInt(10)
val y = MyInt(10)
println(x == y) // false
```

Although Java uses `==` to compare *references*, that's not what happens in Kotlin with this operator. Instead, it translates to a call of the `equals` method, [defined in `Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/equals.html). This is done because this is the comparison we want to perform in our applications a vast majority of the time.

> How do you perform a comparison of references, if `==` is just an `equals` call? With the `===` and `!==` operators.

Since we don't have an `equals` method defined for `MyInt`, we fall back to its default implementation in `Any`, which is mapped to `java.lang.Object`. [The documentation](https://docs.oracle.com/javase/8/docs/api/java/lang/Object.html#equals-java.lang.Object-) in that class states the following: *"for any non-null reference values x and y, this method returns true if and only if x and y refer to the same object (x == y has the value true)"*. Due to the lack of an `equals` implementation, we've fallen back to comparing references, which fails.

One approach to get an `equals` implementation quickly would be to make our `MyInt` class a data class, which wouldn't be unreasonable, however, we'll write an `equals` method manually instead:

```kotlin
override fun equals(other: Any?): Boolean {
    if (other !is MyInt)
        return false
    return value == other.value
}

override fun hashCode(): Int {
    return value
}
```

> We are following age-old advice from Effective Java here: *Item 11: Always override `hashCode` when you override `equals`.*

Our `equals` implementation isn't quite perfect (compare it with what IntelliJ generates, if you want to see some potential improvements), but it's good enough for most practical purposes. Note how we're taking advantage of smart casts in it, to access `other.value`.

Implementing `equals` gives us working `==` and `!=` operators for our `MyInt` class:

```kotlin
println(MyInt(10) == MyInt(10)) // true
println(MyInt(10) == MyInt(0)) // false
println(MyInt(10) != MyInt(0)) // true
```

How about other comparisons? These are provided through yet another operator, `compareTo`. This operator has to take a single parameter, and must return an `Int`, the value of which follows the rules set by the [`java.lang.Comparable`](https://docs.oracle.com/javase/8/docs/api/java/lang/Comparable.html) interface. Simplified, this return value should be:

- zero, if the two values are equal,
- a negative number, if the first value is smaller,
- a positive number, if the first value is larger.

Implementing this for `MyInt` is easy, as we can just subtract the two values from each other:

```kotlin
operator fun compareTo(other: MyInt): Int {
    return this.value - other.value
}
```

Or if we get a bit cheeky, we can delegate this to the [`Int#compareTo`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-int/compare-to.html) function:

```kotlin
operator fun compareTo(other: MyInt): Int {
    return this.value.compareTo(other.value)
}
```

Either way, we now get to use `>`, `<`, `<=` and `>=` on `MyInt`:

```kotlin
println(MyInt(5) < MyInt(10)) // true
println(MyInt(5) > MyInt(10)) // false
```

Optionally, you can also implement the [`Comparable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-comparable/index.html) interface, which comes in handy in certain cases, for example, if you want to [sort](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/sorted.html) a collection of such items. The `compareTo` method declared in the interface matches our existing operator already, so if you want to make `MyInt` a `Comparable`, all you need to add is the `override` keyword:

```kotlin
class MyInt(private val value: Int) : Comparable<MyInt> {
    // ...
    override operator fun compareTo(other: MyInt): Int {
        return this.value - other.value
    }
}
```

#### Assignments are not expressions

We've just looked at what `==` and `===` do, so this is a good place to take a closer look at the regular old `=` operator. In Java, assignments are *expressions* (something with a return type, which yields a return value when evaluated), and they return the newly assigned value. This is why you can write code like this:

```java
BufferedReader reader = ...;
String line = null;
while ((line = reader.readLine()) != null) { // assignment used as an expression
    System.out.println(line);
}
```

You might have noticed that we didn't do this in [chapter 7](./7.md) when we were reading lines from a file. In Kotlin, assignments are only *statements* (a valid line of code that can be executed), but not *expressions*. This language design decision follows the frequent advice of not using the return value of an assignment as an expression even if a language allows it, as this can be hard to read, and it's a potential source of bugs.

For example, this code in C is just a single character away from checking whether `x` is `0` and running a branch accordingly. Instead, it always sets `x` to `0` and then runs the `else` branch, as the value of the `x = 0` expression is automatically coerced into `false`:

```c
if (x = 0) {
    // Run if X was zero...
} else {
    // Run if X is non-zero...
}
```

## Conventions

We've seen how basic operators work, let's move on to some more advanced ones, which we'll discuss under the theme of *conventions*. These conventions will define further, special operators, which will let you empower your own types, and make them play just as smoothly with built-in language features as first-party types do.

Our example for this section will be a `Time` class, which represents a time of day as hours and minutes, but stores just a single value internally:

```kotlin
class Time(hours: Int, minutes: Int)  {
    private val totalMinutes = hours * 60 + minutes

    val hours: Int
        get() = totalMinutes / 60
    val minutes: Int
        get() = totalMinutes % 60
}
```

Whenever `hours` or `minutes` are accessed, those values will be computed from `totalMinutes`.

### Custom ranges

The first convention we want to use is the *range* convention, to define a given interval of time. We already know that the `..` syntax can create a range from two `Int` values. This range can be iterated over, and we can also check if an `Int` is within the range:

```kotlin
val range = 0..10
for (i in range) { ... }
if (5 in range) { ... }
```

Let's do something similar for our `Time` class, step by step. If we look at the type of `range`, we'll see that it's an instance of an [`IntRange`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.ranges/-int-range/). Similarly, we'll create a `TimeRange` class that will represent our interval, between two points in time:

```kotlin
class TimeRange(private val start: Time, private val end: Time)
```

The `..` operator used to create a range maps to the `rangeTo` operator function, which we can define either as a member or an extension. We can go with an extension for this one - this way, the `Time` class can stay simpler, and we can add the range functionality to it without modifying it:

```kotlin
operator fun Time.rangeTo(other: Time): TimeRange {
    return TimeRange(this, other)
}
```

With this defined, we can already create a `TimeRange`:

```kotlin
val morning = Time(8, 0)
val evening = Time(17, 0)

val range: TimeRange = morning..evening
```

### Containment

Let's see how we can check if the range contains a given value. Whenever the `in` keyword is used, it will actually map to a call of an operator called `contains`, by convention. This method has to exist on whatever is on the right-hand side of `in`, and it will receive the value on its left as its parameter. So `x in y` is equivalent to a `y.contains(x)` call.

We can implement this operator in our `TimeRange` with a small bit of arithmetic:

```kotlin
class TimeRange(private val start: Time, private val end: Time) {
    operator fun contains(time: Time): Boolean {
        val timeMinutes = time.hours * 60 + time.minutes
        return start.hours * 60 + start.minutes <= timeMinutes &&
                timeMinutes <= end.hours * 60 + end.minutes
    }
}
```

> This would be much, much simpler if we had a `compareTo` implementation for `Time` - write one!

Putting this new method to the test, we can see that we also get `!in` for free:

```kotlin
val lunch = Time(12, 30)
println(lunch in range) // true
println(lunch !in range) // false
```

### Iteration

Let's move on to iteration. When we use the `for (x in y)` syntax, we are again invoking functions under the hood. This syntax is equivalent to the following:

```kotlin
val iterator = y.iterator()
while (iterator.hasNext()) {
    val x = iterator.next()
    // for loop body for `x`
}
```

First, we'll need to create an operator method in `TimeRange` called `iterator`, which - as you might guess - has to return an [`Iterator`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterator/):

```kotlin
class TimeRange(private val start: Time, private val end: Time) {
    // the `contains` implementation...
  
    operator fun iterator(): Iterator<Time> {
        TODO("implement")
    }
}
```

How do we provide an `Iterator`? We can implement the interface ourselves right here in the method, with an object expression. An `Iterator` has to define the two methods that you can see used in the pseudocode snippet above:

- `hasNext()` returns a `Boolean`, and tells us whether there are any elements remaining,
- `next()` fetches the next element from whatever we're iterating.

Our iterator will iterate on time values minute by minute within our range. Here's our implementation:

```kotlin
operator fun iterator(): Iterator<Time> {
    return object : Iterator<Time> {
        // 1
        val startMinutes = start.hours * 60 + start.minutes
        val endMinutes = end.hours * 60 + end.minutes

        // 2
        var currentMinutes = startMinutes

        // 3
        override fun hasNext(): Boolean {
            return currentMinutes <= endMinutes
        }

        // 4
        override fun next(): Time {
            return Time(hours = currentMinutes / 60, minutes = currentMinutes % 60).also {
                currentMinutes++
            }
        }
    }
}
```

Here, we...

1. Calculate the start and end times of our range in total minutes.
2. Keep track of where our iteration is in a mutable property.
3. Say that there are more time instances to iterate through as long as the current value didn't pass the max value.
4. Create a new `Time` instance every time the iterator is asked for the next item.

> We didn't add a check for whether we still have elements remaining in the `next` method. This isn't an issue when our range is used in a loop, but it could cause issues if the iterator is used manually, through function calls. Our Kotlin `Iterator` maps to [`java.util.Iterator`](https://docs.oracle.com/javase/8/docs/api/java/util/Iterator.html#next--), which specifies that `next` should throw a `NoSuchElementException` if there are no more elements to return.

Note that we are at no point storing all the `Time` instances between the min and max values of the range (neither does `IntRange` actually contain all `Int` values between its bounds). We are just lazily creating these intermediate values, as the `for` loop is progressing on our range.

> Again, this code could be simpler if we had a `compareTo` and an `increment` operator in our `Time` class. Write those operators, and then refactor this code!

Let's put our iteration code to work:

```kotlin
for (time in morning..lunch) {
    println(String.format("%02d:%02d", time.hours, time.minutes))
}
```

> Kotlin doesn't offer its own string formatting syntax at this time. However, as long as we're on the JVM, we can make use of the same format strings that Java offers.

Very similarly to `compareTo` and `Comparable`, you can optionally implement an interface called [`Iterable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-iterable/), which declares the `iterator` method with a matching signature to the operator. Implementing this interface is *very* powerful. It will grant you access to many of the extensions of the Kotlin Standard Library's collection API, as most of these are defined on `Iterable`.

For example, you could take a `TimeRange`, and quickly get a `List<Time>` that only contains the instances of `Time` from it that are at a round 15 minutes:

```kotlin
(morning..lunch).filter { it.minutes % 15 == 0 }
```

So the general takeaway from these optional interfaces:

- If you define the right operators, then by convention, you get to use your own types with certain language features.
- If you implement these interfaces, you'll also get access to a vast number of extensions that are defined on those interfaces.

> The operators that enable conventions can be added as extensions, so you can make existing types that you don't own comparable with `>` or iterable with `in`. However, you can't make types implement interfaces after-the-fact.

### Range utilities

The built-in range types are also `Iterable`. This means that you can, for example, use `forEach` on them to run some code for a certain range of indices:

```kotlin
(10..20).forEach {
    println(it)
}
```

A method reference could clean this up even further:

```kotlin
(10..20).forEach(::println)
```

Similarly, the `map` extension can also come in handy, to create a number of instances of some type, based on the indices:

```kotlin
val times = (5..15).map { min -> Time(8, min) }
```

### Destructuring

One last convention we can apply here is *destructuring*. We've already seen that data classes and lists can be destructured. But this feature, again, seems like something deeply baked into the language, with strong integration in basic types. Thankfully, destructuring also works through operator conventions!

For each index that you want to be able to destructure, you have to define a method with a corresponding name: `component1`, `component2`, and so on. For our `Time` class, we can define these methods even as extensions, to be able to destructure it into an hour and a minute value:

```kotlin
operator fun Time.component1(): Int = hours
operator fun Time.component2(): Int = minutes
```

> Note that these component functions are *not* 0-indexed... For some reason.

This lets us destructure a `Time` instance like this:

```kotlin
val (hours, minutes) = Time(13, 42)
```

> Remember that destructuring is positional, and not based on the names of the variables you're declaring.

Destructuring can also be used in lambda parameters and in `for` loops, so we can now update our previous loop like this:

```kotlin
for ((hours, minutes) in morning..lunch) {
    println(String.format("%02d:%02d", hours, minutes))
}
```

Note the power that lies in component accessors being methods. They aren't restricted to returning values stored in the class, as-is. They can compute values on-the-fly, return values with different types, and so on. Anything that a function can do can be done when a component is being accessed during destructuring.

> Destructuring support for collection types is also added as [extensions](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/component1.html).

### Performance of built-in ranges

Based on what we've just seen, we know that code like this:

```kotlin
for (i in 0..10) {
    println(i)
}
```

... will create an `IntRange` instance, and then get an `Iterator` on it, which it uses to run the `for` loop. This is multiple allocations and several method calls, while the Java equivalent of this loop has none:

```java
for (int i = 0; i <= 10; i++) {
    System.out.println(i);
}
```

If we decompile the bytecode generated from the Kotlin loop above, we can be relieved:

```java
int i = 0;
for(byte var11 = 10; i <= var11; ++i) {
   System.out.println(i);
}
```

Simple usages of the built-in ranges are recognized and optimized by the compiler, so that no unnecessary allocations occur. If you assign an `IntRange` to a variable, and pass it around as a parameter, that *will* result in an actual object allocation, as something has to be passed around.

## Delegates

We've just uncovered the inner workings of operators and ranges, and seen that we can do everything the built-in types could do for our own types as well. It's time to do the same thing for property delegates. We've looked at the built-in ones provided by the Standard Library earlier, and we'll now see that there's actually nothing special about them: it's conventions all the way down.

### Implementing `lazy`

Let's start by reimplementing one of them, the [lazy](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/lazy.html) delegate. Recall the example we used earlier, of computing the value of `pi` lazily? The `lazy` delegate let us only perform the computation when we first access the value of `pi`, and then it stored its value for us, so that any subsequent calls to the property were quick.

```kotlin
val pi by lazy {
    print("Computing... ")
    sqrt(6 * (1..1_000_000_000).sumOf {
        1.toDouble() / it / it
    })
}

println(pi) // Computing... 3.14159264498239
println(pi) // 3.14159264498239
println(pi) // 3.14159264498239
```

So how do delegates work? They extract the logic of a property's getter (and setter, if the property isn't a read-only `val`) into a class. For a class to be eligible for use as a delegate that backs a property, it needs to define a specific operator function, which will be called whenever the value of the property it backs is being read. This, again defined by convention, is the following `getValue` function:

```kotlin
class Lazy<T> {
    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        TODO("implement getter")
    }
}
```

We've created a class called `Lazy` with a generic parameter (`T`), which will be the type of the value that it computes lazily. The `getValue` function has to have two very specific parameters, we'll explore these later. What we need to care about for now is its return type, which is up to us do define - we'll choose the `T` type here, so that this class can back a property of that type.

We've worked with the backing field using the `field` identifier in custom getters and setters already, but we don't get this kind of a field when using delegates, as how we implement the getter and setter is completely up to us.

> We might never store a value in a delegate - just like in a custom getter or setter.
 
If we do want to store a value, we'll simply declare a property in our delegate class. We'll also add a constructor parameter to our lazy delegate: the function that can compute the value of the property when needed.

```kotlin
class Lazy<T>(private val initializer: () -> T) {
    private var value: T? = null

    operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        if (value == null) {
            value = initializer()
        }
        return value!!
    }
}
```

Inside the `getValue` function, we check if our `value` property is already storing a value, and if it isn't, we initialize it using the `initializer` function provided. Then, we return the stored value.

Here's what the usage of this delegate would look like:

```kotlin
val pi by Lazy({
    println("Computing")
    sqrt(6 * (1..1_000_000_000).sumOf {
        1.toDouble() / it / it
    })
})
```

Of course, we can drop the parentheses around the lambda that we're passing in to the constructor, to get closer to the original syntax. We also want to have a lowercase `lazy` there, which we *could* achieve by renaming the class... Or we can do what the Standard Library does, and introduce a factory function for our delegate instead:

```kotlin
fun <T> lazy(initializer: () -> T) = Lazy(initializer)
```

This gets us back to the original syntax at the use site:

```kotlin
val pi by lazy {
    println("Computing")
    sqrt(6 * (1..1_000_000_000).sumOf {
        1.toDouble() / it / it
    })
}
```

### Standard Library delegate interfaces

Implementing `lazy` was a bit difficult, as we had to get the signature of `getValue` just right, off the top of our head (or at least by going to the documentation, and copying it from there). Thankfully, there's a better way: the Standard Library provides a pair of interfaces for delegates, the first one being [`ReadOnlyProperty`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-only-property/), which you can use when implementing delegates that will only ever be used as a `val`.

```kotlin
public interface ReadOnlyProperty<in T, out V> {
    public operator fun getValue(thisRef: T, property: KProperty<*>): V
}
```

The second generic parameter, `V` corresponds to the type of the property that's being delegated, and therefore, the return type of the `getValue` is defined as `V`.

`T` is a more interesting type parameter in the delegate interfaces, which is being used as the type of the `thisRef` parameter. The name `thisRef` is quite descriptive. Whenever `getValue` is called, this first parameter will be a `this`-reference, i.e. the reference of the instance that contains this property (or `null`, if the property doesn't belong to a class instance, which can happen if it's top-level or local). If you use a parameter that's more concrete than `Any`, *you can restrict the types of classes that the delegate can be used in*.

> Note that if you don't make this parameter nullable, your delegate will not be available for use in top-level or local declarations.

Receiving this containing instance as a parameter means that you can access its state or methods while you're performing your getter's tasks, which can be a powerful tool to have. For example, on Android, restricting this `T` parameter to [`Context`](https://developer.android.com/reference/android/content/Context), the class which allows access to system resources, is a popular design choice.

We can update our `Lazy` delegate to use this interface:

```kotlin
class Lazy<T>(private val initializer: () -> T) : ReadOnlyProperty<Any?, T> {
    private var value: T? = null

    override operator fun getValue(thisRef: Any?, property: KProperty<*>): T {
        if (value == null) {
            value = initializer()
        }
        return value!!
    }
}
```

Thanks to this interface, we can also hide this concrete class from clients, by using the interface as the return type of the `lazy` factory function:

```kotlin
fun <T> lazy(initializer: () -> T): ReadOnlyProperty<Any?, T> = Lazy(initializer)
```

> With the implementation of `lazy` as a starting point, try reimplementing [`Delegates.observable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/observable.html) and [`Delegates.vetoable`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-delegates/vetoable.html) as practice!

> The Standard Library `lazy` implementation is more sophisticated than our custom one. For example, it lets you store nullable values lazily (which ours would fail at, always recomputing the value), and it's also thread safe by default. Its implementation is worth taking a look at.

### Read-write delegates and providing delegates [Extra content]

We've covered read-only delegates above. Delegates can also be used as read-write properties, and there's a corresponding [`ReadWriteProperty`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.properties/-read-write-property/) interface for this use case. 

This interface extends `ReadOnlyProperty`, and adds a `setValue` method:

```kotlin
public interface ReadWriteProperty<in T, V> : ReadOnlyProperty<T, V> {
    public override operator fun getValue(thisRef: T, property: KProperty<*>): V
    public operator fun setValue(thisRef: T, property: KProperty<*>, value: V)
}
```

Learn more about read-write delegates and an advanced way of creating delegate instances in [the extras of this chapter](./8-extras.md).

### Map delegates in the Standard Library

Finally, to wrap up the topic of delegates, let's talk about a feature of the Standard Library: delegation to `Map` instances. The `Map` type knows nothing about delegates (nor should it!), but there are [`setValue`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/set-value.html) and [`getValue`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/get-value.html) operators defined for it as extensions.

> At this point, the interfaces being optional in order for the delegation conventions to work comes in really handy. You wouldn't be able to make `Map` implement an interface, but you can add operators to it as extension functions.

How does delegation to a `Map` work? For example, we can set up a class that holds all of its data in a `Map` that it receives as a parameter:

```kotlin
class Address(map: MutableMap<String, String>) {
    var country: String by map
    var zip: String by map
    var city: String by map
    var street: String by map
}
```

Each of these properties will be stored in the map, with the name of the property being used as the key (using the `property` parameter of the accessors that we've seen above).

```kotlin
val map = mutableMapOf<String, String>()
val address = Address(map)
address.country = "Hungary"
address.city = "Budapest"
address.zip = "1117"

println(address.city) // Budapest
```

Storing values works as expected. And if you were to print the entire contents of the `map` instance, you'd see this:

```
{country=Hungary, city=Budapest, zip=1117}
```

## Summary

Kotlin offers many convenient features for its first-party types: various kinds of operators, integration with language features such as iteration with the `for` loop or use in destructuring, and more. The delegates of the Standard Library are also similarly tightly integrated, seemingly magical parts of the language.

All of these things, however, are available for anyone to use, by implementing the right operators and aligning with certain conventions. This enables your own types to be just as idiomatic and convenient to use as any built-in type. You can also improve the API of existing types, by adding these conventions to them as extensions.

## Sources

- [Delightful Delegate Design](https://blog.autsoft.hu/delightful-delegate-design/)
- Official documentation
    - [Operator overloading](https://kotlinlang.org/docs/reference/operator-overloading.html)
    - [Ranges and Progressions](https://kotlinlang.org/docs/reference/ranges.html)
    - [Delegated Properties](https://kotlinlang.org/docs/reference/delegated-properties.html) 

# Chapter 9: The Type System

Thanks to Kotlin's strong typing, we rely on its type system to write safe code every time we're using the language - probably more than you realize. Now it's time to examine this type system, get familiar with its special types, and learn about its mechanisms in detail.

## A closer look at the type system

> This discussion of the type system is based in part on [this original article](https://zsmb.co/posts/typical-kotlin/).

First things first, what exactly is a *type*? Types are what let us - and the compiler - define expectations for any given object. What properties and methods can be called on it, where it can be passed as a parameter, where it can be assigned.

Every variable, property, parameter, and expression has a type in Kotlin which is known at compile time. This static typing is what guarantees that, for example, no calls are made to non-existent functions. This eliminates a whole class of possible runtime errors that might occur in dynamically typed languages.

It's important to note that types are **not** equivalent to classes. We are creating new types every time we declare a class, interface, object, or typealias (going forward, we'll stick mostly to just classes for simplicity). In fact, in all of these cases, we're creating multiple new types with these declarations. Let's take just the case of a boring, empty class:

```kotlin
class Hello
```

By defining this class, we've already created the `Hello` and `Hello?` types. These are separate and very different types, as the compiler forces us to explicitly handle the possible nullability of a `Hello?`, while letting us use a `Hello` relatively freely in comparison, since it knows it's always safe to do so.

Creating a class with a type parameter introduces yet more types:

```kotlin
class List<T>
```

In fact, this unbounded `T` type parameter introduces infinitely many types. Some of these would be `List<String>`, `List<String>?`, `List<String?>`, `List<String?>?`, `List<List<Int>>`, `List<in String>`, `List<*>`... Just to mention a few. (Don't worry, we'll take a look at what all of these are later in this chapter!)

### The `Any` type

Like classes, types exist in a hierarchy. We'll put aside nullable types for a moment, and look at just the hierarchy of non-nullable types. This looks essentially the same as the hierarchy formed by the respective classes that create these types.

![The Kotlin type hierarchy](./images/9_typical_simplest.png)

The root of Kotlin's type hierarchy is the `Any` type (just like the [`Any`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-any/) class is the root of its class hierarchy). This type defines basic functions such as `equals`, `hashCode`, and `toString`, which are available on all object instances in Kotlin, as they all have `Any` as their supertype.

Classes with no explicit superclass inherit directly from the `Any` class, and therefore the (non-nullable) types produced by these classes are direct subtypes of the `Any` type. An example of this is the `Hello` class we've defined earlier. As Kotlin doesn't distinguish between primitives and wrappers, the basic types (`Int`, `Double`, `Boolean`, etc.) are also subtypes of `Any`.

> The number types aren't *direct* subtypes of `Any`, but instead they are subtypes of [`Number`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-number/), which defines common functionality for numerical types.

### Subtyping

We've used the words *subtype* and *supertype* in this previous section, so it's time that we clarify what these words mean.

*Y is a subtype of X if an object of type Y can be used in any place where an X is expected.*

This requirement is twofold. On one hand, it's a technical requirement, which the type system can verify for us. For a concrete example, we know that if we create a `Car` superclass and then inherit from it with a `Tesla` class, then the compiler lets us pass a `Tesla` to a function that expects to operate on a `Car`:

```kotlin
open class Car
class Tesla : Car()

fun drive(car: Car) {
    println("Driving the $car, vroom vroom")
}

drive(Tesla())
```

We tend to summarize why this works in a very simplistic phrase: a `Tesla` *is a* `Car`. However, inheriting from the base class with the syntax `: Car()` isn't really what makes a `Tesla` a `Car`.

The other requirement for this subtyping to be correct is for the `Tesla` class to *fulfill the contract of a `Car`*. If we have a reference of type `Car` which points to a `Tesla` instance, we should be able to call methods on this object and get behaviour consistent with what we expect from the base `Car` type. This is one of the SOLID principles, namely, the [Liskov substitution principle](https://en.wikipedia.org/wiki/Liskov_substitution_principle).

> This second requirement can technically be broken, and it's rather easy to break it. Doing so is a code smell called *refused bequest* - a class inheriting from another class, without upholding its contract. This is usually a misguided effort to reuse code from the superclass. You'll find this discussed in Effective Java in detail, in *Item 18: Favor composition over inheritance*.

Let's have `Car` contain a method that lets us drive it for a given number of miles, and returns the gallons of fuel consumed as a result. For any method, its *contract* consists of the set of input values it can accept, plus the promises it makes about its return values. For this one, we could say that its parameter `miles` always has to be non-negative `Int`, and what it promises for its return value is that it'll be some kind of `Number`.

We can put these requirements into code like this:

```kotlin
open class Car {
    open fun drive(miles: Int): Number {
        require(miles >= 0)
        // Compute & return some default consumption value...
    }
}
```

Note how both of these are restrictions on sets of values. The input is first restricted to values of a single type, `Int`, and then even further restricted by specifying what values within that type may be used. The first of these is enforced by the compiler, and since the type system can't enforce the latter, the best we can do is perform a runtime check for it ourselves.

> We're sticking with an `Int` here for the sake of the example. We could of course use a [`UInt`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-u-int/) to exclude negative values.

Similarly, the output has the restriction that out of all possible types of objects, it has to be a `Number`. This is only a type restriction, so it can be enforced entirely by the compiler.

What happens when we override a method like this in a subtype? We are required to hold up the contract it originally had, as someone might use our `Tesla` as a `Car` at some point (and not just a Netflix player).

The easy way to remember the Liskov principle is with this short phrase: **expect no more, provide no less**.

**Expect no more.** We can't define stricter expectations for inputs than our superclass did, as we have to be able to process everything that the superclass is able to process. We can usually make our input requirements looser, if we want: for our concrete example, we might choose to allow negative values in the subclass. (Assuming that we don't consider an exception being thrown for negative values part of the contract of `Car`!)

**Provide no less.** For our output, we have to provide at least as much as the superclass, which means that we have to provide a `Number`. We may also provide a more concrete type, for example, always an `Int`. This will always fulfill the needs of clients who expect to receive a `Number` from this method.

```kotlin
class Tesla : Car() {
    override fun drive(miles: Int): Int {
        return 0 // No gallons consumed, duh!
    }
}
```

We can even change the method signature in this subclass to the more concrete return type, as you can see in this previous code snippet.

> Interestingly, we can't make our input parameters have less concrete types in the override - this is explained neatly [here](https://typealias.com/concepts/contravariance/#functions).

![The sets of values being discussed](./images/9_subtyping.png)

One last time, for proper subtyping, during inheritance:

- The set of accepted values may only broaden - preconditions can only be equal or weaker. **Expect no more.**
- The set of returned values may only shrink - postconditions can only be equal or stricter. **Provide no less.**

### The parallel nullable and non-nullable type hierarchies

Now, let's see how nullable types fit into the picture of our type system. The relation of a given type and its counterpart is fairly simple to determine. The non-nullable type is a more concrete type, as it can only accept a subset of the values that the nullable type can (all of them except for `null`).

![The relation between the Hello and Hello? types](./images/9_typical_hello_nulls.png)

Applying this to every type in our type hierarchy, we get two tightly connected parallel hierarchies, which we can visualize like so:

![The parallel non-null and nullable hierarchies](./images/9_typical_nulls.png)

Looking at this, we can see that the *real* root of the entire type hierarchy is the `Any?` type. A variable of type `Any?` is able to store an object of any type - pun intended.

We can take a moment to check if all the indirect relations between types also make sense. As an example, we see that `Double` is a subtype of `Number?`, according to the diagram. This makes sense, since a `Double` really does produce all the behaviour that is expected from a `Number?`. We might also have the intuition that an object of type `Double` can be safely stored in a variable of type `Number?`.

### Elvis revisited

With our newly developed knowledge of the type hierarchy of Kotlin, we can get more familiar with a feature that we've already been using for a while - the Elvis operator.

This operator is most often used to handle cases where a value is `null` and we have to use a substitute value in its place. If its left-hand side is `null`, it will simply return the right-hand side. What about the return type of the entire *Elvis expression* though?

Most often, we use the Elvis operator to provide a non-nullable value that has the "same type" as the left-hand side:

```kotlin
val maybeString: String? = null
val definitelyString = maybeString ?: "replacement"
```

This is the straightforward case, and `definitelyString` will simply have the type `String` inferred here, as we're expecting it.

But how does the compiler choose the correct type for an Elvis expression? What if we use different types on the two sides of the operator, and not just the nullable and non-nullable variant of the same type?

Let's answer these questions by looking at some examples. Here's a small, simple type hierarchy we'll be using for these:

![A hierarchy of animals and plants](./images/9_animals_0.png)

##### Both nullable 

Let's evaluate an Elvis expression between a `Dog?` and a `Horse?` type first. I'll be using this notation to describe this task:

![Dog? ?: Horse?](./images/9_animals_1_0.png)

First, we find these types in the hierarchy:

![Dog? and Horse? highlighted in the hierarchy](./images/9_animals_1_1.png)

Now we have to figure out what type the Elvis expression above will return. As our first guess, let's take *the first common supertype of these two sides* and see if that works.

![Animal? highlighted as the supertype of Dog? and Horse?](./images/9_animals_1_2.png)

We got `Animal?` as our type for the entire expression created by the Elvis operator. This seems fine. We'll either have a `Dog` or a `Horse`, plus they might be `null`, and an `Animal?` can hold all of these possible values - and we can check one by one that no other, more concrete type can do so. If we verify our result - for example, in IntelliJ with type inference - we'll see that we have indeed found the correct return type.

##### Right nullable

Here's our next example to evaluate - we've changed the left-hand side to a non-nullable type.

![Dog ?: Horse?](./images/9_animals_2_0.png)

We can find these types quickly now:

![Dog and Horse? highlighted in the hierarchy](./images/9_animals_2_1.png)

Again, we'll take the first common supertype, as this worked well for us before, and we have no reason to doubt it. We could take multiple routes from `Dog` to `Animal?` here, however, this doesn't affect the end result.

![Animal? highlighted as the supertype of Dog and Horse?](./images/9_animals_2_2.png)

We have a few more jumps now, but the result seems sensible. If we check in IntelliJ, we are again correct as far as the return type of an expression like this goes.

If we take a step back however, we'll also find that the Elvis operator is simply redundant in this case - the left side can never be `null`! Nevertheless, if we were to still write this down and not heed the IDE's warnings to remove the redundant Elvis operator, we'd get `Animal?` as the return type.

##### Left nullable

As a non-nullable type on the left side makes no sense, we'll get to our last combination of nullabilities for the two sides:

![Dog? ?: Horse](./images/9_animals_3_0.png)

We identify the types in the hierarchy:

![Dog? and Horse highlighted in the hierarchy](./images/9_animals_3_1.png)

And we take the first common supertype of these two. Again, we could take multiple routes from `Horse` to `Animal?`, but it *is* the first common supertype.

![Animal? erroneously highlighted as the result of a Dog? and Horse expression](./images/9_animals_3_2.png)

Something has gone wrong here. If we take a moment to think, we'll find the nullable result of `Animal?` to be overly cautious. If the left-hand side of the expression happens to be `null`, we'll be using the right-hand side instead, which will give us a non-nullable `Horse` value. If the left side is not `null`, we get a non-nullable `Dog` as the result.

This means that `Animal` would be a perfectly reasonable result for the expression as well. What went wrong, how did we get a nullable type when none is needed? Our mistake was to treat the left side as nullable, even though an Elvis expression will never return `null` from that side.

To fix this, we'll adjust our "algorithm": we'll take the non-nullable version of the type on the left, and the type on the right as-is, and find the first common supertype of *these* two types.

![Animal correctly highlighted as the result of a Dog? and Horse expression](./images/9_animals_3_3.png)

In our case, this means first taking `Dog?` back to the non-nullable side of the hierarchy to `Dog`, and then finding the first common supertype with `Horse`, which, as expected, will now be the correct `Animal` type.

This is the correct way of determining the return type of an Elvis expression. We'll see why it's useful to be familiar with this later.

### Unit

`Unit` is a special type in Kotlin that we've already encountered in the very first chapter. It's worth taking another look at it though.

The documentation describes it as *the type with only one value*. As far as its code goes, this is achieved simply by declaring `Unit` as a singleton `object`. Here's its entire source:

```kotlin
public object Unit {
    override fun toString() = "kotlin.Unit"
}
```

This of course wouldn't be enough for `Unit` to do all the things it does, there's also quite a bit of special treatment by the compiler involved to achieve its functionality.

The most important of these is that functions that return no meaningful value return `Unit` instead in Kotlin. This is a meaningless return value (as it's an empty object), but this way, all functions work semantically the same way: they all return something. In comparison, Java has to give special treatment to `void` returning functions - for example, we can't assign their return type to a variable.

We'll get back to `Unit` when discussing generics in the [next chapter](./10.md#the-usefulness-of-unit).

### Nothing

#### A value that never exists

[`Nothing`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-nothing.html) may look a lot like `Unit` at first glance. `Nothing` is a class that can never be instantiated. This is backed by its very short source:

```kotlin 
public class Nothing private constructor()
```

This in itself leads to some interesting consequences for using `Nothing`. For example, if a function has `Nothing` as its return type, we know that it can never return, since it has no way of acquiring or creating the instance of `Nothing` it would return. This, again, is different from `Unit`-returning functions - those did return something, that value just wasn't meaningful.

What does a function that never returns look like? It might contain an infinite loop, or it might always throw an exception instead of terminating normally:

```kotlin
fun loopy(): Nothing {
    while (true) {
        println("Loop!")
    }
}

fun exceptional(): Nothing {
    throw IllegalStateException()
}
```

The Kotlin compiler allows both of these functions to compile since it understands control flow and sees that neither will ever reach a `return` statement. Of course, both of these could just return `Unit`, but this way, we can signal to client code that they will never return.

Why would we want to do this? For example, because the IDE can now warn callers about code that's placed after a call to these `Nothing`-returning functions, which will never be executed:

![A warning on unreachable code](./images/9_unreachable.png)

#### `Nothing` as a bottom type

The `Nothing` type gets some additional special treatment from the compiler. Since an instance of it can never exist, it can serve in the type system as a [bottom type](https://en.wikipedia.org/wiki/Bottom_type).

> In subtyping systems, the *bottom type* is the subtype of all types.

This updates our overall hierarchy like so:

![The full type hierarchies, containing Nothing](./images/9_typical_nothing.png)

Why and how can `Nothing` serve this purpose? Think about it for a second - anywhere you need a concrete type, be it an `Int`, a `Dog`, or an [`AbstractSingletonProxyFactoryBean`](https://docs.spring.io/spring-framework/docs/current/javadoc-api/org/springframework/aop/framework/AbstractSingletonProxyFactoryBean.html), it's safe to pass in something that has the type `Nothing`, because you know that this code can never actually be reached. 

For example, the `loopy` function shown above will never return properly, which makes this variable assignment and then the call to this `processData` function completely safe to compile, albeit nonsensical:

```kotlin
fun processData(data: List<String>) {
    // Use data
}

fun main() {
    val data: Nothing = loopy()
    processData(data)
}
```

We see that the specific type of `processData`'s parameter doesn't matter. It could be any arbitrary type, and `Nothing` could still be passed in safely (as it will never actually be passed in!).

Let's move on to a use case where we can make more sensible use of `Nothing` being a bottom type.

#### TODO

The Standard Library's [`TODO()`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-t-o-d-o.html) function is a great example of making use of `Nothing`. It's a never-returning function, because it always throws a `NotImplementedError`. Since the compiler knows that it never returns, it allows you to leave functions half-implemented like this, without making you return a value:

```kotlin
fun getValue(): Int {
    TODO("implement later")
}
```

> In Java, you would have to `return 0;` or `return null;` in these non-implemented functions like these temporarily to make them compile, which you might forget about later on.

Since `Nothing` is a bottom type, you can also return `TODO()` from any function regardless of what the return type is, and you can use it as a placeholder for any function parameter as well:

```kotlin
fun calculate(x: Int): Int = TODO()

calculate(TODO())
```

All these usages of `TODO` will crash before returning, reminding you that this part of the code is not implemented yet.

> IntelliJ IDEA also picks up invocations of this function the same way that it picks up comments containing "TODO", so you can view them on the same panel.

#### Nothing ft. Elvis

We're going to bring two previous topics together now, `Nothing` and the Elvis operator.

Consider what happens when you use an `Elvis` operator with something of type `Nothing` on the right-hand side. If the expression's left side ends up being non-null, that's the result of the expression, and we can continue on with our code. However, if we have to evaluate the "default" right side, execution of whatever function we're in is guaranteed to be halted, as evaluating that side will either never terminate, or will terminate with an exception.

Let's reuse the `Nothing`-returning `exceptional` function defined above for this example:

```kotlin
fun calculate(someParam: Int?) {
    val x = someParam ?: exceptional()
    val y = x * 2
    println(y)
}
```

Notice that we are using `x` as an `Int` on the third line where we're multiplying it. This code compiles and works correctly, despite the parameter having a type of `Int?`. This makes sense intuitively. If we were to run into the right-hand side case of the Elvis expression and call the `exceptional` function, `calculate` would not proceed due to the exception thrown from there, and otherwise we have a non-null `Int` on our hands.

However, let's be precise and take a look at the type hierarchy again, and see what the return type of the Elvis expression should be:

![The resolution of the common supertype of Int and Nothing](./images/9_typical_nothing_elvis.png)

First, we take `Int?` back to the non-nullable hierarchy, and then we find the first common supertype of `Int` and `Nothing`... Which, since `Nothing` is a bottom type, is `Int` itself! Notice that the same would happen for any nullable type on the left of the Elvis operator when there's `Nothing` on its right side: the return type of the expression would just be the non-nullable variant of the type on the left.

This is already a quite nice way to handle `null` cases of certain values by throwing an exception, and have them be available on the next line conveniently as the non-null variant of their original type. 

We don't even need to wrap throwing an exception into a function that returns `Nothing`. Like many other built-in constructs, `throw` is actually an expression in Kotlin, and naturally, its return type is `Nothing`. This lets us do simply this:

```kotlin
fun calculate(someParam: Int?) {
    val x = someParam ?: throw IllegalArgumentException("someParam must not be null")
    val y = x * 2
    println(y)
}
```

There's another very handy little expression that can be used here for a different effect - the `return` expression. This lets us stop execution of this function for an invalid argument silently.

```kotlin
fun calculate(someParam: Int?) {
    val x = someParam ?: return
    val y = x * 2
    println(y)
}
```

Of course, we're creating a new variable here that's essentially the same as our parameter. This is both wasteful and somewhat confusing, especially in a longer function. Here's a neat trick that's common practice in Kotlin:

```kotlin
fun calculate(someParam: Int?) {
    someParam ?: return
    val y = someParam * 2
    println(y)
}
```

Why does this still work? Because the Elvis expression (as every other expression) will be evaluated even when its return value is unused, and if the parameter was `null`, it returns from the function. From the next line, `someParam` will be available as an `Int` due to a smart cast. (This of course can be used the same way with a `throw`.)

#### throw return

An interesting quirk of both `return` and `throw` having a type of `Nothing` is that statements like this are perfectly valid in Kotlin:

```kotlin
fun oddity() {
    throw return return throw return
}
```

Why is this? Well, both `return` and `throw` take an argument that needs to be evaluated before they're executed. `throw` takes a `Throwable`, and `return` takes whatever the return type of the given function is - in this case, it's `Unit`, which is applied implicitly as a special case, but the same line would compile even if the function returned an `Int`, as long as we ended it with something like `return 1`.

So, for the first `throw` to be executed, it needs a `Throwable` as an argument. The `return` expression right after it returns `Nothing`, which of course *is* a `Throwable`. Similarly, whatever the function's return type, writing either `throw` or `return` down after a `return` keyword will pass type checks, because `Nothing` will fit that return type.

Now we know why this compiles, but what happens when we run the code? The first expression needs its argument evaluated, which in turn needs its argument evaluated, and so on. At the end of this chain, only the very last expression will be executed, because whether it's a `throw` or a `return`, it will exit the current function. The operations before it on the line, which were "in the queue" to be executed, will never have a chance to take effect.

Now you know how to return values and throw exceptions *in style*.

#### About `Nothing?`

When introducing `Nothing` as a bottom type, we've updated our type hierarchy with two new types, but all we've discussed so far was the non-nullable `Nothing`. Does the nullable type `Nothing?` make any sense, and is it of any use to us?

![The nullable type hierarchy](./images/9_typical_nothing_null_only.png)

It's a subtype of all nullable types, which would mean that a value of type `Nothing?` could be used anywhere where a nullable value is required. We know exactly one value that fits this description - `null` itself.

We can confirm our suspicion by assigning `null` to a variable, and letting type inference do its job:

```kotlin
val x = null
```

From here, we can check with either reflection or through the IDE's tooling that `x`, in fact, is of the type `Nothing?`.

```kotlin
val x: Nothing? = null
```

You almost never want to declare a variable like this, because you'll never be able to assign anything but `null` to it.

Here's the common example of how you might run into issues with this:

```kotlin
var x = null
x = "this is a string" // e: Type mismatch. Required: Nothing? Found: String
```

Although there's a type that would work perfectly well here for both usages of `x` (the nullable `String?`), letting the compiler infer the type in this scenario leaves us with a scary-at-first error message seen above.

Hopefully going forward this won't scare you, and you'll realize quickly that inference is to blame, and you can fix the issue by explicitly typing `x` as a `String?`:

```kotlin
var x: String? = null
x = "this is a string"
```

## Summary

The Kotlin type system is perhaps the most important part of the language. It's the source of the safety that pervades the language. It provides safe null handing, well-defined subtyping, and powerful support for advanced generics (which we'll take a look at in the next chapter).

## Sources

- [Typical Kotlin](https://zsmb.co/posts/typical-kotlin/)

# Chapter 10: Generics

Generics are a powerful means of code reuse, and are widely utilized in both Java and Kotlin. We've touched on generics before, but haven't discussed their intricacies yet. In this chapter, we'll recap why we need them, and then see how Kotlin's type system makes it safe to work with them.

## The reason for Generics

Imagine for a moment that we don't have a list collection provided to us by the JDK or the Kotlin Standard Library, and have to implement our own. Without generics, we'd have two choices:

- Implement a list type for each type of object that we want to store in lists. For example, a `StringList` class would take a `String` as the parameter of its `add` method, and return a `String` from its `get` method. This is convenient and safe to use, but whenever we want to create a list of a new type, we have to implement a new list class that can store that specific type.

    ```kotlin
    class StringList {
        fun add(string: String) { ... }
        fun get(index: Int): String { ... }
    }
    
    val stringList = StringList()
    stringList.add("testing")
    val test: String = stringList.get(0)
    ```

- Create a single `List` type that stores a `List` of `Any` (or `Object`) instances, which solves the issue of having to create new types all the time. However, we now have to remember that we stored, say, `String` instances in a given list, then remember to only put `String` instances in it, and finally cast them back to `String` when we read them from the list, so that we can actually use them.

    ```kotlin
    class List {
        fun add(t: Any) { ... }
        fun get(index: Int): Any { ... }
    }
    
    val stringList = List()
    stringList.add("testing") // remember, Strings only!
    val test: String = stringList.get(0) as String // hope it's a String
    ```

It probably doesn't need further explanation that both of these approaches are remarkably inconvenient and error-prone.

With generics, we can create a `List<T>` class, which uses the generic *type parameter* `T` in its implementation, such as for the parameter of `add` and the return type of `get`. Then, if we instantiate a `List<String>`, the type parameter is fulfilled by the concrete *type argument* `String`, and we'll only be able to add `String` instances to our list, and get any objects out of it with the `String` type as well. Safe and convenient!

```kotlin
class List<T> {
    fun add(t: T) { ... }
    fun get(index: Int): T { ... }
}

val stringList = List<String>()
stringList.add("testing")
val test: String = stringList.get(0)
```

> Under the hood, on the JVM, we're essentially performing the second scenario described out above - but the compiler is helping us out with a lot of the type checking and casting.

Similarly to generic classes, we can create generic functions, by adding type parameters to them. These allow us to, for example, define a `forEach` function that can work on a `List<T>`, regardless of what the actual `T` type is:

```kotlin
inline fun <T> List<T>.forEach(actions: (T) -> Unit) {
    for (element in this) actions(element)
}
```

The `T` type parameter is declared right after the `fun` keyword. Calling this on a `List<Person>` will substitute the type parameter with `Person` thanks to type inference, and give us a parameter of the `Person` type in our lambda:

```kotlin
people.forEach { person: Person ->
    println(person.name)
}
```

It's also possible to explicitly pass a type parameter to a function, if it can't be inferred from context, for example a function like this:

```kotlin
fun <T> create(): T { /* create an instance of T somehow... */ }

create<Person>()
```

> Type parameters are usually single letters in Kotlin. If you look into the Standard Library, you'll see plenty of `T`, `R`, and `C`. These are great if they're being used in relatively standard ways (`T` being whatever single generic parameter, `R` a return type parameter, `C` a collection of some kind), but they can get confusing otherwise. Don't be afraid to use generic type names such as `Item` or `Element` if it makes your code easier to read.

### Upper bounds

You can specify upper bounds for generic type parameters, if you have requirements for the type arguments. For example, you might want to create a function that accepts numbers, prints them as a `Double`, and then returns them with their original type:

```kotlin
fun <N : Number> printNumber(number: N): N {
    println(number.toDouble())
    return number
}

val l: Long = printNumber(23L)
```

One upper bound that you might want to use a lot is, surprisingly, `Any`. If you don't specify an upper bound for your functions, the default will actually be `Any?`, which allows any nullable type to be substituted as well! 

```kotlin
fun <T> testEquality(t1: T, t2: T): Boolean {
    return t1.equals(t2) 
          // ^ e: Only safe (?.) or non-null asserted (!!.) calls 
          //      are allowed on a nullable receiver of type T
}
```

Using `Any` as an upper bound will only allow subtypes of `Any`, which are all non-nullable types.

```kotlin
fun <T : Any> testEquality(t1: T, t2: T): Boolean {
    return t1.equals(t2)
}
```

> Note that specifying a type parameter such as `T : Any` still lets you use the `T?` type, if you need to.

By default, you can specify a single constraint on a type parameter when you declare it. But what if we needed, for example, a type parameter that implements both of these interfaces?

```kotlin
interface Writer {
    fun write(str: String)
}

interface Reader {
    fun read(): String
}
```

If you need multiple upper bounds, you can specify them at the very end of the function signature, with the `where` keyword:

```kotlin
fun <T> readWriteStuff(t: T)
        where T : Reader, T : Writer {
    val str = t.read()
    t.write(str)
}
```

While the language doesn't support intersection types (a type that's defined as having to be a subtype of multiple types), these kinds of combined constraints can give you type parameters which can behave a lot like a intersection type. 

### The usefulness of `Unit`

`Unit` being a proper type comes in handy with generics - let's say we have a `Task<T>` type like this:

```kotlin
interface Task<T> {
    fun execute(): T
}
```

If we need an instance that returns no result when it's done, in Java we couldn't express that as `Task<void>`, because `void` is not a type, just a keyword which signifies the special case of functions that don't return a result. Instead, we'd use the [`Void`](https://docs.oracle.com/javase/8/docs/api/java/lang/Void.html) type, which is the typesystem-equivalent of `void`, to create a `Task<Void>`.

In Kotlin, we can use the same `Unit` in both of these places to describe the lack of meaningful data, so we'd end up with simply `Task<Unit>`.

### Variance

The interaction of generics and inheritance is a very interesting one. For simple types, we know that they can be used wherever their supertypes are expected. What about generic types?

Let's create a `Garage` type representing a parking garage, which lets you park and then retrieve a generic type of `Car`:

```kotlin
interface Garage<T : Car> {
    fun park(car: T)
    fun take(): T?
}
```

The million-dollar question, then: given that a `Tesla` is a `Car`, does it follow that a `Garage<Tesla>` is a `Garage<Car>`?

#### Covariance

Let's see if we can use a `Garage<Tesla>` where a `Garage<Car>` is expected. We'll create a function that takes a `Garage<Car>` as a parameter, and uses its functionality. It first empties the entire garage, and then parks a new `Car` in it.
  
```kotlin
fun testGarage(garage: Garage<Car>) {
    // Empty the garage
    while (true) {
        val car: Car = garage.take() ?: break
        println("Removed $car")
    }
    // Park a new car
    garage.park(Car())
}
```

> Yes, `break` is also an expression, and its return type is `Nothing`. Handy!

Now, let's call it with a `Garage<Tesla>` as its parameter:

```kotlin
val teslaGarage = object : Garage<Tesla> {
    override fun take(): Tesla { ... }
    override fun park(car: Tesla) { ... }
}

testGarage(teslaGarage)
```

We get an error on the call to `testGarage`:

```
Type mismatch.
Required: Garage<Car>
Found: Garage<Tesla>
```

So why are we not allowed to pass in this parameter? Whenever `take()` is called, our `Garage<Tesla>` will return a `Tesla?`, which is a `Car?`. This is all sound. However, then we can also attempt to park a `Car()` (or `Fiat()`, or any other `Car` instance) in a `Garage<Car>`, which we can't do with a `Garage<Tesla>` that only accepts `Tesla` instances. *This means that a `Garage<Tesla>` is not a `Garage<Car>`.*

![Subtyping error for Garage](images/10_broken_garage.png)

We've seen that a `Garage<Tesla>` worked fine in the place of a `Garage<Car>` in certain ways, and not others. It was fine as long as we only took generic values *out* of it. If we just remove the problematic method that takes values of `T` as a parameter, our `Garage<Tesla>` would be safe to use as a `Garage<Car>`.

We'll define an interface that only allows picking cars up:

```kotlin
interface PickupPoint<out T : Car> {
    fun take(): T?
}
```

Note how we've marked the `T` type parameter with the `out` keyword. This keyword ensures that the generic type parameter is only used in *out* positions, i.e. as the return type of functions or properties. If we used `T` for a function's parameter inside this interface, in an *in* position, we'd get a compilation error. In exchange for this restriction, the compiler now knows that a `PickupPoint<Tesla>` can function as a `PickupPoint<Car>`:

```kotlin
fun testPickup(pickupPoint: PickupPoint<Car>) {
    // Take a car from the pickup point
    val car: Car = requireNotNull(pickupPoint.take())
    println("Driving a $car")
}

val teslaPickup = object: PickupPoint<Tesla> {
    override fun take(): Tesla? { ... }
}
testPickup(teslaPickup) // All good!
```

This behavior, marked by the `out` keyword, is called *covariance*. A generic type `Generic` is covariant on a type parameter, when `X` being a subtype of `Y` means that a `Generic<X>` will be a subtype of a `Generic<Y>`. The **subtyping direction is the same** for the parameters and the generic types that use them. They vary *together*, they are *co*variant.

![Covariance](images/10_covariance.png)

#### Contravariance

What about handing off cars to a `Garage`? We've seen that a `Garage<Tesla>` can't work as a `Garage<Car>` for these purposes, because a `Garage<Car>` has to accept any kind of `Car`. However, we can spot an inverse relationship here: a `Garage<Car>` could work as a `Garage<Tesla>` in this case, as it can accept `Tesla` instances!

Of course it won't be true that `Garage<Car>` is a subtype of `Garage<Tesla>`. When we want to pick up a `Tesla`, we can't get one from a `Garage<Car>` in a type safe manner, because it might contain other types of cars, and give us one of those. The same problem as before - we have to split this functionality into a one-way interface too:

```kotlin
interface HandoffPoint<in T : Car> {
    fun park(car: T)
}
```

This time, the type parameter is marked with the `in` keyword, which restricts us to using it in *in* positions, only as the types of values that the interface receives as a parameter. This tells the compiler that an instance of a `HandoffPoint` may have a more general type argument than what's required.

Case in point, it makes our `HandoffPoint<Car>` work as a `HandoffPoint<Tesla>`, just like we wanted it to:

```kotlin
fun testHandoff(handoff: HandoffPoint<Tesla>) {
    handoff.park(Tesla())
}

val carHandoff = object : HandoffPoint<Car> {
    override fun park(car: Car) { ... }
}
testHandoff(carHandoff) // OK!
```

This behavior, marked by the `in` keyword, is called *contravariance*. A generic type `Generic` is contravariant on a type parameter, when `X` being a subtype of `Y` means that a `Generic<Y>` will be a subtype of a `Generic<X>`. The **subtyping direction is reversed** between the type arguments and the generic types that use them. They vary in the *opposite* direction, they are *contra*variant.

![Covariance and contravariance](images/10_covariance_and_contravariance.png)

#### Invariance

With these new interfaces in place, we can quickly reintroduce the `Garage` type, as the combination of these two interfaces:

```kotlin
interface Garage<T : Car> : PickupPoint<T>, HandoffPoint<T>
```

The type parameter of `Garage` can neither be covariant nor contravariant, as it uses the `T` type parameter in both *in* and *out* positions. A type like this is an *invariant* type.

![Covariance, contravariance, and invariance](images/10_co_contra_and_invariance.png)

> We've seen that reading values from a type with a generic type parameter enables covariance. This is another benefit of having separate [`List`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-list/) and [`MutableList`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/-mutable-list/) interfaces in the Standard Library. While the `MutableList` interface is doomed to be invariant, `List` is actually covariant. A `List<Tesla>` is automatically  a `List<Car>`, which makes using lists a lot smoother!

> There are first-party types that use this exact same approach of splitting a bidirectional interface into two interfaces for variance. [`Channel`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html) is a good example of this, as it combines the [`SendChannel`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-send-channel/) and [`ReceiveChannel`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-receive-channel/) interfaces, which are contravariant and covariant, respectively.

#### Use-site variance and star projections [Extra content]

See the [extras for this chapter](./10-extras.md) for some even more advanced use cases for variance in Kotlin. You'll learn what the `Garage<*>` type means!

#### The usefulness of `Nothing` in generics

Generics and variance also gives us an opportunity to use `Nothing` again. It's a common pattern to define a sealed class that can either hold a generic result, or wrap an error, like this:

```kotlin
sealed class Result<T : Any>
class Success<T : Any>(val result: T) : Result<T>()
class Error<T : Any>(val throwable: Throwable) : Result<T>()
```

> Note how the result `T` type can never be nullable here.

If we want to report an error for a call that expects a `Result` like this, we can do it by creating an `Error` instance:

```kotlin
fun getData(): Result<String> {
    return Error<String>(RuntimeException("oh bother"))
}
```

The way that this `Error` class works is interesting. It defines a generic type parameter that it doesn't use - or rather, uses only to conform to its supertype. This class doesn't actually have to be generic to inherit from `Result`. It doesn't use its generic parameter in any way, and there's no reason why the same `Error` containing an exception couldn't be a `Result` that asked for a `String` and a `Result` that asked for a `Customer` at the same time. We can express this like so, thanks to `Nothing` being a bottom type:

```kotlin
sealed class Result<T : Any>
class Success<T : Any>(val result: T) : Result<T>()
class Error(val throwable: Throwable) : Result<Nothing>()
```

If we haven't realized that we needed variance on this class so far, we'd definitely realize it now, as a `Result<Nothing>` at this point is not a `Result<String>` or a `Result<Customer>`, so we can't use `Error` in the way that we wanted to use it.

Similarly, code like this doesn't work either, because a `Result<Employee>` is not a `Result<Person>`:

```kotlin
open class Person
class Employee : Person()

fun getPerson() : Result<Person> {
    return Success<Employee>(Employee())
}
```

The issue in both of these cases is that `Result` is invariant (the default behaviour for a generic parameter, if not specified otherwise), so only exact type arguments can be used. This can be fixed by adding covariance to our `Result` class, using the `out` keyword:

```kotlin
sealed class Result<out T : Any>
class Success<T : Any>(val result: T) : Result<T>()
class Error(val throwable: Throwable) : Result<Nothing>()
```

> Sealed classes for results of operations like this one are used frequently in Kotlin, as a way to avoid having to handle exceptions with `try-catch` blocks. Instead, methods using these result types can always return normally, and their results can be checked for success or failure using a `when` statement.

> Since Kotlin 1.5, the Standard Library contains a [`Result`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin/-result/) type that's quite similar to the one we've implemented here.

### Reified generics

In Java, whenever we use generics, we have to deal with a "feature" of the JVM called [*type erasure*](https://docs.oracle.com/javase/tutorial/java/generics/erasure.html). To oversimplify it: generic types only exist at compile time, and all generic parameters are replaced with the `Object` type by the time they end up in the bytecode. This differs for example from the C++ implementation of generics, where separate, typed classes get generated for every type parameter that a generic class is used with. (These approaches are the second and first of the painful manual options laid out [in the introduction at the beginning of this chapter](#the-reason-for-generics), respectively).

This type erasure is the reason why we have trouble with...

- Telling apart a `List<Kitten>` and a `List<Tiger>` at runtime by performing `instanceof` checks on a `List` instance

    ```java
    if (list instanceof List<Kitten>) {
        print("Aww.")    // ^ Error: Illegal generic type for instanceof
    } else if (list instanceof List<Tiger>) {
        print("Uh-oh.")         // ^ Error: Illegal generic type for instanceof  
    }
    ```

- Getting the `.class` of a type parameter like we'd do with a regular type

    ```java
    System.out.println(String.class); // This works
    System.out.println(T.class);     
                     // ^ Error: Cannot select from a type variable
    ```
 
- Performing type checks against a type parameter
    
    ```java
    System.out.println("" instanceof String); // This works
    System.out.println("" instanceof T);
                                  // ^ Error: Class or array expected
    ```

So what are reified generics, and how do they help us with these issues in Kotlin? They are, essentially, a clever compile time trick. When we create a generic function in Kotlin, we can mark its type parameters as `reified` - but only if we also make the function itself `inline`. For example:

```kotlin
inline fun <reified T> printType(t: T) {
    println("I think '$t' is ${T::class}")
}
```

Accessing the generic parameter's `class` wouldn't normally be possible on the JVM, however, if we call this function with the reified parameter, it works:

```kotlin
printType("hi")  // I think 'hi' is class kotlin.String
printType(Bar()) // I think 'Bar' is class foo.Bar
```

How is this possible? Remember, we can only make type parameters reified if our function is inlined - and that's exactly where the magic happens. When we call an inline function, its body is essentially copied to the call site instead of a function call being performed.

When this happens for a function that has a reified type parameter, all usages of that type parameter in the body get replaced with the concrete type argument that the function was invoked with at the call site. This is the same process that happens to regular parameters during inlining, just applied to type parameters this time.

For example, our previous two calls above compile to these lines (at the bytecode level), with the concrete values of the type parameters inlined:

```kotlin
println("I think '${"hi"}' is ${String::class}")
println("I think '${Bar()}' is ${Bar::class}")
```

... which are perfectly valid calls to perform on these concrete types.

This handy transformation also lets us perform type checks such as `x is T` if `T` is reified. For example, this generic function can be easily implemented in Kotlin:

```kotlin
inline fun <reified R> List<*>.filterType(): List<R> {
    val result = mutableListOf<R>()
    for (element in this) {
        if (element is R) {
            result.add(element)
        }
    }
    return result
}
```

It's an extension on a `List` with an unknown (or any) type argument, takes a reified type parameter, and filters the original list to only those elements that are of the type `R`. Its usage would look like this:

```kotlin
val list = listOf(1, 'o', 992.5233, 2, 25.21, "foo", 17)
println(list.filterType<Double>()) // [992.5233, 25.21]
```

When we invoke this `filterType` function with the `Double` type argument, the type check inside it becomes an `element is Double` check at compile time, which is perfectly valid bytecode.

> This function is actually called [`filterIsInstance`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.collections/filter-is-instance.html), and it's part of the Kotlin Standard Library.

## Summary
 
Kotlin has powerful support for advanced generics, with the help of type constraints, variance, and projections. You don't even really have to keep track of how these things interact in your code - the compiler pays attention to all of this for you, and ensures that you're only performing safe operations.

`Nothing` can be a useful type when defining generic class hierarchies. Reified generic type parameters let you access the values of type arguments at runtime.
 
## Sources
 
- Illustrated articles on generics by Dave Leeds
    - [An Illustrated Guide to Covariance and Contravariance in Kotlin](https://typealias.com/guides/illustrated-guide-covariance-contravariance/)
    - [The Ins and Outs of Generic Variance in Kotlin](https://typealias.com/guides/ins-and-outs-of-generic-variance/)
- Official documentation
    - [Generics: in, out, where](https://kotlinlang.org/docs/reference/generics.html)

# Chapter 11: Coroutines

Kotlin's coroutines are a language feature that enable powerful asynchronous programming. They're a "simple", low-level construct, that various kinds of asynchronous abstractions and APIs can be built upon. In this chapter, we'll get familiar with the practical basics of coroutines, and see how they can make our unavoidably asynchronous lives easier.

## Foundations

Threading, parallelism, concurrency... We'll come across a lot of similar-sounding concepts while exploring coroutines. Let's start by defining some of these.

#### Threading

All of our code executes on threads. By default, when writing a JVM console application, it creates just a single thread, which executes the `main()` function for us (and any functions called from there).

![A single main function on a thread](images/11_single_threaded_main.png)

We can also create own threads manually, if we want to get off of the main one. Then we can place code on them in the form of a `Runnable` (conveniently represented by a lambda in Kotlin), and run them, join them, interrupt them, ~~boil 'em, mash 'em, stick 'em in a stew~~ as we please.

```kotlin
val thread = Thread {
    println("Printing from this thread!")
}
thread.name = "my-background-thread"
thread.start()
thread.join()
```

![Episode IV: A New Thread](images/11_a_new_thread.png)

Threads are very expensive to create and tedious to manage with this direct API, so we have the abstraction of an [`Executor`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/Executor.html) (and the further abstraction of [`ExecutorService`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/ExecutorService.html)), which makes dealing with threads easier.

```java
public interface Executor {
    void execute(Runnable command);
}
```

`Executor`s can wrap a single thread or multiple ones (a threadpool) and *reuse* those for whatever tasks we throw at them in the form of `Runnable` instances, with neat scheduling, cancellation options, and so on. This is much cheaper than creating new threads all the time, for anything we want to do in the background.

```kotlin
val singleThreadExecutor: Executor = Executors.newSingleThreadExecutor()
val threadpoolExecutor: Executor = Executors.newFixedThreadPool(8)

singleThreadExecutor.execute {
    println("I'm in a Runnable!")
}
```

![ThreadPoolExecutor](images/11_threadpool_executor.png)

Why is going to background threads beneficial? One thing we might seek by doing this is improved performance, thanks to parallelism, which we'll get to in just a moment.

In other cases, it can also be a hard requirement. When we write GUI applications (be it Android, JavaFX, or Swing for example), the frameworks responsible for the GUI usually dedicate a single *main* or *UI* thread to processing input events and drawing the interface elements. If we block this thread with long-running code, our users will see our app freeze, which is a terrible experience!

#### Parallelism

Starting new threads and placing work on Executors like above lets us perform things in **parallel**. Multiple computations or IO operations can be in progress at the exact same time, which can reduce the total time that executing our program takes. For example, we can calculate the results of two complicated formulas at the same time, or process filters on two images on two separate threads.

![Truly parallel, multi threaded work](images/11_concurrent_parallel_multithread.png)

The alternative to parallel execution would be what we get by default when using a single thread: **sequential** execution. One task executed after another.

![Sequential, single thread work](images/11_sequential_single_thread.png)

Note that sequential doesn't always mean single-threaded. You can perform a sequential series of tasks while continuously hopping threads (in fact we'll do quite a bit of this later on!):

![Sequential, multi threaded](images/11_sequential_multi_thread.png)

Of course, not every task can or should be parallelized: for small tasks, the overhead of creating new threads and coordinating work between them will result in worse performance than just single-threaded sequential processing. Parallel code is also a lot harder to reason about than sequential code, as [race conditions](https://en.wikipedia.org/wiki/Race_condition#Software) may occur.

#### Concurrency

**Concurrency** is the idea of executing two tasks *virtually* at the same time. This can happen by true parallelism, on two different threads executing simultaneously on a multi-core CPU:

![Truly parallel, multi threaded](images/11_concurrent_parallel_multithread.png)

However, it can also be done using just a single thread and core in a time-sliced manner:

![Concurrent tasks on a single thread](images/11_concurrent_single_thread.png)

Both of these approaches achieve concurrency. To the outside world, it will seem like these two tasks have been performed "at the same time". This means that any concurrent code, even if it's not parallel, is subject to the perils of race conditions.

>Threads and scheduling are a very complex topic to discuss as we have CPU-level hyperthreading, upon which OS threads run, upon which JVM threads are created, etc. Slicing, optimizations, and virtualization happens at several levels here. We are using simplified, good-enough definitions here.

#### Asynchronicity

Two quick and relatively simple definitions to wrap up the introduction.

When you execute something **synchronously**, you wait for it to finish before moving on to another task. This is what happens with regular, blocking function calls.

>This would be making a sandwich for ourselves for dinner, performing all the required steps, participating in the process all along, without doing anything else while it's happening.

When you execute something **asynchronously**, you can move on to another task before it finishes, and then deal with the result later. This is what happens when you use callback-based APIs.

>This is making popcorn in the microwave. We start it, then for a while we are free to perform other tasks, and then we're eventually notified of completion by the beeping in the kitchen.

## Our asynchronous sample app

Enough definitions, let's see all of this in code! Our example app will be a JavaFX application, which allows us to search for TV shows using the [TVmaze API](https://www.tvmaze.com/api).

![Our TV Show browser app](images/11_tvshowapp.png)

We'll focus on the part of the application that fetches the show information from the network. This is done using two models:

```kotlin
data class ShowSummary(
    val id: Int,
    val name: String,
)

data class ShowDetails(
    val id: Int,
    val name: String,
    val status: String,
    val runtime: Int?,
    val premiered: String?,
    val language: String?,
)
```

### Blocking behaviour

... and an initial, blocking API with the following interface:

```kotlin
interface BlockingApi {
    fun search(query: String): List<ShowSummary>
    fun getDetails(id: Int): ShowDetails
}
```

First, we'll perform a search for the keyword that was input in the text box. This will yield a list of `ShowSummary` objects, which only contain IDs and titles, so we'll then call the details API for each of these IDs to figure out the status, runtime, premiere date, and more - this is the information contained in the `ShowDetails` model.

Here's this in code, using our API:

```kotlin
fun getShowDetailsBlocking(query: String, tableView: TableView<ShowDetails>) {
    val api: BlockingApi = BlockingApiImpl()

    val showSummaries = api.search(query) // blocking network call
    val details = showSummaries.map { summary ->
        api.getDetails(summary.id) // blocking network calls
    }

    tableView.setData(details)
}
```

> The TVmaze API actually returns all the data we need in the first fetch. We're not parsing it on purpose so that we have to make additional network calls for the detailed descriptions. This is for educational purposes only!

This takes *1+N* network calls - *N* being the number of results - which takes a bit of time. All these calls are executed on a single thread, sequentially, and synchronously. As our `map` call is looping through the summaries, it waits for each of their details to be fetched over the network.

This means that we are blocking the UI thread of the application while we're performing all these calls! If you try to interact with the application - sort a column, resize or move the window - while the search is happening, you'll see that it's unresponsive.

![Sequential calls to the API on a single thread](images/11_sequential_blocking_calls.png)

### Asynchronous callbacks

Let's get off the UI thread for our network calls with a popular solution: callbacks.

Instead of having our API's functions block the caller's thread until it can return the results, they'll take a callback function as their parameter, and return immediately. The actual network calls are started in a background thread, and the provided callback function will be invoked back on the main thread when the results are ready, *asynchronously*. In the meantime, the main thread will be free to do other things, for example, process UI events.

Our callback based API will have this interface:

```kotlin
interface CallbackApi {
    fun search(query: String, callback: (List<ShowSummary>) -> Unit)
    fun getDetails(id: Int, callback: (ShowDetails) -> Unit)
}
```

Let's take a look at how this may be implemented, on top of the original blocking API:

```kotlin
override fun search(query: String, callback: (List<ShowSummary>) -> Unit) {
    Thread {
        val result = blockingApi.search(query)
        Platform.runLater {
            callback(result)
        }
    }.start()
}
```

The function starts a new background `Thread` immediately, which it blocks for the duration of the network call, and then it gets back to the main thread to invoke the `callback`.

![A callback using a background thread](images/11_a_single_callback.png)

This is done by using [`Platform.runLater`](https://docs.oracle.com/javase/8/javafx/api/javafx/application/Platform.html#runLater-java.lang.Runnable-), which puts the `Runnable` it receives as a parameter on the event queue that the JavaFX application's main thread processes events from. This is the same queue that user input events will end up in! Whenever the main thread is not busy, it will process events from this queue, eventually running our `Runnable`, invoking the callback, which we'll use to update the table with the results.

> Other platforms with a GUI, such as Android, also have dedicated UI threads and various mechanisms to dispatch runnable pieces of code to that thread (e.g. [`runOnUiThread`](https://developer.android.com/reference/android/app/Activity.html#runOnUiThread(java.lang.Runnable))).

Starting a new `Thread` for every call into our API implementation is quite wasteful. This could be improved by using a single `ExecutorService` internally, backed by a threadpool of a couple of threads.

> Try making this improvement to the `CallbackApiImpl` class yourself!

Moving to this callback-based API will force us to change the way we write our code at the call site. The functions we call don't return results to us directly. They return immediately, and we have to place the code we want to run after they've produced a result in the callbacks.

Since we need to make a second round of network calls based on the results of the first one, we'll also have to nest our callbacks:

```kotlin
fun getShowDetailsWithCallbacks(query: String, tableView: TableView<ShowDetails>) {
    val callbackApi: CallbackApi = CallbackApiImpl()

    val results = mutableListOf<ShowDetails>()
    callbackApi.search(query) { showSummaries ->
        for (show in showSummaries) {
            callbackApi.getDetails(show.id) { showDetails ->
                results.add(showDetails)

                if (results.size == showSummaries.size) {
                    tableView.setData(results)
                }
            }
        }
    }
}
```

Note that since `getDetails` is now asynchronous and returns immediately (not waiting for its network call to complete), our behaviour has changed significantly here. The `for` loop fires off all requests for show details in parallel (each in their own thread), whereas we were making these calls sequentially before.

![Parallel threads shooting off for the callbacks](images/11_parallel_callbacks.png)

This will actually give us better load times, as network requests are generally slow operations, and are worth executing in parallel. However, it also comes with plenty of complications - as concurrent code was promised to.

Our callbacks will be invoked in an unknown order, which means that it's no longer simple to tell when they're all done, so that we can use their results. To know when we've received the last callback, we are placing each details object in a `MutableList` as it's loaded, and whenever there are as many items in the list as we expect it to have for the final result, we figure that we're done and set the data in the `TableView`.

This has some issues:

- The results in this list are in essentially random order, as our network calls might have taken varying amounts of time, and the callbacks could've run in any order. If the order of these items was important, we'd have to somehow keep track of this (or sort them after they're all loaded).
- We should've prepared for some of these calls failing, which can happen easily when making network requests. If any of the calls fail and they don't invoke their callback, that will mean that we'll never reach the desired list size in the callbacks, despite getting *some* amount of results from the network. Our UI will never be updated.

Fixing these kinds of things using callbacks is very, very painful. Even if these all worked magically, callbacks twisted our code inside out. Instead of writing code from top to bottom, we are forced to continuously nest callbacks into each other as our asynchronous steps progress, in a lovely structure often referred to as callback hell (see [here](http://callbackhell.com/), [here](https://stackoverflow.com/a/25098230/4465208), and especially [**here**](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)).

### Futures, Promises, and Rx

There are higher level abstractions that operate asynchronously, but they at least flatten sequential asynchronous calls by chaining function calls together. For example, the same code using a [`CompletableFuture`](https://docs.oracle.com/javase/8/docs/api/java/util/concurrent/CompletableFuture.html) based API might look something like this (with a bit of help from [Java Streams](https://docs.oracle.com/javase/8/docs/api/java/util/stream/package-summary.html) to fire off a list of futures at the same time):

```kotlin
futureApi.search(query)
    .thenApply { summaries ->
        val futures = summaries.map { futureApi.getDetails(it.id) }
        Stream.of(*futures.toTypedArray())
            .map(CompletableFuture<ShowDetails>::join)
            .collect(Collectors.toList())
    }
    .thenAccept { results: List<ShowDetails> ->
        Platform.runLater {
            tableView.setData(results)
        }
    }
```

Or using the ever popular [RxJava](https://github.com/ReactiveX/RxJava) library, you could do something like this:

```kotlin
rxApi.search(query)
    .flatMapObservable { showSummaries ->
        Observable.fromIterable(showSummaries)
    }
    .flatMapSingle { rxApi.getDetails(it.id) }
    .toList()
    .subscribeOn(Schedulers.io())
    .observeOn(JavaFxScheduler.platform())
    .subscribe { results: List<ShowDetails> ->
        tableView.setData(results)
    }
```

These solutions both avoid the issues of callbacks to some degree. They prevent endless nesting by turning the same sequential behaviour into chained calls. They are also able to keep the order of the items while grabbing the details, and even give you reasonable error handling functionality (not present in the code snippets above).

However, they come with their own downsides. `CompletableFuture` has a fairly small API, and you'll somehow have to grab additional tools such as [`Stream`](https://docs.oracle.com/javase/8/docs/api/java/util/stream/Stream.html) to combine them just the way you need them.

RxJava is likely to have an operator for everything you'll ever need, you just have to know about them and figure out how to combine them. This is also its drawback, it has [*all of the operators*](http://reactivex.io/documentation/operators.html). You have to learn these and get used to them.

Both of these APIs solve some of our problems - they give us multi-threaded, asynchronous calls, with error handling - but they require us to shape our code differently from the traditional, imperative, synchronous style that we write blocking code in, and are used to.

> This familiarity is useful: it helps us spot mistakes in the code, as we already know what certain patterns will behave like.

Their APIs are also not what we're used to with synchronous code. Instead of returning the actual types that they are "returning", they return wrappers that will eventually yield these types somehow. In the case of the `Rx` example, all return values are wrapped in `Single`s:

```kotlin
interface RxApi {
    fun search(query: String): Single<List<ShowSummary>>
    fun getDetails(id: Int): Single<ShowDetails>
}
```

With all of this behind us, let's see how coroutines can make dealing with all of these issues simpler.

## Coroutines

Coroutines are small pieces of work that can be executed in the background. They used to be advertised as *lightweight threads*, which gets the basic idea across well enough, but we'll see that coroutines are much more capable (and indeed, much more lightweight) than threads in many ways.

Once again, we'll use our original blocking API, this time as the basis for the coroutine implementation of fetching shows. We'll start our first coroutine by using `GlobalScope.launch`. This `launch` function returns immediately, and the lambda passed to it will be executed on a background thread - in a coroutine:

```kotlin
val api: BlockingApi = BlockingApiImpl()

GlobalScope.launch {
    // start of the coroutine
    val showSummaries = api.search(query)
    val details = showSummaries.map {  summary ->
        api.getDetails(summary.id)
    }
    tableView.setData(details)
    // end of the coroutine
}
```

> Nearly all of the coroutine functionality we'll be using comes from a library, [`kotlinx.coroutines`](https://kotlin.github.io/kotlinx.coroutines/). You can think of this library as the Standard Library's equivalent for coroutines. Just like there's basically no Kotlin without the Standard Library, there's also nearly no coroutines without `kotlinx.coroutines`.

What happens here is conceptually very similar to just starting a `Thread` manually, like this:

```kotlin
Thread {
    val showSummaries = api.search(query)
    val details = showSummaries.map {  summary ->
        api.getDetails(summary.id)
    }
    tableView.setData(details)
}.start()
```

This is a good start, but there's still the issue of getting back to the main thread for the call to the `tableView`. So let's talk about how coroutines handle threads, and how we can control the threads that they are executed on.

### Contexts

Taking a look at the simplified signature of the `launch` function, we can see that it takes a `CoroutineContext` as an optional parameter.

```kotlin
fun launch(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend () -> Unit
): Job
```

> We'll ignore the `GlobalScope` part of our coroutine starting code for now for simplicity, but we'll get back to it later!

So what's a context then? It's a set of *elements* that describe *how* a coroutine is executed. These elements can control various aspects of a coroutine:

- Threading
- Cancellation
- Error handling
- A name for debugging

A `CoroutineContext` may contain a value for any number of these elements, even none or all of them. You can think of these as being available slots in the context that may be filled or left empty:

![An empty CoroutineContext](images/11_empty_context.png)

Each of these elements may be used as a `CoroutineContext` on their own, in that case, they form a context with only a single element.

![A single element in a context](images/11_single_coroutine_element.png)

Contexts can also be combined easily using the `+` operator. If two contexts that contain the same kind of element are combined, the element on the right-hand side of the operator will be the one that makes it into the result context.

![Combining CoroutineContexts](images/11_context_addition.png)

The threading aspect of coroutines is handled by [`CoroutineDispatcher`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/) instances. The `kotlinx.coroutines` library includes a few dispatcher implementations that cover most common use cases, which are found nested in the [`Dispatchers`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/index.html) object:

- [`Default`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-default.html)
  - Used by default for new coroutines if no other dispatcher is specified. It's meant to be used for CPU-heavy computational tasks. This dispatcher wraps as many threads as your CPU has, but at least two. Thanks to having a matching number of threads to CPU cores, running lots of coroutines using this dispatcher can comfortably saturate all CPU cores.
- [`IO`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-i-o.html)
  - This dispatcher also wraps a threadpool, and is meant to be used for IO intensive work (for example, disk and network interactions), which block threads, but don't require CPU-heavy computation. It uses 64 threads for this purpose (or the number of cores the CPU has, if that happens to be more).
- [`Main`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-main.html)
  - This dispatcher is only available if there is a GUI framework being used, and wraps the main thread of the application in a platform-specific way. To access this dispatcher, additional dependencies (e.g. [`kotlinx-coroutines-javafx`](https://github.com/Kotlin/kotlinx.coroutines/tree/master/ui/kotlinx-coroutines-javafx)) have to be included in the project.
- [`Unconfined`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-dispatchers/-unconfined.html)
  - A special dispatcher which doesn't prescribe any specific thread for the coroutine, and simply executes on the thread that it was started from (with some caveats, see its documentation for more precise details).

To use any of these dispatchers, we can pass them in as the parameter of the `launch` function, and the coroutine it starts will execute on that dispatcher. We'll also be able to change the dispatcher a coroutine is running on as it's executing.

> Fun fact: the IO and Default dispatchers described above actually share threads between their threadpools, which means that switching between these two dispatchers in a running coroutine might be entirely free, as it can theoretically just keep using the same thread!

These are just the built-in dispatchers, but you may also create your very own, should you need to do something very specific for threading. For example, you might want to have a Dispatcher wrapping a single background thread, and move all of your database operations to that Dispatcher with coroutines. The easiest way to create your own Dispatcher is to convert an `Executor` into one:

```kotlin
val dispatcher: CoroutineDispatcher = 
        Executors.newSingleThreadExecutor().asCoroutineDispatcher()
```

> If you simply need a dispatcher that confines how many parallel coroutines you have running on it, you can use [`limitedParallelism`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-dispatcher/limited-parallelism.html) on an existing dispatcher (such as `Dispatchers.Default` or `Dispatchers.IO`) to avoid creating new threads.

### Using the correct context in our sample app

With our newfound knowledge of coroutine dispatchers, let's launch our coroutine performing network calls in the correct context:

```kotlin
GlobalScope.launch(Dispatchers.IO) {
    val showSummaries = api.search(query)
    val details = showSummaries.map {  summary ->
        api.getDetails(summary.id)
    }
    tableView.setData(details)
}
```

![A coroutine launched on the IO dispatcher](images/11_io_only.png)

Blocking network calls now happen on a thread provided by `Dispatchers.IO`, yay! However, we still didn't make it back to the UI thread for our `tableView` update. For this, we'll use the [`withContext`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/with-context.html) function. This higher-order function takes a lambda that it will execute sequentially inside our coroutine, but will do so in a different context - the one given to the function as a parameter.

Since a `CoroutineContext`, among other things, defines the thread the coroutine executes on, we can use this to move a part of our coroutine to the main thread, with `Dispatchers.Main`:

```kotlin
GlobalScope.launch(Dispatchers.IO) {
    val showSummaries = api.search(query)
    val details = showSummaries.map {  summary ->
        api.getDetails(summary.id)
    }
    withContext(Dispatchers.Main) {
        tableView.setData(details)
    }
    println("Back in the background!")
}
```

The mechanism making this happen is the very essence of coroutines - suspension. The `withContext` function is a *suspending* function. When it's called, it suspends execution of the coroutine on the IO thread that it was started on, *freeing up that thread for other coroutines to use*.

Then, it executes the code passed to it in the specified context, in this case, on the main thread. When it's done, `withContext` returns, and our coroutine will get back into the context of the IO Dispatcher, and continue from the point where it left off before suspending, executing the rest of the code in it after the `withContext` call. In this example, this is the dummy call to `println`.

![Switching to the Main dispatcher for the UI change](images/11_io_then_main.png)

> Note that the coroutine gets back into the context of `Dispatchers.IO` after `withContext` returns, but this doesn't mean that it'll be on the same thread as before. It can end up on any thread used by this Dispatcher.

It's more conventional to turn this thread handling inside out - start the coroutine in the context of the UI thread and have its contents execute there by default. Any costly blocking calls can then be moved to background threads by switching contexts:

```kotlin
GlobalScope.launch(Dispatchers.Main) {
    val showSummaries = withContext(Dispatchers.IO) {
        api.search(query)
    }
    val details = showSummaries.map { summary ->
        withContext(Dispatchers.IO) {
            api.getDetails(summary.id)
        }
    }

    tableView.setData(details)
}
```

![Starting on the Main dispatcher, and moving to IO for each call](images/11_main_first_io_for_each.png)

Notice how `withContext` actually returns the result of the part of the coroutine that executes inside it, which is used above in both cases. This is possible, as the function that calls it is suspended while it executes, and waits for this result.

It's also worth noting that we can use `withContext` inside complex structures, such as inside the lambda passed to the `map` function! Now the main thread will be suspended mid-loop whenever we perform a `getDetails` call.

Making these context changes here in the UI handling code with `withContext` is a bit unsightly, and if we forget to wrap these calls, we'll accidentally block the UI thread. Thankfully, we can create our own *suspending functions*, which will have the same ability as `withContext` - they'll be able to execute without blocking the caller thread!

This is done by using the `suspend` keyword on our functions. Yes, we'll now `suspend fun`. We'll create a `CoroutineApi` interface like this:

```kotlin
interface CoroutineApi {
    suspend fun search(query: String): List<ShowSummary>
    suspend fun getDetails(id: Int): ShowDetails
}
```

There are no callbacks, and the methods directly return the result when they're called. However, they'll be able to do this in a non-blocking way, by suspending. Their implementation is actually rather simple too: we'll use `withContext` inside them to switch from whatever thread the methods were called on to the IO dispatcher!

```kotlin
class CoroutineApiImpl : CoroutineApi {
    private val blockingApi: BlockingApi = BlockingApiImpl()

    override suspend fun search(query: String): List<ShowSummary> {
        return withContext(Dispatchers.IO) {
            blockingApi.search(query)
        }
    }

    override suspend fun getDetails(id: Int): ShowDetails {
        return withContext(Dispatchers.IO) {
            blockingApi.getDetails(id)
        }
    }
}
```

The call site at this point simplifies to something very familiar and simple looking:

```kotlin
val api: CoroutineApi = CoroutineApiImpl()

GlobalScope.launch(Dispatchers.Main) {
    val showSummaries = api.search(query) // suspends!
    val details = showSummaries.map { summary ->
        api.getDetails(summary.id) // suspends!
    }
    tableView.setData(details)
}
```

Apart from having to start the coroutine, the rest of our code looks the same as its blocking, synchronous counterpart that we started out with. Unlike with callbacks, futures, or reactive frameworks, coroutines don't make you learn a new style of programming, and don't change the shape of your code.

What's done with comments above, noting *suspension points*, is actually marked by the IDE with icons:

![Suspension points in IntelliJ IDEA](images/11_suspension_points.png)

The `suspend` keyword and its accompanying mechanism is actually the only support provided for coroutines by the language. All other constructs that we're using here (`launch`, `withContext`, and so on) come from the `kotlinx.coroutines` library, which is a first-party library built on top of the suspension mechanism. The expectation is that only library authors will ever have to interact with the coroutine APIs on the lowest levels, and everyone else writing application code will rely on `kotlinx.coroutines` and similar libraries (like we just did!), which offer higher level abstractions.

Thanks to asynchronous code with coroutines keeping its simple, straightforward, imperative style, you can still make function calls, assign their results to variables, and quite importantly, still use constructs like basic loops, or the collection functions you've already learned, and even the regular try-catch for error handling (across threads!).
 
Here's an example of a suspending function that, depending on a coin flip, either returns a value or throws an exception:

```kotlin
suspend fun failedValueFetch(): Int = withContext(Dispatchers.Default) {
    if (Random.nextBoolean()) {
        throw RuntimeException("Oops!")
    }
    return@withContext 13
}
```

If we call this from another suspending function, we can surround it with a `try-catch`, which will work as we'd expect it to for blocking, synchronous calls.

```kotlin
suspend fun tryToFetchValue() {
    try {
        println(failedValueFetch())
    } catch (e: Exception) {
        e.printStackTrace()
    }
}
```

The `e.printStackTrace()` call will run in whatever context this function was invoked on, even though the exception is being thrown from the context of `Dispatchers.Default`.

### Suspension doesn't happen magically

It's very important to note that marking a function with the `suspend` keyword only *enables* it to suspend execution on the caller thread - it doesn't perform the suspension on its own. For example, a function like this is still not safe to call from the main thread, as it performs a heavy computation that will freeze the UI:

```kotlin
suspend fun findBigPrime(): BigInteger = BigInteger.probablePrime(4096, Random())
```

A well-behaving suspending function is expected to suspend on the caller thread, and perform its work somewhere else. This might be done by using `withContext`, which is a very commonly used solution, but there are also other mechanisms available that can be used to suspend a coroutine. We either have to do this ourselves, or call into a library that provides a suspending API that will perform the required suspension work internally.

### Starting coroutines

Suspending functions have an important rule: they can only be called from other suspending functions. A regular function has no notion of suspending execution, so they'd have no way of waiting for a suspending call to return its result.

This presents a small riddle: how do we make our first call to a suspending function, if we need to already be in a suspending function to do so? This is the purpose that *coroutine builders* serve. They let us bridge the gap between the regular, synchronous world and the suspenseful world of coroutines.

[`launch`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/launch.html) is the first coroutine builder that we've taken a look at. The trick to `launch` is that it takes a lambda parameter, which is a suspending function:

```kotlin
fun launch(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend () -> Unit
): Job
```

It creates a new coroutine, which will execute the suspending `block` of code passed to it. `launch` is a fire-and-forget style coroutine builder, as it doesn't return a result. The `launch` function returns immediately after starting the coroutine, while the started coroutine fires off asynchronously. It does return a [`Job`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job/index.html) instance, which, according to the documentation:

> is a cancellable thing with a life-cycle that culminates in its completion.

Basically, this `Job` represents a piece of work being performed for us by a coroutine, and can be used to keep track of that coroutine. For example, we can check if it's still running, or cancel it:

```kotlin
val job = GlobalScope.launch {
    println("Job is running...")
    delay(500)
    println("Job is done!")
}

Thread.sleep(200L)
if (job.isActive) {
    job.cancel()
}
```

> [`delay`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/delay.html) is a handy suspending function that we can use inside coroutines to wait for a given amount of the time in a non-blocking way.

Since the coroutine above is cancelled before the `delay` is over, only its first print statement will be executed.

We can also `join` a `Job` (wait until it completes), similarly how we can join a `Thread`. This doesn't happen in a blocking way, however. The `join` method on `Job` is suspending, and will suspend until that `Job` completes. This means that we can only use it if we're inside a coroutine, for example:

```kotlin
fun main() {
    val job = GlobalScope.launch {
        println("Job is running...")
        delay(500)
        println("Job is done!")
    }

    GlobalScope.launch {
        println("Second coroutine started, will wait for first")
        job.join()
        println("All done!")
    }

    Thread.sleep(1000)
}
```

This will print the following:

```
Job is running...
Second coroutine started, will wait for first
Job is done!
All done!
```

### Under the hood of a suspending function

Let's take a brief look at coroutines under the hood, to see how the suspension mechanism works. We'll use this piece of code for this:

```kotlin
suspend fun compute(question: String): Int {
    delay(236_682_000_000_000_000L) // ~ 7.5 million years
    return 42
}

fun demoCoroutines() {
    GlobalScope.launch {
        println("Asking question")
        val result = compute("life, universe, and everything")
        println("Answer was: $result")
        delay(1000)
        println("Forty-two?!")
    }
}
```

Every call to a suspending function creates a *suspension point* in your function. These suspension points slice your functions up into various pieces, each of which executes in a regular, boring, blocking way. For our `demoCoroutines` function with its two suspension points, this means three distinct parts:

![Slices in the function above](images/11_continuations.png)

The first, yellow block executes together, as a series of blocking instructions. When it calls into `compute` though, the magic happens. It doesn't just pass in the `String` parameter that's visible here at the call site: it also passes in a *continuation*. 

Here's what (a slightly skewed projection of) the interface of the `Continuation` type looks like:

```kotlin
public interface Continuation<in T> {
    public val context: CoroutineContext
    public fun resume(value: T)
    public fun resumeWithException(exception: Throwable)
}
```

This `Continuation` represents the remaining part of our coroutine after a suspension point, and it's how we can get back to our coroutine after a suspension completes. Its generic type argument is whatever type the suspending function call returns to the next piece of the coroutine. If we manage to produce this value inside the suspending function, `resume` will be called, and if we failed with an exception, `resumeWithException` is called instead.

All of this is invisible to us at the source level, but if we get a good enough decompiler (and unfortunately, the built-in one is not able to handle coroutines too well), we can see it happening at the bytecode level:

```java
@Nullable
public static final void compute(
    @NotNull final String question,
    @NotNull final Continuation<Integer> $completion) {
     // lots of code pertaining to delay, which would be yet another 
     // suspending call and an additional level of nesting...
     $completion.resume(42)
}
```

> This is *not* the real bytecode produced by coroutine code, it is vastly simplified here to avoid some of the complicated details.

Every time we suspend, we pass in the next piece of code to be executed after the asynchronous call is completed as a parameter. This type of programming is called [*continuation-passing style*](https://en.wikipedia.org/wiki/Continuation-passing_style), as opposed to the *direct style* that we're used to with synchronous code.

But doesn't this look awfully familiar? We've managed to make our way back to using callbacks! However, we are much better off than before. Instead of writing these callbacks ourselves, and having to think in this style at the source level, the compiler is performing this transformation for us!

The actual implementation of coroutines also involves some generated classes to hold state, as well as a state machine that keeps track of which suspension point a given coroutine is at in a function. We won't dive any deeper into this here, but you can find more resources on this in the sources below.

### Explicit parallelism

Let's get back to the high level APIs that we actually want to use! We already know `launch`, our simple, fire-and-forget coroutine builder. We can also switch threads back and forth by using `withContext` and passing in various dispatchers. However, all of our coroutine code so far has been sequential. At each suspension point, the coroutine waited for the suspending call to return, and then continue from there.

Let's use this dummy function in the upcoming snippets to load some data, with a bit of a delay, in a suspending way.

```kotlin
suspend fun getData(index: Int): Double {
    delay(1000L)
    return index.toDouble() * 2
}
```

If we want to load two pieces of data with this function using `launch`, this will take us two seconds, as we only start loading the second piece of data once we have the first one:

```kotlin
GlobalScope.launch {
    val result = getData(1) + getData(2) 
    println("Result is $result")
}
```

This is perhaps even clearer if we format this code this way:

```kotlin
GlobalScope.launch {
    val data1 = getData(1) // Loads for 1 second
    val data2 = getData(2) // Another load for 1 second
    val result = data1 + data2
    println("Result is $result")
}
```

This sequential-by-default behaviour of coroutines is actually very handy. As discussed in the introduction, it's much easier to reason about sequential code than concurrent code.

Coroutines do also support parallelism, but they require us to be explicit about it. The second coroutine builder we'll learn is the one that lets us run coroutines in parallel: [`async`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/async.html).

When we call `async`, we pass it a suspending function as its parameter, just like we did with `launch`. However, `async` is not fire-and-forget: it will produce a value when it's done. The value is represented by the [`Deferred`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/index.html) object that's returned from the `async` call (immediately, after it fires off the coroutine). This is a coroutine-powered, non-blocking *future*/*promise* type.

If we create two coroutines with `async` that each call `getData`, they'll start executing in parallel:

```kotlin
val data1: Deferred<Double> = GlobalScope.async { 
    getData(1) 
}
val data2: Deferred<Double> = GlobalScope.async { 
    getData(2) 
}
```

To get the results of these coroutines, we'll have to use the [`await`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-deferred/await.html) function available on `Deferred`. Hello, *async-await*. `await` is a non-blocking, suspending function. This means that we have to call it inside a coroutine. Let's just start a third coroutine for now, which will `await` both results, and then print their sum:

```kotlin
val data1 = GlobalScope.async { getData(1) }
val data2 = GlobalScope.async { getData(2) }

GlobalScope.launch {
    val result = data1.await() + data2.await()
    println("Result is $result")
}
```

This last coroutine here has two suspension points, one at each `await` call. Unlike before, however, these `await` calls aren't what start the data fetches - by the time we get to these, those are already happening in the first two coroutines which are running.

These `await` calls only serve to suspend until each `Deferred` can produce a result, and they will return as soon as the async coroutines that are behind the `Deferred` instances complete. Since these run in parallel, the first `await` call will take about a second to return, but the second `await` call will return almost immediately.

In total, this code will execute in roughly one second, instead of the two that it would've taken sequentially.

### Cancellation

Let's talk about the details of cancellation next, which will eventually get us to a second `CoroutineContext` element, as well as one last crucial concept around coroutines.

```kotlin
val job = GlobalScope.launch {
    println("Job is running...")
    delay(500)
    println("Job is done!")
}

Thread.sleep(200L)
if (job.isActive) {
    job.cancel()
}
```

We've seen that code like this works, and only the first message in the coroutine is printed:

```
Job is running...
```

This happens because we call `cancel` while the suspending `delay` call is happening in the coroutine. What if there were no suspension points in the coroutine, and its entire body was just blocking code? For example, if we replace the `delay` call with [`Thread.sleep`](https://docs.oracle.com/javase/8/docs/api/java/lang/Thread.html#sleep-long-):

```kotlin
val job = GlobalScope.launch {
    println("Job is running...")
    Thread.sleep(500L)
    println("Job is done!")
}

Thread.sleep(200L)
if (job.isActive) {
    job.cancel()
}
```

If we run the code again, we'll see this output:

```
Job is running...
Job is done!
```

We're in trouble, cancellation is now broken! It turns out that coroutines can only be cancelled *cooperatively*. While a coroutine is running continuously blocking code, it won't be notified of being cancelled.

Why doesn't the `Thread` that the coroutine is running on get shut down forcibly? Because doing something like this would be dangerous. Whenever you write blocking code, you expect all those lines of code to be executed together, one after another. If this gets cut off in the middle, completely unexpected things can happen in the application. Hence the cooperative approach instead.

So how do we cooperate? For one, we can call functions from `kotlinx.coroutines` that support cancellation already - `delay` was an example of this. If our coroutine is cancelled while we are waiting for `delay`, it will throw a `JobCancellationException` instead of returning normally. If our coroutine was cancelled some time *before* a call to `delay`, and this cancellation wasn't handled yet, `delay` will also throw this exception as soon as it's called.

For example, let's say that we have a list of entities to save to two different places which we perform by calling these two blocking functions:

```kotlin
fun saveToServer(entity: String): Unit = ...
fun saveToDisk(entity: String): Unit = ...
```

We don't want to end up in a situation where we've saved an entity to one of these places, but not the other. We either want both of these calls to run for an entity, or neither of them. 

A first approach to this problem would be to just block a thread on the IO dispatcher for the entire length of our operation, which ensures that this coroutine is practically never cancelled:

```kotlin
suspend fun processEntities(entities: List<String>) = withContext(Dispatchers.IO) {
    entities.forEach { entity ->
        saveToServer(entity)
        saveToDisk(entity)
    }
}
```

However, we can also add cancellation support, by checking if our current coroutine has been cancelled, manually. For example, we can do this after processing each entity:

```kotlin
suspend fun processEntities(entities: List<String>) = withContext(Dispatchers.IO) {
    entities.forEach { entity ->
        saveToDisk(entity)
        saveToServer(entity)
        if (!isActive) {
            return@withContext
        }
    }
}
```

If our coroutine is cancelled while we run the blocking part of our code, that entire blocking part will still be executed together, but then we'll eventually notice the cancellation at the end of the loop, and stop performing further work, in a safe way.

There is a dedicated function in kotlinx.coroutines to check for a cancelled coroutine: [`ensureActive`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/ensure-active.html).

All `ensureActive` does is handle cancellation (meaning that it throws a `JobCancellationException` when it's invoked in a cancelled coroutine:

```kotlin
public fun Job.ensureActive(): Unit {
    if (!isActive) throw getCancellationException()
}
```

This means that we can call it every once in a while when performing lots of blocking work, to provide opportunity for the coroutine to be cancelled. This is done completely manually though, explicitly, which means we are aware of the possibility of cancellation. `ensureActive` can easily replace manual cancellation checks, if terminating with an exception upon cancellation is good enough for us:

```kotlin
suspend fun processEntities(entities: List<String>) = withContext(Dispatchers.IO) {
    entities.forEach { entity ->
        saveToDisk(entity)
        saveToServer(entity)
        ensureActive()
    }
}
```

Just like with `delay`, even if the coroutine happens to have been cancelled some time before `ensureActive`, it will notice this, and throw an exception. The cancellation doesn't have to happen at the exact time that `ensureActive` is called.

Note that if there's some cleanup of the coroutine to do (freeing up resources, etc.) when it's cancelled, manual cancellation checks can still be very handy, and should be used instead of `ensureActive`.

> Another function from kotlinx.coroutines is [`yield`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/yield.html), which has the original purpose of performing a manual suspension of the current coroutine, just to give other coroutines waiting for the same dispatcher a chance to execute. It essentially reschedules the rest of our coroutine to be executed on the same dispatcher that it's currently on. If there's nothing else waiting to use this dispatcher, this is the same as a 0-length delay. Since it's nearly a no-op, and handles cancellation (throws an exception if the coroutine it's in is cancelled), you might see it used for the same purpose as `ensureActive`.

### Structured concurrency 

Let's take another look at this code example that loads two pieces of data in parallel, and then combines them, but now with cancellation in mind.

```kotlin
val data1 = GlobalScope.async { getData(1) }
val data2 = GlobalScope.async { getData(2) }

GlobalScope.launch {
    val result = data1.await() + data2.await()
    println("Result is $result")
}
```

Something is still not quite right with the code above. If one of the coroutines started with `async` fails with an exception, the coroutine that awaits it (the one started by `launch`) will also receive that exception, crashing that coroutine too, however, the other `async` call will continue in the background! We've only cancelled two of the three coroutines.

Though we *can* cancel coroutines manually, it's easy to see that if we had to keep track of every possible failure that can occur while running coroutines and cancel every related coroutine manually, we'd be writing *a lot* of error handling code. We'd be back to the kind of manual management that we can perform on threads.

Here's where we'll learn about a second `CoroutineContext` element: the parent `Job`. `Job` instances work in a hierarchy, and if we pass in a `Job` instance as the context of a coroutine (either on its own, or combined with other elements), it becomes the parent of the newly started coroutine's `Job`.

This hierarchy has the following effect on these jobs:

- A `Job` won't get to a completed state until all of its children have completed. A parent always waits for its children.
- If a `Job` is cancelled, all of its children are immediately cancelled as well, recursively.
- If a `Job` fails with an exception, its parent fails immediately as well, consequently cancelling all other siblings.

For a basic cancellation example, let's take a look at this code, where the second coroutine is started as the child of the first one, using the `context` parameter:

```kotlin
val job = GlobalScope.launch {
    println("This is job 1")
    delay(500)
    println("This was job 1")
}

GlobalScope.launch(context = job) {
    println("This is job 2")
    delay(500)
    println("This was job 2")
}

Thread.sleep(200L)
job.cancel()
```

Calling `cancel` on the first `Job` will also cancel its child job, resulting in only this output:

```
This is job 1
This is job 2
```

Getting back to our two `async` calls, how can we use the `Job` mechanism for cancellation there? We'd need a `Job` to serve as the parent of both `async` calls if we want them to be cancelled together. We could start an empty, dummy coroutine for this that just waits around for a while (with `launch`, for example), but there's a simpler and nicer way to do this: by creating a `Job` with its ["constructor"](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-job.html):

```kotlin
val parent = Job()

val data1 = GlobalScope.async(context = parent) { getData(1) }
val data2 = GlobalScope.async(context = parent) { getData(2) }
GlobalScope.launch(parent) {
    val result = data1.await() + data2.await()
    println("Result is $result")
}
```

This works! If either of our three coroutines fail, they'll cancel their parent, and all the rest will be cancelled neatly.

This kind of a parent `Job` was used for a while to group coroutines in components that should all be cancelled together, when that component is destroyed in some sense. This component is usually a dialog or screen in a GUI application, or a service in a backend application. *Something* that has a lifecycle and performs work, and has to stop performing work when its lifecycle ends.

> "On a more philosophical level, you rarely launch coroutines “globally”, like you do with threads. Coroutines are always related to some local scope in your application, which is an entity with a limited life-time, like a UI element." 
> - [Roman Elizarov on Structured Concurrency](https://medium.com/@elizarov/structured-concurrency-722d765aa952)

We'll use the example of an Android [`Activity`](https://developer.android.com/reference/android/app/Activity), which represents a screen, and receives an [`onDestroy`](https://developer.android.com/reference/android/app/Activity#onDestroy()) callback when it's closed.

If we want to cancel all coroutines in an `Activity` when it closes, we can use the parent `Job` approach from before, like this:

```kotlin
class MainActivity : Activity() {
    private val parent = Job()
    
    override fun onDestroy() {
        super.onDestroy()
        parent.cancel()
    }
    
    fun onClick(button: Button) {
        GlobalScope.launch(parent + Dispatchers.Main) { 
            // Do stuff to handle button clicks
        }
    }
}
```

The only issue now is that you always have to remember to add this `parent` to the context that you launch your coroutines in - that it's optional to specify the parent. If you decide not to include it, your coroutines will run loose, and will never be cleaned up.

#### The introduction of `CoroutineScope`

With the evolution of coroutines, [`CoroutineScope`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope/) was introduced to fill in this gap, and to not only enable, but force us to think of scoping coroutines. 

Every coroutine builder became an extension on `CoroutineScope`, which forces us to choose a scope to start each coroutine. So far, we've been using `GlobalScope`, which is just what it sounds like. It ties all coroutines in it to the entire lifetime of the application, which isn't great. Coroutines started in this scope are never cancelled automatically, for example. Very rarely should a coroutine run in a scope this wide, so be cautious whenever you think you need to use it.

#### Cancellation through the scope

Before we look at ways to create our own proper scopes, let's see this cancellation and parenting mechanism at work.

Once we're inside a coroutine, for example the body of `launch`, child coroutines become easier to start, as the parameter of these builders is not only a suspending function, but an extension on `CoroutineScope`:

```kotlin
public fun CoroutineScope.launch(
    context: CoroutineContext = EmptyCoroutineContext,
    block: suspend CoroutineScope.() -> Unit
): Job
```

This scope, which you can then start new coroutines in will be inherited from the outer coroutine, and immediately makes any nested coroutines children of the outer one.

So if we `launch` in `GlobalScope` at first, we can then nest `async` calls in it without specifying a scope again, as the `this` reference points to a `CoroutineScope`. That's what we're calling our nested builders on.

These nested coroutines will contain the `Job` of the outer coroutine (`launch`, in this case) as their parent, so if either of them fails, the parent and siblings also get cancelled! The scope ties our coroutines together nicely.

```kotlin
GlobalScope.launch { // this: CoroutineScope
    val data1 = async { getData(1) }
    val data2 = async { getData(2) }

    val result = data1.await() + data2.await()
    println("Result is $result")
}
```

#### What's in a scope?

Alright, time to define our own scope. It would be helpful to take a look at what a `CoroutineScope` looks like at the code level now:

```kotlin
public interface CoroutineScope {
    public val coroutineContext: CoroutineContext
}
```

There's not much to it. It really just contains a `CoroutineContext`, which will be used by every coroutine that's launched in this scope. This is the sort of behaviour that we were looking for.

However, our coroutine builders already took a `CoroutineContext` as their parameter. If they're also called on a `CoroutineScope` which supplies a context, which one wins? 

It turns out that they're combined using the rules we've learned earlier. This happens left-to-right again, so for each type of element, if it's present in both, the one from the parameter context will override the one from the scope. This reinforces the notion that the scope provides a _default_ context of kinds for coroutines started inside it, and the parameter can be used to adjust it when really necessary (for example, to choose a different Dispatcher).

#### Custom scopes

Getting back to our `Activity`, a common solution used to be to make your *lifecycle-having* components implement the `CoroutineScope` interface directly, like so:

```kotlin
class MainActivity : Activity(), CoroutineScope {
    override val coroutineContext = Job() + Dispatchers.Main

    override fun onDestroy() {
        super.onDestroy()
        coroutineContext.cancel()
    }

    fun onClick() {
        launch() {
            // Do stuff to handle button clicks
        }
    }
}
```

This is pretty convenient, as we can use coroutine builders with the scope implicitly being applied to them, so if we just don't specify a context in their parameters, they'll use what they get from the scope!

However, a new style of using scopes seems to be taking over, and [is now officially recommended too](https://github.com/Kotlin/kotlinx.coroutines/issues/1581), which is to *contain* a `CoroutineScope` and explicitly start coroutines in it, instead of implementing it and using it implicitly.

- This, yet again, is composition over inheritance, as advocated by *Effective Java* and many others. One obvious win by containing a scope will be that we can make it `private`. With the implementation above, any piece of code that gets a reference to a `MainActivity` sees that it's a `CoroutineScope`, and can create coroutines in this scope! Probably not something we want to allow.
- Coroutines like being explicit about what's happening. If you write down the scope you start a coroutine in, you're forced to choose to use that scope for the coroutine. Forcing developers to think about this decision is why `CoroutineScope` was introduced in the first place.

Let's see how we can create a `CoroutineScope` that will be contained by an `Activity`. We can simply call a ["constructor"](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-coroutine-scope.html) again, passing in a `CoroutineContext` that we want the scope to contain:

```kotlin
class MainActivity : Activity() {
    private val scope: CoroutineScope = CoroutineScope(Job() + Dispatchers.Main)

    override fun onDestroy() {
        super.onDestroy()
        scope.cancel()
    }

    fun onClick() {
        scope.launch() {
            // Do stuff to handle button clicks
        }
    }
}
```

Note how we now explicitly specify the scope being used.

> If you don't put a parent `Job` in a `CoroutineScope` created this way, it'll create an empty `Job` to serve as the parent for nested coroutines. After all, 90% of why `CoroutineScope` exists is to support proper cancellation of nested jobs.

> [`SupervisorJob`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/-supervisor-job.html) is worth a look if you're creating your own scope, as you might want it to replace this empty parent job a lot of cases.

### One last builder

With most of the examples shown, we'd run into an issue if we were to run them in just a simple `main` function. For example, take this code:

```kotlin
fun main() {
    GlobalScope.launch {
        delay(100)
        println("Coroutines!")
    }

    println("Goodbye.")
}
```

Running this will print `Goodbye.` and then terminate the application. Running coroutines will not keep a JVM console application alive (they are on daemon threads). This is not an issue with applications that have a GUI and an event loop that's constantly kept alive, but a console app like this terminates just a bit too eagerly. One hacky workaround is to just sleep the main thread for long enough that the coroutines complete:

```kotlin
fun main() {
    GlobalScope.launch {
        delay(100)
        println("Coroutines!")
    }

    Thread.sleep(1000L)
    println("Goodbye.")
}
```

... which is what we've been doing in previous examples, but we can also do better.

There is a third coroutine builder worth being familiar with, [`runBlocking`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/run-blocking.html). This builder also launches the suspending function passed to it as a parameter in a new coroutine, however, it doesn't return until that coroutine completes.

This should never be used inside a coroutine. Its purpose, really, is to give an entry point to the coroutine world from `main` functions, and in tests (for similar reasons).

> `runBlocking` is useful for tests, but there is also a dedicated `kotlinx.coroutines.test` library, which includes lots of testing utilities, such as [`runTest`](https://kotlinlang.org/api/kotlinx.coroutines/kotlinx-coroutines-test/kotlinx.coroutines.test/run-test.html). 

Using `runBlocking`, we don't need that manual wait anymore in the previous example, we can just place our code inside its body directly:

```kotlin
fun main() {
    runBlocking {
        delay(1000)
        println("Hello world!")
    }
}
```

... or start a child coroutine inside it, which the parent will wait for to complete anyway:

```kotlin
fun main() {
    runBlocking { 
        launch {
            delay(1000)
            println("Hello world!")
        }
    }
}
```

There's also one more, fancy shortcut we can take if we need a `main` function to run coroutines: we can mark it with the `suspend` keyword:

```kotlin
suspend fun main() {
    delay(1000)
    println("Hello world!")
}
```

### Wrapping a callback

There are many existing libraries that use callback-based APIs. These would normally force all your code to operate in a callback-based manner, but they can be integrated nicely with coroutines by converting calls to these APIs into suspending calls instead, using extension functions.

Take a callback-based API like this one:

```java
public abstract class Task<T> {
    public interface OnCompleteListener<T> {
        void onComplete(T result);
        void onError(Throwable exception);
    }

    protected OnCompleteListener<T> listener;

    public void setListener(OnCompleteListener<T> listener) {
        this.listener = listener;
    }
}
```

Methods called in a library that contains this `Task` type can shoot off asynchronous calls on background threads, and return a `Task` as their result. It's your task to attach a listener to this task, so that you're notified of its completion:

```kotlin
getUsername().setListener(object : Task.OnCompleteListener<String?> {
    override fun onComplete(result: String?) {
        println("Success: $result")
    }

    override fun onError(exception: Throwable?) {
        println("Error: $exception")
    }
})
```

This `setListener` call returns immediately, and the callbacks inside it will be invoked at a later time. We would rather suspend at this point, so that we can keep writing sequential code that should run after this asynchronous waiting for a result has completed.

We can extend the `Task` type with an extension function that is named `await` by tradition:

```kotlin
suspend fun <T> Task<T>.await(): T = suspendCoroutine { cont ->
    this.setListener(object : Task.OnCompleteListener<T> {
        override fun onComplete(result: T) {
            cont.resume(result)
        }

        override fun onError(exception: Throwable) {
            cont.resumeWithException(exception)
        }
    })
}
```

This suspending function uses the [`suspendCoroutine`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/suspend-coroutine.html) function to - guess what - suspend the currently running coroutine. We have a suspension point!

The lambda passed to `suspendCoroutine` receives a [`Continuation`](https://kotlinlang.org/api/latest/jvm/stdlib/kotlin.coroutines/-continuation/index.html) as its parameter, and we can manually use this `Continuation` to either resume the coroutine at the suspension point by producing a result, or by throwing an exception at the suspension point by providing a `Throwable`. We simply hook these two calls up with the appropriate callbacks in our `Task` API, and we're good to go!

```kotlin
suspend fun main() {
    val name = getUsername().await()
    println(name)
}
```

We can now get a `Task` from the API and simply `await` it in a suspending way. Awesome!

> [`suspendCancellableCoroutine`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines/suspend-cancellable-coroutine.html) from `kotlinx-coroutines` is an even nicer way of doing this, with handling of coroutine cancellation.

> This pattern used to be the way to integrate Retrofit calls with coroutine-based applications, and Firebase APIs are also a [prime example](https://joebirch.co/2019/10/03/using-firebase-on-android-with-kotlin-coroutines/) where this can come in handy during Android development.

## Summary

Coroutines definitely take a bit of getting used to. They're not a trivial concept by any means, but once they click, they unlock very, very powerful asynchronous programming. They are stable, production-ready, and enjoy widespread use - for example, they have taken the Android world by storm, replacing Rx in many applications.

They're also one of the best examples of pushing Kotlin's language features to the limit, both in their API and implementation. You are encouraged to dive into the code of some of the APIs that you use when dealing with coroutines - you'll be sure to find very neat solutions in there.

There's much more to coroutines than what we had a chance to cover. Most importantly, the [`Flow`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.flow/-flow/) type built on top of coroutines lets you model asynchronous streams of data. See the [official documentation on Flow](https://kotlinlang.org/docs/flow.html) to get started.

For some less common topics, there are also [`Channel`](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/-channel/index.html)s and [actors](https://kotlin.github.io/kotlinx.coroutines/kotlinx-coroutines-core/kotlinx.coroutines.channels/actor.html) and much more to discover. You can learn about these on your own, as you need them. You'll find some sources below to get started..

## Sources

- [kotlinx.coroutines guide](https://github.com/Kotlin/kotlinx.coroutines/blob/master/docs/topics/coroutines-guide.md)
- [What Color is Your Function?](https://journal.stuffwithstuff.com/2015/02/01/what-color-is-your-function/)
- Async, concurrent, parallel, and so on
  - [Concurrency, Parallelism, Threads, Processes, Async, and Sync](https://medium.com/swift-india/concurrency-parallelism-threads-processes-async-and-sync-related-39fd951bc61d)
  - [StackOverflow answer 1](https://stackoverflow.com/a/36604522/4465208)
  - [StackOverflow answer 2](https://stackoverflow.com/a/748189/4465208)
- [Demystifying CoroutineContext](https://proandroiddev.com/demystifying-coroutinecontext-1ce5b68407ad)
- [Marcin Moskała - Understanding Kotlin Coroutines](https://www.youtube.com/watch?v=DOoJnJJnAG4)
- [KotlinConf 2017 - Introduction to Coroutines by Roman Elizarov](https://www.youtube.com/watch?v=_hfBv0a09Jc)
- [Kotlin Coroutines (Andrey Breslav, 2016)](https://www.youtube.com/watch?v=4W3ruTWUhpw)
- Roman Elizarov's blog
  - [How do you color your functions?](https://medium.com/@elizarov/how-do-you-color-your-functions-a6bb423d936d)
  - [Blocking threads, suspending coroutines](https://medium.com/@elizarov/blocking-threads-suspending-coroutines-d33e11bf4761)
  - [Explicit concurrency](https://medium.com/@elizarov/explicit-concurrency-67a8e8fd9b25)
  - [The reason to avoid GlobalScope](https://medium.com/@elizarov/the-reason-to-avoid-globalscope-835337445abc)
  - [Coroutine Context and Scope](https://medium.com/@elizarov/coroutine-context-and-scope-c8b255d59055)
- [Update CoroutineScope docs to recommend explicit scope](https://github.com/Kotlin/kotlinx.coroutines/issues/1581)) 
- [Wrapping Callbacks](https://github.com/Kotlin/KEEP/blob/master/proposals/coroutines.md#wrapping-callbacks)
- [Using Firebase on Android with Kotlin coroutines](https://joebirch.co/android/using-firebase-on-android-with-kotlin-coroutines/)
